diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/Android.mk b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/Android.mk
index 2104398..b9cf6e5 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/Android.mk
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/Android.mk
@@ -5,9 +5,11 @@ LOCAL_PATH := $(call my-dir)
 
 commonSources := \
         GLClientState.cpp \
+        GLESTextureUtils.cpp \
         ChecksumCalculator.cpp \
         GLSharedGroup.cpp \
         glUtils.cpp \
+        IndexRangeCache.cpp \
         SocketStream.cpp \
         TcpStream.cpp \
 
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.cpp
index 60940b8..8983524 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.cpp
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.cpp
@@ -16,30 +16,17 @@
 
 #include "ChecksumCalculator.h"
 
-#include <string>
-#include <vector>
 #include <string.h>
 
 // Checklist when implementing new protocol:
 // 1. update CHECKSUMHELPER_MAX_VERSION
-// 2. update maxChecksumSize()
+// 2. update ChecksumCalculator::Sizes enum
 // 3. update checksumByteSize()
 // 4. update addBuffer, writeChecksum, resetChecksum, validate
 
 // change CHECKSUMHELPER_MAX_VERSION when you want to update the protocol version
 #define CHECKSUMHELPER_MAX_VERSION 1
 
-// checksum buffer size
-// Please add a new checksum buffer size when implementing a new protocol,
-// as well as modifying the maxChecksumSize function.
-static const size_t kV1ChecksumSize = 8;
-
-static constexpr size_t maxChecksumSize() {
-    return 0 > kV1ChecksumSize ? 0 : kV1ChecksumSize;
-}
-
-static const size_t kMaxChecksumSize = maxChecksumSize();
-
 // utility macros to create checksum string at compilation time
 #define CHECKSUMHELPER_VERSION_STR_PREFIX "ANDROID_EMU_CHECKSUM_HELPER_v"
 #define CHECKSUMHELPER_MACRO_TO_STR(x) #x
@@ -86,6 +73,15 @@ size_t ChecksumCalculator::checksumByteSize() const {
     }
 }
 
+ChecksumCalculator::ChecksumCalculator()
+                : m_version(0)
+                , m_numRead(0)
+                , m_numWrite(0)
+                , m_isEncodingChecksum(false)
+                , m_v1BufferTotalLength(0)
+{
+}
+
 void ChecksumCalculator::addBuffer(const void* buf, size_t packetLen) {
     m_isEncodingChecksum = true;
     switch (m_version) {
@@ -127,17 +123,22 @@ bool ChecksumCalculator::validate(const void* expectedChecksum, size_t expectedC
         resetChecksum();
         return false;
     }
-    // buffers for computing the checksum
-    unsigned char sChecksumBuffer[kMaxChecksumSize];
+    bool isValid;
     switch (m_version) {
         case 1: {
-            uint32_t val = computeV1Checksum();
-            memcpy(sChecksumBuffer, &val, sizeof(val));
-            memcpy(sChecksumBuffer+sizeof(val), &m_numRead, sizeof(m_numRead));
+            const uint32_t val = computeV1Checksum();
+            isValid = 0 == memcmp(&val, expectedChecksum, sizeof(val)) &&
+                      0 == memcmp(&m_numRead,
+                                  static_cast<const char*>(expectedChecksum) +
+                                          sizeof(val),
+                                  sizeof(m_numRead));
+
             break;
         }
+        default:
+            isValid = true;  // No checksum is a valid checksum.
+            break;
     }
-    bool isValid = !memcmp(sChecksumBuffer, expectedChecksum, checksumSize);
     m_numRead++;
     resetChecksum();
     return isValid;
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.h
index 4cc231a..3494aef 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/ChecksumCalculator.h
@@ -123,6 +123,12 @@
 
 class ChecksumCalculator {
 public:
+    enum Sizes {
+        kVersion1ChecksumSize = 8,
+        kMaxChecksumSize = kVersion1ChecksumSize
+    };
+
+    ChecksumCalculator();
     // Get and set current checksum version
     uint32_t getVersion() const { return m_version; }
     // Call setVersion to set a checksum version. It should be called before
@@ -165,17 +171,17 @@ public:
     // Will reset the list of buffers by calling resetChecksum.
     bool validate(const void* expectedChecksum, size_t expectedChecksumLen);
 protected:
-    uint32_t m_version = 0;
+    uint32_t m_version;
     // A temporary state used to compute the total length of a list of buffers,
     // if addBuffer is called.
-    uint32_t m_numRead = 0;
-    uint32_t m_numWrite = 0;
+    uint32_t m_numRead;
+    uint32_t m_numWrite;
     // m_isEncodingChecksum is true when between addBuffer and writeChecksum
-    bool m_isEncodingChecksum = false;
+    bool m_isEncodingChecksum;
 private:
     // Compute a 32bit checksum
     // Used in protocol v1
     uint32_t computeV1Checksum();
     // The buffer used in protocol version 1 to compute checksum.
-    uint32_t m_v1BufferTotalLength = 0;
+    uint32_t m_v1BufferTotalLength;
 };
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/FixedBuffer.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/FixedBuffer.h
index 7026396..9a908de 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/FixedBuffer.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/FixedBuffer.h
@@ -16,6 +16,8 @@
 #ifndef _FIXED_BUFFER_H
 #define _FIXED_BUFFER_H
 
+#include <cutils/log.h>
+
 class FixedBuffer {
 public:
     FixedBuffer(size_t initialSize = 0) {
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.cpp
index 638eb4c..6e9c8f6 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.cpp
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.cpp
@@ -14,6 +14,7 @@
 * limitations under the License.
 */
 #include "GLClientState.h"
+#include "GLESTextureUtils.h"
 #include "ErrorLog.h"
 #include <stdio.h>
 #include <stdlib.h>
@@ -25,108 +26,259 @@
 #define MAX(a, b) ((a) < (b) ? (b) : (a))
 #endif
 
-GLClientState::GLClientState(int nLocations)
-{
-    if (nLocations < LAST_LOCATION) {
-        nLocations = LAST_LOCATION;
-    }
-    m_nLocations = nLocations;
-    m_states = new VertexAttribState[m_nLocations];
-    for (int i = 0; i < m_nLocations; i++) {
-        m_states[i].enabled = 0;
-        m_states[i].enableDirty = false;
-        m_states[i].data = 0;
-    }
-    m_currentArrayVbo = 0;
-    m_currentIndexVbo = 0;
+// Don't include these in the .h file, or we get weird compile errors.
+#include <GLES3/gl3.h>
+#include <GLES3/gl31.h>
+
+void GLClientState::init() {
+    m_initialized = false;
+    m_nLocations = CODEC_MAX_VERTEX_ATTRIBUTES;
+
+    m_arrayBuffer = 0;
+    m_max_vertex_attrib_bindings = m_nLocations;
+    addVertexArrayObject(0);
+    setVertexArrayObject(0);
     // init gl constans;
-    m_states[VERTEX_LOCATION].glConst = GL_VERTEX_ARRAY;
-    m_states[NORMAL_LOCATION].glConst = GL_NORMAL_ARRAY;
-    m_states[COLOR_LOCATION].glConst = GL_COLOR_ARRAY;
-    m_states[POINTSIZE_LOCATION].glConst = GL_POINT_SIZE_ARRAY_OES;
-    m_states[TEXCOORD0_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD1_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD2_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD3_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD4_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD5_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD6_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[TEXCOORD7_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
-    m_states[MATRIXINDEX_LOCATION].glConst = GL_MATRIX_INDEX_ARRAY_OES;
-    m_states[WEIGHT_LOCATION].glConst = GL_WEIGHT_ARRAY_OES;
+    m_currVaoState[VERTEX_LOCATION].glConst = GL_VERTEX_ARRAY;
+    m_currVaoState[NORMAL_LOCATION].glConst = GL_NORMAL_ARRAY;
+    m_currVaoState[COLOR_LOCATION].glConst = GL_COLOR_ARRAY;
+    m_currVaoState[POINTSIZE_LOCATION].glConst = GL_POINT_SIZE_ARRAY_OES;
+    m_currVaoState[TEXCOORD0_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD1_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD2_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD3_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD4_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD5_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD6_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[TEXCOORD7_LOCATION].glConst = GL_TEXTURE_COORD_ARRAY;
+    m_currVaoState[MATRIXINDEX_LOCATION].glConst = GL_MATRIX_INDEX_ARRAY_OES;
+    m_currVaoState[WEIGHT_LOCATION].glConst = GL_WEIGHT_ARRAY_OES;
+
+    m_copyReadBuffer = 0;
+    m_copyWriteBuffer = 0;
+    m_pixelPackBuffer = 0;
+    m_pixelUnpackBuffer = 0;
+    m_transformFeedbackBuffer = 0;
+    m_uniformBuffer = 0;
+    m_atomicCounterBuffer = 0;
+    m_dispatchIndirectBuffer = 0;
+    m_drawIndirectBuffer = 0;
+    m_shaderStorageBuffer = 0;
+
+    m_transformFeedbackActiveUnpaused = false;
+
+    // to be modified later when these are queried from host.
+    m_max_transform_feedback_separate_attribs = 0;
+    m_max_uniform_buffer_bindings = 0;
+    m_max_atomic_counter_buffer_bindings = 0;
+    m_max_shader_storage_buffer_bindings = 0;
+
     m_activeTexture = 0;
     m_currentProgram = 0;
+    m_currentShaderProgram = 0;
 
     m_pixelStore.unpack_alignment = 4;
     m_pixelStore.pack_alignment = 4;
 
+    m_pixelStore.unpack_row_length = 0;
+    m_pixelStore.unpack_image_height = 0;
+    m_pixelStore.unpack_skip_pixels = 0;
+    m_pixelStore.unpack_skip_rows = 0;
+    m_pixelStore.unpack_skip_images = 0;
+
+    m_pixelStore.pack_row_length = 0;
+    m_pixelStore.pack_skip_pixels = 0;
+    m_pixelStore.pack_skip_rows = 0;
+
     memset(m_tex.unit, 0, sizeof(m_tex.unit));
     m_tex.activeUnit = &m_tex.unit[0];
-    m_tex.textures = NULL;
-    m_tex.numTextures = 0;
-    m_tex.allocTextures = 0;
+    m_tex.textureRecs = NULL;
+
+    mRboState.boundRenderbuffer = 0;
+    mRboState.boundRenderbufferIndex = 0;
+
+    mFboState.boundDrawFramebuffer = 0;
+    mFboState.boundReadFramebuffer = 0;
+    mFboState.drawFboCheckStatus = GL_NONE;
+    mFboState.readFboCheckStatus = GL_NONE;
 
     m_maxVertexAttribsDirty = true;
 }
 
+GLClientState::GLClientState()
+{
+    init();
+}
+
+GLClientState::GLClientState(int majorVersion, int minorVersion) :
+    m_glesMajorVersion(majorVersion),
+    m_glesMinorVersion(minorVersion) {
+    init();
+}
+
 GLClientState::~GLClientState()
 {
-    delete m_states;
 }
 
 void GLClientState::enable(int location, int state)
 {
-    if (!validLocation(location)) {
+    m_currVaoState[location].enableDirty |= (state != m_currVaoState[location].enabled);
+    m_currVaoState[location].enabled = state;
+}
+
+void GLClientState::setVertexAttribState(int location, int size, GLenum type, GLboolean normalized, GLsizei stride, const void *data, bool isInt)
+{
+    m_currVaoState[location].size = size;
+    m_currVaoState[location].type = type;
+    m_currVaoState[location].stride = stride;
+    m_currVaoState[location].data = (void*)data;
+    m_currVaoState[location].bufferObject = m_arrayBuffer;
+    m_currVaoState[location].elementSize = size ? (glSizeof(type) * size) : 0;
+    switch (type) {
+        case GL_INT_2_10_10_10_REV:
+        case GL_UNSIGNED_INT_2_10_10_10_REV:
+            m_currVaoState[location].elementSize =
+                m_currVaoState[location].elementSize / 4;
+            break;
+        default:
+            break;
+    }
+    m_currVaoState[location].normalized = normalized;
+    m_currVaoState[location].isInt = isInt;
+}
+
+void GLClientState::setVertexBindingDivisor(int bindingindex, GLuint divisor) {
+    m_currVaoState.bufferBinding(bindingindex).divisor = divisor;
+}
+
+const GLClientState::BufferBinding& GLClientState::getCurrAttributeBindingInfo(int attribindex) {
+    return m_currVaoState.bufferBindings_const()[m_currVaoState[attribindex].bindingindex];
+}
+
+void GLClientState::setVertexAttribBinding(int attribindex, int bindingindex) {
+    m_currVaoState[attribindex].bindingindex = bindingindex;
+}
+
+void GLClientState::setVertexAttribFormat(int location, int size, GLenum type, GLboolean normalized, GLuint reloffset, bool isInt) {
+    m_currVaoState[location].size = size;
+    m_currVaoState[location].type = type;
+    m_currVaoState[location].normalized = normalized;
+    m_currVaoState[location].reloffset = reloffset;
+    m_currVaoState[location].elementSize = size ? (glSizeof(type) * size) : 0;
+    switch (type) {
+        case GL_INT_2_10_10_10_REV:
+        case GL_UNSIGNED_INT_2_10_10_10_REV:
+            m_currVaoState[location].elementSize =
+                m_currVaoState[location].elementSize / 4;
+            break;
+        default:
+            break;
+    }
+    m_currVaoState[location].isInt = isInt;
+}
+
+void GLClientState::addVertexArrayObjects(GLsizei n, GLuint* arrays) {
+    for (GLsizei i = 0; i < n; i++) {
+        addVertexArrayObject(arrays[i]);
+    }
+}
+
+void GLClientState::removeVertexArrayObjects(GLsizei n, const GLuint* arrays) {
+    for (GLsizei i = 0; i < n; i++) {
+        if (arrays[i] && m_currVaoState.vaoId() == arrays[i]) {
+            setVertexArrayObject(0);
+        }
+        removeVertexArrayObject(arrays[i]);
+    }
+}
+
+void GLClientState::addVertexArrayObject(GLuint name) {
+    if (m_vaoMap.find(name) !=
+        m_vaoMap.end()) {
+        ALOGE("%s: ERROR: %u already part of current VAO state!",
+              __FUNCTION__, name);
         return;
     }
 
-    m_states[location].enableDirty |= (state != m_states[location].enabled);
-    m_states[location].enabled = state;
+    m_vaoMap.insert(
+            VAOStateMap::value_type(
+                name,
+                VAOState(0, m_nLocations, std::max(m_nLocations, m_max_vertex_attrib_bindings))));
+    VertexAttribStateVector& attribState =
+        m_vaoMap.find(name)->second.attribState;
+    for (int i = 0; i < m_nLocations; i++) {
+        attribState[i].enabled = 0;
+        attribState[i].enableDirty = false;
+        attribState[i].data = 0;
+        attribState[i].reloffset = 0;
+        attribState[i].bindingindex = i;
+        attribState[i].divisor = 0;
+        attribState[i].size = 4; // 4 is the default size
+        attribState[i].type = GL_FLOAT; // GL_FLOAT is the default type
+    }
+
+    VertexAttribBindingVector& bindingState =
+        m_vaoMap.find(name)->second.bindingState;
+    for (int i = 0; i < bindingState.size(); i++) {
+        bindingState[i].effectiveStride = 16;
+    }
 }
 
-void GLClientState::setState(int location, int size, GLenum type, GLboolean normalized, GLsizei stride, const void *data)
-{
-    if (!validLocation(location)) {
+void GLClientState::removeVertexArrayObject(GLuint name) {
+    if (name == 0) {
+        ALOGE("%s: ERROR: cannot delete VAO 0!",
+              __FUNCTION__);
         return;
     }
-    m_states[location].size = size;
-    m_states[location].type = type;
-    m_states[location].stride = stride;
-    m_states[location].data = (void*)data;
-    m_states[location].bufferObject = m_currentArrayVbo;
-    m_states[location].elementSize = size ? (glSizeof(type) * size) : 0;
-    m_states[location].normalized = normalized;
+    if (m_vaoMap.find(name) ==
+        m_vaoMap.end()) {
+        ALOGE("%s: ERROR: %u not found in VAO state!",
+              __FUNCTION__, name);
+        return;
+    }
+    m_vaoMap.erase(name);
 }
 
-void GLClientState::setBufferObject(int location, GLuint id)
-{
-    if (!validLocation(location)) {
+void GLClientState::setVertexArrayObject(GLuint name) {
+    if (m_vaoMap.find(name) ==
+        m_vaoMap.end()) {
+        ALOGE("%s: ERROR: %u not found in VAO state!",
+              __FUNCTION__, name);
         return;
     }
 
-    m_states[location].bufferObject = id;
+    if (name && m_currVaoState.vaoId() == name) {
+        ALOGV("%s: set vao to self, no-op (%u)",
+              __FUNCTION__, name);
+        return;
+    }
+
+    m_currVaoState =
+        VAOStateRef(m_vaoMap.find(name));
+    ALOGV("%s: set vao to %u (%u) %u %u", __FUNCTION__,
+            name,
+            m_currVaoState.vaoId(),
+            m_arrayBuffer,
+            m_currVaoState.iboId());
 }
 
-const GLClientState::VertexAttribState * GLClientState::getState(int location)
-{
-    if (!validLocation(location)) {
-        return NULL;
-    }
-    return & m_states[location];
+bool GLClientState::isVertexArrayObject(GLuint vao) const {
+    return m_vaoMap.find(vao) != m_vaoMap.end();
 }
 
-const GLClientState::VertexAttribState * GLClientState::getStateAndEnableDirty(int location, bool *enableChanged)
+const GLClientState::VertexAttribState& GLClientState::getState(int location)
 {
-    if (!validLocation(location)) {
-        return NULL;
-    }
+    return m_currVaoState[location];
+}
 
+const GLClientState::VertexAttribState& GLClientState::getStateAndEnableDirty(int location, bool *enableChanged)
+{
     if (enableChanged) {
-        *enableChanged = m_states[location].enableDirty;
+        *enableChanged = m_currVaoState[location].enableDirty;
     }
 
-    m_states[location].enableDirty = false;
-    return & m_states[location];
+    m_currVaoState[location].enableDirty = false;
+    return m_currVaoState[location];
 }
 
 int GLClientState::getLocation(GLenum loc)
@@ -161,41 +313,239 @@ int GLClientState::getLocation(GLenum loc)
     return retval;
 }
 
+static void sClearIndexedBufferBinding(GLuint id, std::vector<GLClientState::BufferBinding>& bindings) {
+    for (size_t i = 0; i < bindings.size(); i++) {
+        if (bindings[i].buffer == id) {
+            bindings[i].offset = 0;
+            bindings[i].stride = 0;
+            bindings[i].effectiveStride = 16;
+            bindings[i].size = 0;
+            bindings[i].buffer = 0;
+            bindings[i].divisor = 0;
+        }
+    }
+}
+
+void GLClientState::addBuffer(GLuint id) {
+    mBufferIds.insert(id);
+}
+
+void GLClientState::removeBuffer(GLuint id) {
+    mBufferIds.erase(id);
+}
+
+bool GLClientState::bufferIdExists(GLuint id) const {
+    return mBufferIds.find(id) != mBufferIds.end();
+}
+
+void GLClientState::unBindBuffer(GLuint id) {
+    if (m_arrayBuffer == id) m_arrayBuffer = 0;
+    if (m_currVaoState.iboId() == id) m_currVaoState.iboId() = 0;
+    if (m_copyReadBuffer == id)
+        m_copyReadBuffer = 0;
+    if (m_copyWriteBuffer == id)
+        m_copyWriteBuffer = 0;
+    if (m_pixelPackBuffer == id)
+        m_pixelPackBuffer = 0;
+    if (m_pixelUnpackBuffer == id)
+        m_pixelUnpackBuffer = 0;
+    if (m_transformFeedbackBuffer == id)
+        m_transformFeedbackBuffer = 0;
+    if (m_uniformBuffer == id)
+        m_uniformBuffer = 0;
+    if (m_atomicCounterBuffer == id)
+        m_atomicCounterBuffer = 0;
+    if (m_dispatchIndirectBuffer == id)
+        m_dispatchIndirectBuffer = 0;
+    if (m_drawIndirectBuffer == id)
+        m_drawIndirectBuffer = 0;
+    if (m_shaderStorageBuffer == id)
+        m_shaderStorageBuffer = 0;
+
+    sClearIndexedBufferBinding(id, m_indexedTransformFeedbackBuffers);
+    sClearIndexedBufferBinding(id, m_indexedUniformBuffers);
+    sClearIndexedBufferBinding(id, m_indexedAtomicCounterBuffers);
+    sClearIndexedBufferBinding(id, m_indexedShaderStorageBuffers);
+    sClearIndexedBufferBinding(id, m_currVaoState.bufferBindings());
+}
+
+int GLClientState::bindBuffer(GLenum target, GLuint id)
+{
+    int err = 0;
+    switch(target) {
+    case GL_ARRAY_BUFFER:
+        m_arrayBuffer = id;
+        break;
+    case GL_ELEMENT_ARRAY_BUFFER:
+        m_currVaoState.iboId() = id;
+        break;
+    case GL_COPY_READ_BUFFER:
+        m_copyReadBuffer = id;
+        break;
+    case GL_COPY_WRITE_BUFFER:
+        m_copyWriteBuffer = id;
+        break;
+    case GL_PIXEL_PACK_BUFFER:
+        m_pixelPackBuffer = id;
+        break;
+    case GL_PIXEL_UNPACK_BUFFER:
+        m_pixelUnpackBuffer = id;
+        break;
+    case GL_TRANSFORM_FEEDBACK_BUFFER:
+        m_transformFeedbackBuffer = id;
+        break;
+    case GL_UNIFORM_BUFFER:
+        m_uniformBuffer = id;
+        break;
+    case GL_ATOMIC_COUNTER_BUFFER:
+        m_atomicCounterBuffer = id;
+        break;
+    case GL_DISPATCH_INDIRECT_BUFFER:
+        m_dispatchIndirectBuffer = id;
+        break;
+    case GL_DRAW_INDIRECT_BUFFER:
+        m_drawIndirectBuffer = id;
+        break;
+    case GL_SHADER_STORAGE_BUFFER:
+        m_shaderStorageBuffer = id;
+        break;
+    default:
+        err = -1;
+    }
+    return err;
+}
+
+void GLClientState::bindIndexedBuffer(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, GLintptr stride, GLintptr effectiveStride) {
+    switch (target) {
+    case GL_TRANSFORM_FEEDBACK_BUFFER:
+        m_indexedTransformFeedbackBuffers[index].buffer = buffer;
+        m_indexedTransformFeedbackBuffers[index].offset = offset;
+        m_indexedTransformFeedbackBuffers[index].size = size;
+        m_indexedTransformFeedbackBuffers[index].stride = stride;
+        break;
+    case GL_UNIFORM_BUFFER:
+        m_indexedUniformBuffers[index].buffer = buffer;
+        m_indexedUniformBuffers[index].offset = offset;
+        m_indexedUniformBuffers[index].size = size;
+        m_indexedUniformBuffers[index].stride = stride;
+        break;
+    case GL_ATOMIC_COUNTER_BUFFER:
+        m_indexedAtomicCounterBuffers[index].buffer = buffer;
+        m_indexedAtomicCounterBuffers[index].offset = offset;
+        m_indexedAtomicCounterBuffers[index].size = size;
+        m_indexedAtomicCounterBuffers[index].stride = stride;
+        break;
+    case GL_SHADER_STORAGE_BUFFER:
+        m_indexedShaderStorageBuffers[index].buffer = buffer;
+        m_indexedShaderStorageBuffers[index].offset = offset;
+        m_indexedShaderStorageBuffers[index].size = size;
+        m_indexedShaderStorageBuffers[index].stride = stride;
+        break;
+    default:
+        m_currVaoState.bufferBinding(index).buffer = buffer;
+        m_currVaoState.bufferBinding(index).offset = offset;
+        m_currVaoState.bufferBinding(index).size = size;
+        m_currVaoState.bufferBinding(index).stride = stride;
+        m_currVaoState.bufferBinding(index).effectiveStride = effectiveStride;
+        return;
+    }
+}
+
+int GLClientState::getMaxIndexedBufferBindings(GLenum target) const {
+    switch (target) {
+    case GL_TRANSFORM_FEEDBACK_BUFFER:
+        return m_indexedTransformFeedbackBuffers.size();
+    case GL_UNIFORM_BUFFER:
+        return m_indexedUniformBuffers.size();
+    case GL_ATOMIC_COUNTER_BUFFER:
+        return m_indexedAtomicCounterBuffers.size();
+    case GL_SHADER_STORAGE_BUFFER:
+        return m_indexedShaderStorageBuffers.size();
+    default:
+        return m_currVaoState.bufferBindings_const().size();
+    }
+}
+
+int GLClientState::getBuffer(GLenum target) {
+    int ret=0;
+    switch (target) {
+        case GL_ARRAY_BUFFER:
+            ret = m_arrayBuffer;
+            break;
+        case GL_ELEMENT_ARRAY_BUFFER:
+            ret = m_currVaoState.iboId();
+            break;
+        case GL_COPY_READ_BUFFER:
+            ret = m_copyReadBuffer;
+            break;
+        case GL_COPY_WRITE_BUFFER:
+            ret = m_copyWriteBuffer;
+            break;
+        case GL_PIXEL_PACK_BUFFER:
+            ret = m_pixelPackBuffer;
+            break;
+        case GL_PIXEL_UNPACK_BUFFER:
+            ret = m_pixelUnpackBuffer;
+            break;
+        case GL_TRANSFORM_FEEDBACK_BUFFER:
+            ret = m_transformFeedbackBuffer;
+            break;
+        case GL_UNIFORM_BUFFER:
+            ret = m_uniformBuffer;
+            break;
+        case GL_ATOMIC_COUNTER_BUFFER:
+            ret = m_atomicCounterBuffer;
+            break;
+        case GL_DISPATCH_INDIRECT_BUFFER:
+            ret = m_dispatchIndirectBuffer;
+            break;
+        case GL_DRAW_INDIRECT_BUFFER:
+            ret = m_drawIndirectBuffer;
+            break;
+        case GL_SHADER_STORAGE_BUFFER:
+            ret = m_shaderStorageBuffer;
+            break;
+        default:
+            ret = -1;
+    }
+    return ret;
+}
+
 void GLClientState::getClientStatePointer(GLenum pname, GLvoid** params)
 {
-    const GLClientState::VertexAttribState *state = NULL;
+    GLenum which_state = -1;
     switch (pname) {
     case GL_VERTEX_ARRAY_POINTER: {
-        state = getState(GLClientState::VERTEX_LOCATION);
+        which_state = GLClientState::VERTEX_LOCATION;
         break;
         }
     case GL_NORMAL_ARRAY_POINTER: {
-        state = getState(GLClientState::NORMAL_LOCATION);
+        which_state = GLClientState::NORMAL_LOCATION;
         break;
         }
     case GL_COLOR_ARRAY_POINTER: {
-        state = getState(GLClientState::COLOR_LOCATION);
+        which_state = GLClientState::COLOR_LOCATION;
         break;
         }
     case GL_TEXTURE_COORD_ARRAY_POINTER: {
-        state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
+        which_state = getActiveTexture() + GLClientState::TEXCOORD0_LOCATION;
         break;
         }
     case GL_POINT_SIZE_ARRAY_POINTER_OES: {
-        state = getState(GLClientState::POINTSIZE_LOCATION);
+        which_state = GLClientState::POINTSIZE_LOCATION;
         break;
         }
     case GL_MATRIX_INDEX_ARRAY_POINTER_OES: {
-        state = getState(GLClientState::MATRIXINDEX_LOCATION);
+        which_state = GLClientState::MATRIXINDEX_LOCATION;
         break;
         }
     case GL_WEIGHT_ARRAY_POINTER_OES: {
-        state = getState(GLClientState::WEIGHT_LOCATION);
+        which_state = GLClientState::WEIGHT_LOCATION;
         break;
         }
     }
-    if (state && params)
-        *params = state->data;
+    if (which_state != -1)
+        *params = getState(which_state).data;
 }
 
 int GLClientState::setPixelStore(GLenum param, GLint value)
@@ -203,46 +553,148 @@ int GLClientState::setPixelStore(GLenum param, GLint value)
     int retval = 0;
     switch(param) {
     case GL_UNPACK_ALIGNMENT:
-        if (value == 1 || value == 2 || value == 4 || value == 8) {
-            m_pixelStore.unpack_alignment = value;
-        } else {
-            retval =  GL_INVALID_VALUE;
-        }
+        m_pixelStore.unpack_alignment = value;
         break;
     case GL_PACK_ALIGNMENT:
-        if (value == 1 || value == 2 || value == 4 || value == 8) {
-            m_pixelStore.pack_alignment = value;
-        } else {
-            retval =  GL_INVALID_VALUE;
-        }
+        m_pixelStore.pack_alignment = value;
         break;
-        default:
-            retval = GL_INVALID_ENUM;
+    case GL_UNPACK_ROW_LENGTH:
+        m_pixelStore.unpack_row_length = value;
+        break;
+    case GL_UNPACK_IMAGE_HEIGHT:
+        m_pixelStore.unpack_image_height = value;
+        break;
+    case GL_UNPACK_SKIP_PIXELS:
+        m_pixelStore.unpack_skip_pixels = value;
+        break;
+    case GL_UNPACK_SKIP_ROWS:
+        m_pixelStore.unpack_skip_rows = value;
+        break;
+    case GL_UNPACK_SKIP_IMAGES:
+        m_pixelStore.unpack_skip_images = value;
+        break;
+    case GL_PACK_ROW_LENGTH:
+        m_pixelStore.pack_row_length = value;
+        break;
+    case GL_PACK_SKIP_PIXELS:
+        m_pixelStore.pack_skip_pixels = value;
+        break;
+    case GL_PACK_SKIP_ROWS:
+        m_pixelStore.pack_skip_rows = value;
+        break;
+    default:
+        retval = GL_INVALID_ENUM;
     }
     return retval;
 }
 
 
+size_t GLClientState::pixelDataSize(GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, int pack) const
+{
+    if (width <= 0 || height <= 0 || depth <= 0) return 0;
 
+    ALOGV("%s: pack? %d", __FUNCTION__, pack);
+    if (pack) {
+        ALOGV("%s: pack stats", __FUNCTION__);
+        ALOGV("%s: pack align %d", __FUNCTION__, m_pixelStore.pack_alignment);
+        ALOGV("%s: pack rowlen %d", __FUNCTION__, m_pixelStore.pack_row_length);
+        ALOGV("%s: pack skippixels %d", __FUNCTION__, m_pixelStore.pack_skip_pixels);
+        ALOGV("%s: pack skiprows %d", __FUNCTION__, m_pixelStore.pack_skip_rows);
+    } else {
+        ALOGV("%s: unpack stats", __FUNCTION__);
+        ALOGV("%s: unpack align %d", __FUNCTION__, m_pixelStore.unpack_alignment);
+        ALOGV("%s: unpack rowlen %d", __FUNCTION__, m_pixelStore.unpack_row_length);
+        ALOGV("%s: unpack imgheight %d", __FUNCTION__, m_pixelStore.unpack_image_height);
+        ALOGV("%s: unpack skippixels %d", __FUNCTION__, m_pixelStore.unpack_skip_pixels);
+        ALOGV("%s: unpack skiprows %d", __FUNCTION__, m_pixelStore.unpack_skip_rows);
+        ALOGV("%s: unpack skipimages %d", __FUNCTION__, m_pixelStore.unpack_skip_images);
+    }
+    return GLESTextureUtils::computeTotalImageSize(
+            width, height, depth,
+            format, type,
+            pack ? m_pixelStore.pack_alignment : m_pixelStore.unpack_alignment,
+            pack ? m_pixelStore.pack_row_length : m_pixelStore.unpack_row_length,
+            pack ? 0 : m_pixelStore.unpack_image_height,
+            pack ? m_pixelStore.pack_skip_pixels : m_pixelStore.unpack_skip_pixels,
+            pack ? m_pixelStore.pack_skip_rows : m_pixelStore.unpack_skip_rows,
+            pack ? 0 : m_pixelStore.unpack_skip_images);
+}
 
-size_t GLClientState::pixelDataSize(GLsizei width, GLsizei height, GLenum format, GLenum type, int pack) const
+size_t GLClientState::pboNeededDataSize(GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, int pack) const
 {
-    if (width <= 0 || height <= 0) return 0;
+    if (width <= 0 || height <= 0 || depth <= 0) return 0;
 
-    int pixelsize = glUtilsPixelBitSize(format, type) >> 3;
+    ALOGV("%s: pack? %d", __FUNCTION__, pack);
+    if (pack) {
+        ALOGV("%s: pack stats", __FUNCTION__);
+        ALOGV("%s: pack align %d", __FUNCTION__, m_pixelStore.pack_alignment);
+        ALOGV("%s: pack rowlen %d", __FUNCTION__, m_pixelStore.pack_row_length);
+        ALOGV("%s: pack skippixels %d", __FUNCTION__, m_pixelStore.pack_skip_pixels);
+        ALOGV("%s: pack skiprows %d", __FUNCTION__, m_pixelStore.pack_skip_rows);
+    } else {
+        ALOGV("%s: unpack stats", __FUNCTION__);
+        ALOGV("%s: unpack align %d", __FUNCTION__, m_pixelStore.unpack_alignment);
+        ALOGV("%s: unpack rowlen %d", __FUNCTION__, m_pixelStore.unpack_row_length);
+        ALOGV("%s: unpack imgheight %d", __FUNCTION__, m_pixelStore.unpack_image_height);
+        ALOGV("%s: unpack skippixels %d", __FUNCTION__, m_pixelStore.unpack_skip_pixels);
+        ALOGV("%s: unpack skiprows %d", __FUNCTION__, m_pixelStore.unpack_skip_rows);
+        ALOGV("%s: unpack skipimages %d", __FUNCTION__, m_pixelStore.unpack_skip_images);
+    }
+    return GLESTextureUtils::computeNeededBufferSize(
+            width, height, depth,
+            format, type,
+            pack ? m_pixelStore.pack_alignment : m_pixelStore.unpack_alignment,
+            pack ? m_pixelStore.pack_row_length : m_pixelStore.unpack_row_length,
+            pack ? 0 : m_pixelStore.unpack_image_height,
+            pack ? m_pixelStore.pack_skip_pixels : m_pixelStore.unpack_skip_pixels,
+            pack ? m_pixelStore.pack_skip_rows : m_pixelStore.unpack_skip_rows,
+            pack ? 0 : m_pixelStore.unpack_skip_images);
+}
 
-    int alignment = pack ? m_pixelStore.pack_alignment : m_pixelStore.unpack_alignment;
 
-    if (pixelsize == 0 ) {
-        ERR("unknown pixel size: width: %d height: %d format: %d type: %d pack: %d align: %d\n",
-             width, height, format, type, pack, alignment);
-    }
-    size_t linesize = pixelsize * width;
-    size_t aligned_linesize = int(linesize / alignment) * alignment;
-    if (aligned_linesize < linesize) {
-        aligned_linesize += alignment;
+size_t GLClientState::clearBufferNumElts(GLenum buffer) const
+{
+    switch (buffer) {
+    case GL_COLOR:
+        return 4;
+    case GL_DEPTH:
+    case GL_STENCIL:
+        return 1;
     }
-    return aligned_linesize * height;
+    return 1;
+}
+
+void GLClientState::setNumActiveUniformsInUniformBlock(GLuint program, GLuint uniformBlockIndex, GLint numActiveUniforms) {
+    UniformBlockInfoKey key;
+    key.program = program;
+    key.uniformBlockIndex = uniformBlockIndex;
+
+    UniformBlockUniformInfo info;
+    info.numActiveUniforms = (size_t)numActiveUniforms;
+
+    m_uniformBlockInfoMap[key] = info;
+}
+
+size_t GLClientState::numActiveUniformsInUniformBlock(GLuint program, GLuint uniformBlockIndex) const {
+    UniformBlockInfoKey key;
+    key.program = program;
+    key.uniformBlockIndex = uniformBlockIndex;
+    UniformBlockInfoMap::const_iterator it =
+        m_uniformBlockInfoMap.find(key);
+    if (it == m_uniformBlockInfoMap.end()) return 0;
+    return it->second.numActiveUniforms;
+}
+
+void GLClientState::associateProgramWithPipeline(GLuint program, GLuint pipeline) {
+    m_programPipelines[program] = pipeline;
+}
+
+GLClientState::ProgramPipelineIterator GLClientState::programPipelineBegin() {
+    return m_programPipelines.begin();
+}
+
+GLClientState::ProgramPipelineIterator GLClientState::programPipelineEnd() {
+    return m_programPipelines.end();
 }
 
 GLenum GLClientState::setActiveTextureUnit(GLenum texture)
@@ -307,21 +759,16 @@ GLenum GLClientState::bindTexture(GLenum target, GLuint texture,
         GLboolean* firstUse)
 {
     GLboolean first = GL_FALSE;
-    TextureRec* texrec = NULL;
-    if (texture != 0) {
-        if (m_tex.textures) {
-            texrec = (TextureRec*)bsearch(&texture, m_tex.textures,
-                    m_tex.numTextures, sizeof(TextureRec), compareTexId);
-        }
-        if (!texrec) {
-            if (!(texrec = addTextureRec(texture, target))) {
-                return GL_OUT_OF_MEMORY;
-            }
-            first = GL_TRUE;
-        }
-        if (target != texrec->target) {
-            return GL_INVALID_OPERATION;
-        }
+
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) {
+        texrec = addTextureRec(texture, target);
+    }
+
+    if (texture && target != texrec->target &&
+        (target != GL_TEXTURE_EXTERNAL_OES &&
+         texrec->target != GL_TEXTURE_EXTERNAL_OES)) {
+        ALOGD("%s: issue GL_INVALID_OPERATION: target 0x%x texrectarget 0x%x texture %u", __FUNCTION__, target, texrec->target, texture);
     }
 
     switch (target) {
@@ -331,6 +778,18 @@ GLenum GLClientState::bindTexture(GLenum target, GLuint texture,
     case GL_TEXTURE_EXTERNAL_OES:
         m_tex.activeUnit->texture[TEXTURE_EXTERNAL] = texture;
         break;
+    case GL_TEXTURE_CUBE_MAP:
+        m_tex.activeUnit->texture[TEXTURE_CUBE_MAP] = texture;
+        break;
+    case GL_TEXTURE_2D_ARRAY:
+        m_tex.activeUnit->texture[TEXTURE_2D_ARRAY] = texture;
+        break;
+    case GL_TEXTURE_3D:
+        m_tex.activeUnit->texture[TEXTURE_3D] = texture;
+        break;
+    case GL_TEXTURE_2D_MULTISAMPLE:
+        m_tex.activeUnit->texture[TEXTURE_2D_MULTISAMPLE] = texture;
+        break;
     }
 
     if (firstUse) {
@@ -340,42 +799,115 @@ GLenum GLClientState::bindTexture(GLenum target, GLuint texture,
     return GL_NO_ERROR;
 }
 
-GLClientState::TextureRec* GLClientState::addTextureRec(GLuint id,
-        GLenum target)
+void GLClientState::setBoundEGLImage(GLenum target, GLeglImageOES image) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return;
+    texrec->boundEGLImage = true;
+}
+
+TextureRec* GLClientState::addTextureRec(GLuint id, GLenum target)
 {
-    if (m_tex.numTextures == m_tex.allocTextures) {
-        const GLuint MAX_TEXTURES = 0xFFFFFFFFu;
+    TextureRec* tex = new TextureRec;
+    tex->id = id;
+    tex->target = target;
+    tex->format = -1;
+    tex->multisamples = 0;
+    tex->immutable = false;
+    tex->boundEGLImage = false;
+    tex->dims = new TextureDims;
 
-        GLuint newAlloc;
-        if (MAX_TEXTURES - m_tex.allocTextures >= m_tex.allocTextures) {
-            newAlloc = MAX(4, 2 * m_tex.allocTextures);
-        } else {
-            if (m_tex.allocTextures == MAX_TEXTURES) {
-                return NULL;
-            }
-            newAlloc = MAX_TEXTURES;
-        }
+    (*(m_tex.textureRecs))[id] = tex;
+    return tex;
+}
 
-        TextureRec* newTextures = (TextureRec*)realloc(m_tex.textures,
-                newAlloc * sizeof(TextureRec));
-        if (!newTextures) {
-            return NULL;
-        }
+TextureRec* GLClientState::getTextureRec(GLuint id) const {
+    SharedTextureDataMap::const_iterator it =
+        m_tex.textureRecs->find(id);
+    if (it == m_tex.textureRecs->end()) {
+        return NULL;
+    }
+    return it->second;
+}
+
+void GLClientState::setBoundTextureInternalFormat(GLenum target, GLint internalformat) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return;
+    texrec->internalformat = internalformat;
+}
 
-        m_tex.textures = newTextures;
-        m_tex.allocTextures = newAlloc;
+void GLClientState::setBoundTextureFormat(GLenum target, GLenum format) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return;
+    texrec->format = format;
+}
+
+void GLClientState::setBoundTextureType(GLenum target, GLenum type) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return;
+    texrec->type = type;
+}
+
+void GLClientState::setBoundTextureDims(GLenum target, GLsizei level, GLsizei width, GLsizei height, GLsizei depth) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) {
+        return;
     }
 
-    TextureRec* tex = m_tex.textures + m_tex.numTextures;
-    TextureRec* prev = tex - 1;
-    while (tex != m_tex.textures && id < prev->id) {
-        *tex-- = *prev--;
+    if (level == -1) {
+        GLsizei curr_width = width;
+        GLsizei curr_height = height;
+        GLsizei curr_depth = depth;
+        GLsizei curr_level = 0;
+
+        while (true) {
+            texrec->dims->widths[curr_level] = curr_width;
+            texrec->dims->heights[curr_level] = curr_height;
+            texrec->dims->depths[curr_level] = curr_depth;
+            if (curr_width >> 1 == 0 &&
+                curr_height >> 1 == 0 &&
+                ((target == GL_TEXTURE_3D && curr_depth == 0) ||
+                 true)) {
+                break;
+            }
+            curr_width = (curr_width >> 1) ? (curr_width >> 1) : 1;
+            curr_height = (curr_height >> 1) ? (curr_height >> 1) : 1;
+            if (target == GL_TEXTURE_3D) {
+                curr_depth = (curr_depth >> 1) ? (curr_depth >> 1) : 1;
+            }
+            curr_level++;
+        }
+
+    } else {
+        texrec->dims->widths[level] = width;
+        texrec->dims->heights[level] = height;
+        texrec->dims->depths[level] = depth;
     }
-    tex->id = id;
-    tex->target = target;
-    m_tex.numTextures++;
+}
 
-    return tex;
+void GLClientState::setBoundTextureSamples(GLenum target, GLsizei samples) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return;
+    texrec->multisamples = samples;
+}
+
+void GLClientState::setBoundTextureImmutableFormat(GLenum target) {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return;
+    texrec->immutable = true;
+}
+
+bool GLClientState::isBoundTextureImmutableFormat(GLenum target) const {
+    GLuint texture = getBoundTexture(target);
+    TextureRec* texrec = getTextureRec(texture);
+    if (!texrec) return false;
+    return texrec->immutable;
 }
 
 GLuint GLClientState::getBoundTexture(GLenum target) const
@@ -385,11 +917,85 @@ GLuint GLClientState::getBoundTexture(GLenum target) const
         return m_tex.activeUnit->texture[TEXTURE_2D];
     case GL_TEXTURE_EXTERNAL_OES:
         return m_tex.activeUnit->texture[TEXTURE_EXTERNAL];
+    case GL_TEXTURE_CUBE_MAP:
+        return m_tex.activeUnit->texture[TEXTURE_CUBE_MAP];
+    case GL_TEXTURE_2D_ARRAY:
+        return m_tex.activeUnit->texture[TEXTURE_2D_ARRAY];
+    case GL_TEXTURE_3D:
+        return m_tex.activeUnit->texture[TEXTURE_3D];
+    case GL_TEXTURE_2D_MULTISAMPLE:
+        return m_tex.activeUnit->texture[TEXTURE_2D_MULTISAMPLE];
     default:
         return 0;
     }
 }
 
+// BEGIN driver workarounds-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
+// (>' ')><(' '<)(>' ')><(' '<)(>' ')><(' '<)(>' ')><(' '<)(>' ')><(' '<)(>' ')>
+
+static bool unreliableInternalFormat(GLenum internalformat) {
+    switch (internalformat) {
+    case GL_LUMINANCE:
+        return true;
+    default:
+        return false;
+    }
+}
+
+void GLClientState::writeCopyTexImageState
+    (GLenum target, GLint level, GLenum internalformat) {
+    if (unreliableInternalFormat(internalformat)) {
+        CubeMapDef entry;
+        entry.id = getBoundTexture(GL_TEXTURE_2D);
+        entry.target = target;
+        entry.level = level;
+        entry.internalformat = internalformat;
+        m_cubeMapDefs.insert(entry);
+    }
+}
+
+static GLenum identifyPositiveCubeMapComponent(GLenum target) {
+    switch (target) {
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+        return GL_TEXTURE_CUBE_MAP_POSITIVE_X;
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+        return GL_TEXTURE_CUBE_MAP_POSITIVE_Y;
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+        return GL_TEXTURE_CUBE_MAP_POSITIVE_Z;
+    default:
+        return 0;
+    }
+}
+
+GLenum GLClientState::copyTexImageNeededTarget
+    (GLenum target, GLint level, GLenum internalformat) {
+    if (unreliableInternalFormat(internalformat)) {
+        GLenum positiveComponent =
+            identifyPositiveCubeMapComponent(target);
+        if (positiveComponent) {
+            CubeMapDef query;
+            query.id = getBoundTexture(GL_TEXTURE_2D);
+            query.target = positiveComponent;
+            query.level = level;
+            query.internalformat = internalformat;
+            if (m_cubeMapDefs.find(query) ==
+                m_cubeMapDefs.end()) {
+                return positiveComponent;
+            }
+        }
+    }
+    return 0;
+}
+
+GLenum GLClientState::copyTexImageLuminanceCubeMapAMDWorkaround
+    (GLenum target, GLint level, GLenum internalformat) {
+    writeCopyTexImageState(target, level, internalformat);
+    return copyTexImageNeededTarget(target, level, internalformat);
+}
+
+// (>' ')><(' '<)(>' ')><(' '<)(>' ')><(' '<)(>' ')><(' '<)(>' ')><(' '<)(>' ')>
+// END driver workarounds-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
+
 void GLClientState::deleteTextures(GLsizei n, const GLuint* textures)
 {
     // Updating the textures array could be made more efficient when deleting
@@ -399,14 +1005,13 @@ void GLClientState::deleteTextures(GLsizei n, const GLuint* textures)
     // - could swap deleted textures to the end and re-sort.
     TextureRec* texrec;
     for (const GLuint* texture = textures; texture != textures + n; texture++) {
-        texrec = (TextureRec*)bsearch(texture, m_tex.textures,
-                m_tex.numTextures, sizeof(TextureRec), compareTexId);
+        texrec = getTextureRec(*texture);
+        if (texrec && texrec->dims) {
+            delete texrec->dims;
+        }
         if (texrec) {
-            const TextureRec* end = m_tex.textures + m_tex.numTextures;
-            memmove(texrec, texrec + 1,
-                    (end - texrec - 1) * sizeof(TextureRec));
-            m_tex.numTextures--;
-
+            m_tex.textureRecs->erase(*texture);
+            delete texrec;
             for (TextureUnit* unit = m_tex.unit;
                  unit != m_tex.unit + MAX_TEXTURE_UNITS;
                  unit++)
@@ -420,3 +1025,747 @@ void GLClientState::deleteTextures(GLsizei n, const GLuint* textures)
         }
     }
 }
+
+// RBO//////////////////////////////////////////////////////////////////////////
+
+void GLClientState::addFreshRenderbuffer(GLuint name) {
+    // if underlying opengl says these are fresh names,
+    // but we are keeping a stale one, reset it.
+    RboProps props;
+    props.target = GL_RENDERBUFFER;
+    props.name = name;
+    props.format = GL_NONE;
+    props.multisamples = 0;
+    props.previouslyBound = false;
+
+    if (usedRenderbufferName(name)) {
+        mRboState.rboData[getRboIndex(name)] = props;
+    } else {
+        mRboState.rboData.push_back(props);
+    }
+}
+
+void GLClientState::addRenderbuffers(GLsizei n, GLuint* renderbuffers) {
+    for (size_t i = 0; i < n; i++) {
+        addFreshRenderbuffer(renderbuffers[i]);
+    }
+}
+
+size_t GLClientState::getRboIndex(GLuint name) const {
+    for (size_t i = 0; i < mRboState.rboData.size(); i++) {
+        if (mRboState.rboData[i].name == name) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+void GLClientState::removeRenderbuffers(GLsizei n, const GLuint* renderbuffers) {
+    size_t bound_rbo_idx = getRboIndex(boundRboProps_const().name);
+
+    std::vector<GLuint> to_remove;
+    for (size_t i = 0; i < n; i++) {
+        if (renderbuffers[i] != 0) { // Never remove the zero rb.
+            to_remove.push_back(getRboIndex(renderbuffers[i]));
+        }
+    }
+
+    for (size_t i = 0; i < to_remove.size(); i++) {
+        mRboState.rboData[to_remove[i]] = mRboState.rboData.back();
+        mRboState.rboData.pop_back();
+    }
+
+    // If we just deleted the currently bound rb,
+    // bind the zero rb
+    if (getRboIndex(boundRboProps_const().name) != bound_rbo_idx) {
+        bindRenderbuffer(GL_RENDERBUFFER, 0);
+    }
+}
+
+bool GLClientState::usedRenderbufferName(GLuint name) const {
+    for (size_t i = 0; i < mRboState.rboData.size(); i++) {
+        if (mRboState.rboData[i].name == name) {
+            return true;
+        }
+    }
+    return false;
+}
+
+void GLClientState::setBoundRenderbufferIndex() {
+    for (size_t i = 0; i < mRboState.rboData.size(); i++) {
+        if (mRboState.rboData[i].name == mRboState.boundRenderbuffer) {
+            mRboState.boundRenderbufferIndex = i;
+            break;
+        }
+    }
+}
+
+RboProps& GLClientState::boundRboProps() {
+    return mRboState.rboData[mRboState.boundRenderbufferIndex];
+}
+
+const RboProps& GLClientState::boundRboProps_const() const {
+    return mRboState.rboData[mRboState.boundRenderbufferIndex];
+}
+
+void GLClientState::bindRenderbuffer(GLenum target, GLuint name) {
+    // If unused, add it.
+    if (!usedRenderbufferName(name)) {
+        addFreshRenderbuffer(name);
+    }
+    mRboState.boundRenderbuffer = name;
+    setBoundRenderbufferIndex();
+    boundRboProps().target = target;
+    boundRboProps().previouslyBound = true;
+}
+
+GLuint GLClientState::boundRenderbuffer() const {
+    return boundRboProps_const().name;
+}
+
+void GLClientState::setBoundRenderbufferFormat(GLenum format) {
+    boundRboProps().format = format;
+}
+
+void GLClientState::setBoundRenderbufferSamples(GLsizei samples) {
+    boundRboProps().multisamples = samples;
+}
+
+// FBO//////////////////////////////////////////////////////////////////////////
+
+// Format querying
+
+GLenum GLClientState::queryRboFormat(GLuint rbo_name) const {
+    return mRboState.rboData[getRboIndex(rbo_name)].format;
+}
+
+GLsizei GLClientState::queryRboSamples(GLuint rbo_name) const {
+    return mRboState.rboData[getRboIndex(rbo_name)].multisamples;
+}
+
+GLint GLClientState::queryTexInternalFormat(GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return -1;
+    return texrec->internalformat;
+}
+
+GLsizei GLClientState::queryTexWidth(GLsizei level, GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) {
+        return 0;
+    }
+    return texrec->dims->widths[level];
+}
+
+GLsizei GLClientState::queryTexHeight(GLsizei level, GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return 0;
+    return texrec->dims->heights[level];
+}
+
+GLsizei GLClientState::queryTexDepth(GLsizei level, GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return 0;
+    return texrec->dims->depths[level];
+}
+
+bool GLClientState::queryTexEGLImageBacked(GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return false;
+    return texrec->boundEGLImage;
+}
+
+GLenum GLClientState::queryTexFormat(GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return -1;
+    return texrec->format;
+}
+
+GLenum GLClientState::queryTexType(GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return -1;
+    return texrec->type;
+}
+
+GLsizei GLClientState::queryTexSamples(GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return 0;
+    return texrec->multisamples;
+}
+
+GLenum GLClientState::queryTexLastBoundTarget(GLuint tex_name) const {
+    TextureRec* texrec = getTextureRec(tex_name);
+    if (!texrec) return GL_NONE;
+    return texrec->target;
+}
+
+void GLClientState::getBoundFramebufferFormat(
+        GLenum target,
+        GLenum attachment, FboFormatInfo* res_info) const {
+    const FboProps& props = boundFboProps_const(target);
+
+    res_info->type = FBO_ATTACHMENT_NONE;
+    res_info->rb_format = GL_NONE;
+    res_info->rb_multisamples = 0;
+    res_info->tex_internalformat = -1;
+    res_info->tex_format = GL_NONE;
+    res_info->tex_type = GL_NONE;
+    res_info->tex_multisamples = 0;
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        if (props.colorAttachmenti_hasRbo[colorAttachmentIndex]) {
+            res_info->type = FBO_ATTACHMENT_RENDERBUFFER;
+            res_info->rb_format =
+                queryRboFormat(
+                        props.colorAttachmenti_rbos[colorAttachmentIndex]);
+            res_info->rb_multisamples =
+                queryRboSamples(
+                        props.colorAttachmenti_rbos[colorAttachmentIndex]);
+        } else if (props.colorAttachmenti_hasTex[colorAttachmentIndex]) {
+            res_info->type = FBO_ATTACHMENT_TEXTURE;
+            res_info->tex_internalformat =
+                queryTexInternalFormat(
+                        props.colorAttachmenti_textures[colorAttachmentIndex]);
+            res_info->tex_format =
+                queryTexFormat(
+                        props.colorAttachmenti_textures[colorAttachmentIndex]);
+            res_info->tex_type =
+                queryTexType(props.colorAttachmenti_textures[colorAttachmentIndex]);
+            res_info->tex_multisamples =
+                queryTexSamples(props.colorAttachmenti_textures[colorAttachmentIndex]);
+        } else {
+            res_info->type = FBO_ATTACHMENT_NONE;
+        }
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        if (props.depthAttachment_hasRbo) {
+            res_info->type = FBO_ATTACHMENT_RENDERBUFFER;
+            res_info->rb_format = queryRboFormat(props.depthAttachment_rbo);
+            res_info->rb_multisamples =
+                queryRboSamples(
+                        props.colorAttachmenti_rbos[colorAttachmentIndex]);
+        } else if (props.depthAttachment_hasTexObj) {
+            res_info->type = FBO_ATTACHMENT_TEXTURE;
+            res_info->tex_internalformat = queryTexInternalFormat(props.depthAttachment_texture);
+            res_info->tex_format = queryTexFormat(props.depthAttachment_texture);
+            res_info->tex_type = queryTexType(props.depthAttachment_texture);
+            res_info->tex_multisamples =
+                queryTexSamples(props.colorAttachmenti_textures[colorAttachmentIndex]);
+        } else {
+            res_info->type = FBO_ATTACHMENT_NONE;
+        }
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        if (props.stencilAttachment_hasRbo) {
+            res_info->type = FBO_ATTACHMENT_RENDERBUFFER;
+            res_info->rb_format = queryRboFormat(props.stencilAttachment_rbo);
+            res_info->rb_multisamples =
+                queryRboSamples(
+                        props.colorAttachmenti_rbos[colorAttachmentIndex]);
+        } else if (props.stencilAttachment_hasTexObj) {
+            res_info->type = FBO_ATTACHMENT_TEXTURE;
+            res_info->tex_internalformat = queryTexInternalFormat(props.stencilAttachment_texture);
+            res_info->tex_format = queryTexFormat(props.stencilAttachment_texture);
+            res_info->tex_type = queryTexType(props.stencilAttachment_texture);
+            res_info->tex_multisamples =
+                queryTexSamples(props.colorAttachmenti_textures[colorAttachmentIndex]);
+        } else {
+            res_info->type = FBO_ATTACHMENT_NONE;
+        }
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        if (props.depthstencilAttachment_hasRbo) {
+            res_info->type = FBO_ATTACHMENT_RENDERBUFFER;
+            res_info->rb_format = queryRboFormat(props.depthstencilAttachment_rbo);
+            res_info->rb_multisamples =
+                queryRboSamples(
+                        props.colorAttachmenti_rbos[colorAttachmentIndex]);
+        } else if (props.depthstencilAttachment_hasTexObj) {
+            res_info->type = FBO_ATTACHMENT_TEXTURE;
+            res_info->tex_internalformat = queryTexInternalFormat(props.depthstencilAttachment_texture);
+            res_info->tex_format = queryTexFormat(props.depthstencilAttachment_texture);
+            res_info->tex_type = queryTexType(props.depthstencilAttachment_texture);
+            res_info->tex_multisamples =
+                queryTexSamples(props.colorAttachmenti_textures[colorAttachmentIndex]);
+        } else {
+            res_info->type = FBO_ATTACHMENT_NONE;
+        }
+        break;
+    }
+}
+
+FboAttachmentType GLClientState::getBoundFramebufferAttachmentType(GLenum target, GLenum attachment) const {
+    FboFormatInfo info;
+    getBoundFramebufferFormat(target, attachment, &info);
+    return info.type;
+}
+
+
+int GLClientState::getMaxColorAttachments() const {
+    return m_max_color_attachments;
+}
+
+int GLClientState::getMaxDrawBuffers() const {
+    return m_max_draw_buffers;
+}
+
+void GLClientState::addFreshFramebuffer(GLuint name) {
+    FboProps props;
+    props.name = name;
+    props.previouslyBound = false;
+
+    props.colorAttachmenti_textures.resize(m_max_color_attachments, 0);
+    props.depthAttachment_texture = 0;
+    props.stencilAttachment_texture = 0;
+    props.depthstencilAttachment_texture = 0;
+
+    props.colorAttachmenti_hasTex.resize(m_max_color_attachments, false);
+    props.depthAttachment_hasTexObj = false;
+    props.stencilAttachment_hasTexObj = false;
+    props.depthstencilAttachment_hasTexObj = false;
+
+    props.colorAttachmenti_rbos.resize(m_max_color_attachments, 0);
+    props.depthAttachment_rbo = 0;
+    props.stencilAttachment_rbo = 0;
+    props.depthstencilAttachment_rbo = 0;
+
+    props.colorAttachmenti_hasRbo.resize(m_max_color_attachments, false);
+    props.depthAttachment_hasRbo = false;
+    props.stencilAttachment_hasRbo = false;
+    props.depthstencilAttachment_hasRbo = false;
+    mFboState.fboData[name] = props;
+}
+
+void GLClientState::addFramebuffers(GLsizei n, GLuint* framebuffers) {
+    for (size_t i = 0; i < n; i++) {
+        addFreshFramebuffer(framebuffers[i]);
+    }
+}
+
+void GLClientState::removeFramebuffers(GLsizei n, const GLuint* framebuffers) {
+    for (size_t i = 0; i < n; i++) {
+        if (framebuffers[i] != 0) { // Never remove the zero fb.
+            if (framebuffers[i] == mFboState.boundDrawFramebuffer) {
+                bindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
+            }
+            if (framebuffers[i] == mFboState.boundReadFramebuffer) {
+                bindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+            }
+            mFboState.fboData.erase(framebuffers[i]);
+        }
+    }
+}
+
+bool GLClientState::usedFramebufferName(GLuint name) const {
+    return mFboState.fboData.find(name) != mFboState.fboData.end();
+}
+
+FboProps& GLClientState::boundFboProps(GLenum target) {
+    switch (target) {
+    case GL_DRAW_FRAMEBUFFER:
+        return mFboState.fboData[mFboState.boundDrawFramebuffer];
+    case GL_READ_FRAMEBUFFER:
+        return mFboState.fboData[mFboState.boundReadFramebuffer];
+    case GL_FRAMEBUFFER:
+        return mFboState.fboData[mFboState.boundDrawFramebuffer];
+    }
+    return mFboState.fboData[mFboState.boundDrawFramebuffer];
+}
+
+const FboProps& GLClientState::boundFboProps_const(GLenum target) const {
+    switch (target) {
+    case GL_DRAW_FRAMEBUFFER:
+        return mFboState.fboData.find(mFboState.boundDrawFramebuffer)->second;
+    case GL_READ_FRAMEBUFFER:
+        return mFboState.fboData.find(mFboState.boundReadFramebuffer)->second;
+    case GL_FRAMEBUFFER:
+        return mFboState.fboData.find(mFboState.boundDrawFramebuffer)->second;
+    }
+    return mFboState.fboData.find(mFboState.boundDrawFramebuffer)->second;
+}
+
+void GLClientState::bindFramebuffer(GLenum target, GLuint name) {
+    // If unused, add it.
+    if (!usedFramebufferName(name)) {
+        addFreshFramebuffer(name);
+    }
+    switch (target) {
+        case GL_DRAW_FRAMEBUFFER:
+            mFboState.boundDrawFramebuffer = name;
+            break;
+        case GL_READ_FRAMEBUFFER:
+            mFboState.boundReadFramebuffer = name;
+            break;
+        default: // case GL_FRAMEBUFFER:
+            mFboState.boundDrawFramebuffer = name;
+            mFboState.boundReadFramebuffer = name;
+            break;
+    }
+    boundFboProps(target).previouslyBound = true;
+}
+
+void GLClientState::setCheckFramebufferStatus(GLenum target, GLenum status) {
+    switch (target) {
+        case GL_DRAW_FRAMEBUFFER:
+            mFboState.drawFboCheckStatus = status;
+            break;
+        case GL_READ_FRAMEBUFFER:
+            mFboState.readFboCheckStatus = status;
+            break;
+        case GL_FRAMEBUFFER:
+            mFboState.drawFboCheckStatus = status;
+            break;
+    }
+}
+
+GLenum GLClientState::getCheckFramebufferStatus(GLenum target) const {
+    switch (target) {
+    case GL_DRAW_FRAMEBUFFER:
+        return mFboState.drawFboCheckStatus;
+    case GL_READ_FRAMEBUFFER:
+        return mFboState.readFboCheckStatus;
+    case GL_FRAMEBUFFER:
+        return mFboState.drawFboCheckStatus;
+    }
+    return mFboState.drawFboCheckStatus;
+}
+
+GLuint GLClientState::boundFramebuffer(GLenum target) const {
+    return boundFboProps_const(target).name;
+}
+
+// Texture objects for FBOs/////////////////////////////////////////////////////
+
+void GLClientState::attachTextureObject(
+        GLenum target,
+        GLenum attachment, GLuint texture) {
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        boundFboProps(target).colorAttachmenti_textures[colorAttachmentIndex] = texture;
+        boundFboProps(target).colorAttachmenti_hasTex[colorAttachmentIndex] = true;
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        boundFboProps(target).depthAttachment_texture = texture;
+        boundFboProps(target).depthAttachment_hasTexObj = true;
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        boundFboProps(target).stencilAttachment_texture = texture;
+        boundFboProps(target).stencilAttachment_hasTexObj = true;
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        boundFboProps(target).depthstencilAttachment_texture = texture;
+        boundFboProps(target).depthstencilAttachment_hasTexObj = true;
+        boundFboProps(target).stencilAttachment_texture = texture;
+        boundFboProps(target).stencilAttachment_hasTexObj = true;
+        boundFboProps(target).depthAttachment_texture = texture;
+        boundFboProps(target).depthAttachment_hasTexObj = true;
+        break;
+    }
+}
+
+GLuint GLClientState::getFboAttachmentTextureId(GLenum target, GLenum attachment) const {
+    GLuint res = 0; // conservative
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        res = boundFboProps_const(target).colorAttachmenti_textures[colorAttachmentIndex];
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        res = boundFboProps_const(target).depthAttachment_texture;
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        res = boundFboProps_const(target).stencilAttachment_texture;
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        res = boundFboProps_const(target).depthstencilAttachment_texture;
+        break;
+    }
+    return res;
+}
+
+// RBOs for FBOs////////////////////////////////////////////////////////////////
+
+void GLClientState::detachRbo(GLuint renderbuffer) {
+    for (int i = 0; i < m_max_color_attachments; i++) {
+        detachRboFromFbo(GL_DRAW_FRAMEBUFFER, glUtilsColorAttachmentName(i), renderbuffer);
+        detachRboFromFbo(GL_READ_FRAMEBUFFER, glUtilsColorAttachmentName(i), renderbuffer);
+    }
+
+    detachRboFromFbo(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, renderbuffer);
+    detachRboFromFbo(GL_READ_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, renderbuffer);
+
+    detachRboFromFbo(GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, renderbuffer);
+    detachRboFromFbo(GL_READ_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, renderbuffer);
+
+    detachRboFromFbo(GL_DRAW_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, renderbuffer);
+    detachRboFromFbo(GL_READ_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, renderbuffer);
+}
+
+void GLClientState::detachRboFromFbo(GLenum target, GLenum attachment, GLuint renderbuffer) {
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        if (boundFboProps(target).colorAttachmenti_hasRbo[colorAttachmentIndex] &&
+            boundFboProps(target).colorAttachmenti_rbos[colorAttachmentIndex] == renderbuffer) {
+            boundFboProps(target).colorAttachmenti_rbos[colorAttachmentIndex] = 0;
+            boundFboProps(target).colorAttachmenti_hasRbo[colorAttachmentIndex] = false;
+        }
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        if (boundFboProps(target).depthAttachment_rbo == renderbuffer &&
+            boundFboProps(target).depthAttachment_hasRbo) {
+            boundFboProps(target).depthAttachment_rbo = 0;
+            boundFboProps(target).depthAttachment_hasRbo = false;
+        }
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        if (boundFboProps(target).stencilAttachment_rbo == renderbuffer &&
+            boundFboProps(target).stencilAttachment_hasRbo) {
+            boundFboProps(target).stencilAttachment_rbo = 0;
+            boundFboProps(target).stencilAttachment_hasRbo = false;
+        }
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        if (boundFboProps(target).depthAttachment_rbo == renderbuffer &&
+            boundFboProps(target).depthAttachment_hasRbo) {
+            boundFboProps(target).depthAttachment_rbo = 0;
+            boundFboProps(target).depthAttachment_hasRbo = false;
+        }
+        if (boundFboProps(target).stencilAttachment_rbo == renderbuffer &&
+            boundFboProps(target).stencilAttachment_hasRbo) {
+            boundFboProps(target).stencilAttachment_rbo = 0;
+            boundFboProps(target).stencilAttachment_hasRbo = false;
+        }
+        if (boundFboProps(target).depthstencilAttachment_rbo == renderbuffer &&
+            boundFboProps(target).depthstencilAttachment_hasRbo) {
+            boundFboProps(target).depthstencilAttachment_rbo = 0;
+            boundFboProps(target).depthstencilAttachment_hasRbo = false;
+        }
+        break;
+    }
+}
+
+void GLClientState::attachRbo(GLenum target, GLenum attachment, GLuint renderbuffer) {
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        boundFboProps(target).colorAttachmenti_rbos[colorAttachmentIndex] = renderbuffer;
+        boundFboProps(target).colorAttachmenti_hasRbo[colorAttachmentIndex] = true;
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        boundFboProps(target).depthAttachment_rbo = renderbuffer;
+        boundFboProps(target).depthAttachment_hasRbo = true;
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        boundFboProps(target).stencilAttachment_rbo = renderbuffer;
+        boundFboProps(target).stencilAttachment_hasRbo = true;
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        boundFboProps(target).depthAttachment_rbo = renderbuffer;
+        boundFboProps(target).depthAttachment_hasRbo = true;
+        boundFboProps(target).stencilAttachment_rbo = renderbuffer;
+        boundFboProps(target).stencilAttachment_hasRbo = true;
+        boundFboProps(target).depthstencilAttachment_rbo = renderbuffer;
+        boundFboProps(target).depthstencilAttachment_hasRbo = true;
+        break;
+    }
+}
+
+GLuint GLClientState::getFboAttachmentRboId(GLenum target, GLenum attachment) const {
+    GLuint res = 0; // conservative
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        res = boundFboProps_const(target).colorAttachmenti_rbos[colorAttachmentIndex];
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        res = boundFboProps_const(target).depthAttachment_rbo;
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        res = boundFboProps_const(target).stencilAttachment_rbo;
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        res = boundFboProps_const(target).depthstencilAttachment_rbo;
+        break;
+    }
+    return res;
+}
+
+bool GLClientState::attachmentHasObject(GLenum target, GLenum attachment) const {
+    bool res = true; // liberal
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        res = boundFboProps_const(target).colorAttachmenti_hasTex[colorAttachmentIndex] ||
+              boundFboProps_const(target).colorAttachmenti_hasRbo[colorAttachmentIndex];
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        res = (boundFboProps_const(target).depthAttachment_hasTexObj) ||
+              (boundFboProps_const(target).depthAttachment_hasRbo);
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        res = (boundFboProps_const(target).stencilAttachment_hasTexObj) ||
+              (boundFboProps_const(target).stencilAttachment_hasRbo);
+        break;
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        res = (boundFboProps_const(target).depthstencilAttachment_hasTexObj) ||
+              (boundFboProps_const(target).depthstencilAttachment_hasRbo);
+        break;
+    }
+    return res;
+}
+
+GLuint GLClientState::objectOfAttachment(GLenum target, GLenum attachment) const {
+    const FboProps& props = boundFboProps_const(target);
+
+    int colorAttachmentIndex =
+        glUtilsColorAttachmentIndex(attachment);
+
+    if (colorAttachmentIndex != -1) {
+        if (props.colorAttachmenti_hasTex[colorAttachmentIndex]) {
+            return props.colorAttachmenti_textures[colorAttachmentIndex];
+        } else if (props.colorAttachmenti_hasRbo[colorAttachmentIndex]) {
+            return props.colorAttachmenti_rbos[colorAttachmentIndex];
+        } else {
+            return 0;
+        }
+    }
+
+    switch (attachment) {
+    case GL_DEPTH_ATTACHMENT:
+        if (props.depthAttachment_hasTexObj) {
+            return props.depthAttachment_texture;
+        } else if (props.depthAttachment_hasRbo) {
+            return props.depthAttachment_rbo;
+        } else {
+            return 0;
+        }
+        break;
+    case GL_STENCIL_ATTACHMENT:
+        if (props.stencilAttachment_hasTexObj) {
+            return props.stencilAttachment_texture;
+        } else if (props.stencilAttachment_hasRbo) {
+            return props.stencilAttachment_rbo;
+        } else {
+            return 0;
+        }
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        if (props.depthstencilAttachment_hasTexObj) {
+            return props.depthstencilAttachment_texture;
+        } else if (props.depthstencilAttachment_hasRbo) {
+            return props.depthstencilAttachment_rbo;
+        } else {
+            return 0;
+        }
+        break;
+    }
+    return 0;
+}
+
+void GLClientState::setTransformFeedbackActiveUnpaused(bool activeUnpaused) {
+    m_transformFeedbackActiveUnpaused = activeUnpaused;
+}
+
+bool GLClientState::getTransformFeedbackActiveUnpaused() const {
+    return m_transformFeedbackActiveUnpaused;
+}
+
+void GLClientState::setTextureData(SharedTextureDataMap* sharedTexData) {
+    m_tex.textureRecs = sharedTexData;
+}
+
+void GLClientState::fromMakeCurrent() {
+    if (mFboState.fboData.find(0) == mFboState.fboData.end()) {
+        addFreshFramebuffer(0);
+    }
+    FboProps& default_fb_props = mFboState.fboData[0];
+    default_fb_props.colorAttachmenti_hasRbo[0] = true;
+    default_fb_props.depthAttachment_hasRbo = true;
+    default_fb_props.stencilAttachment_hasRbo = true;
+    default_fb_props.depthstencilAttachment_hasRbo = true;
+}
+
+void GLClientState::initFromCaps(
+    int max_transform_feedback_separate_attribs,
+    int max_uniform_buffer_bindings,
+    int max_atomic_counter_buffer_bindings,
+    int max_shader_storage_buffer_bindings,
+    int max_vertex_attrib_bindings,
+    int max_color_attachments,
+    int max_draw_buffers) {
+
+    m_max_vertex_attrib_bindings = max_vertex_attrib_bindings;
+
+    if (m_glesMajorVersion >= 3) {
+        m_max_transform_feedback_separate_attribs = max_transform_feedback_separate_attribs;
+        m_max_uniform_buffer_bindings = max_uniform_buffer_bindings;
+        m_max_atomic_counter_buffer_bindings = max_atomic_counter_buffer_bindings;
+        m_max_shader_storage_buffer_bindings = max_shader_storage_buffer_bindings;
+
+        if (m_max_transform_feedback_separate_attribs)
+            m_indexedTransformFeedbackBuffers.resize(m_max_transform_feedback_separate_attribs);
+        if (m_max_uniform_buffer_bindings)
+            m_indexedUniformBuffers.resize(m_max_uniform_buffer_bindings);
+        if (m_max_atomic_counter_buffer_bindings)
+            m_indexedAtomicCounterBuffers.resize(m_max_atomic_counter_buffer_bindings);
+        if (m_max_shader_storage_buffer_bindings)
+            m_indexedShaderStorageBuffers.resize(m_max_shader_storage_buffer_bindings);
+
+        BufferBinding buf0Binding;
+        buf0Binding.buffer = 0;
+        buf0Binding.offset = 0;
+        buf0Binding.size = 0;
+        buf0Binding.stride = 0;
+        buf0Binding.effectiveStride = 0;
+
+        for (size_t i = 0; i < m_indexedTransformFeedbackBuffers.size(); ++i)
+            m_indexedTransformFeedbackBuffers[i] = buf0Binding;
+        for (size_t i = 0; i < m_indexedUniformBuffers.size(); ++i)
+            m_indexedUniformBuffers[i] = buf0Binding;
+        for (size_t i = 0; i < m_indexedAtomicCounterBuffers.size(); ++i)
+            m_indexedAtomicCounterBuffers[i] = buf0Binding;
+        for (size_t i = 0; i < m_indexedShaderStorageBuffers.size(); ++i)
+            m_indexedShaderStorageBuffers[i] = buf0Binding;
+    }
+
+    m_max_color_attachments = max_color_attachments;
+    m_max_draw_buffers = max_draw_buffers;
+
+    addFreshRenderbuffer(0);
+    addFreshFramebuffer(0);
+
+    m_initialized = true;
+}
+
+bool GLClientState::needsInitFromCaps() const {
+    return !m_initialized;
+}
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.h
index 8e95c37..e41cf44 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLClientState.h
@@ -22,6 +22,8 @@
 #define GL_APIENTRYP
 #endif
 
+#include "TextureSharedData.h"
+
 #include <GLES/gl.h>
 #include <GLES/glext.h>
 #include <GLES2/gl2.h>
@@ -32,6 +34,67 @@
 #include "ErrorLog.h"
 #include "codec_defs.h"
 
+#include <vector>
+#include <map>
+#include <set>
+
+// Tracking framebuffer objects:
+// which framebuffer is bound,
+// and which texture names
+// are currently bound to which attachment points.
+struct FboProps {
+    GLuint name;
+    bool previouslyBound;
+    std::vector<GLuint> colorAttachmenti_textures;
+    GLuint depthAttachment_texture;
+    GLuint stencilAttachment_texture;
+    GLuint depthstencilAttachment_texture;
+
+    std::vector<bool> colorAttachmenti_hasTex;
+    bool depthAttachment_hasTexObj;
+    bool stencilAttachment_hasTexObj;
+    bool depthstencilAttachment_hasTexObj;
+
+    std::vector<GLuint> colorAttachmenti_rbos;
+    GLuint depthAttachment_rbo;
+    GLuint stencilAttachment_rbo;
+    GLuint depthstencilAttachment_rbo;
+
+    std::vector<bool> colorAttachmenti_hasRbo;
+    bool depthAttachment_hasRbo;
+    bool stencilAttachment_hasRbo;
+    bool depthstencilAttachment_hasRbo;
+};
+
+// Same for Rbo's
+struct RboProps {
+    GLenum target;
+    GLuint name;
+    GLenum format;
+    GLsizei multisamples;
+    bool previouslyBound;
+};
+
+// Enum for describing whether a framebuffer attachment
+// is a texture or renderbuffer.
+enum FboAttachmentType {
+    FBO_ATTACHMENT_RENDERBUFFER = 0,
+    FBO_ATTACHMENT_TEXTURE = 1,
+    FBO_ATTACHMENT_NONE = 2
+};
+
+// Tracking FBO format
+struct FboFormatInfo {
+    FboAttachmentType type;
+    GLenum rb_format;
+    GLsizei rb_multisamples;
+
+    GLint tex_internalformat;
+    GLenum tex_format;
+    GLenum tex_type;
+    GLsizei tex_multisamples;
+};
+
 class GLClientState {
 public:
     typedef enum {
@@ -58,35 +121,102 @@ public:
         GLenum type;
         GLsizei stride;
         void *data;
+        GLuint reloffset;
         GLuint bufferObject;
         GLenum glConst;
         unsigned int elementSize;
         bool enableDirty;  // true if any enable state has changed since last draw
         bool normalized;
+        GLuint divisor;
+        bool isInt;
+        int bindingindex;
     } VertexAttribState;
 
+    struct BufferBinding {
+        GLintptr offset;
+        GLintptr stride;
+        GLintptr effectiveStride;
+        GLsizeiptr size;
+        GLuint buffer;
+        GLuint divisor;
+    };
+
+    typedef std::vector<VertexAttribState> VertexAttribStateVector;
+    typedef std::vector<BufferBinding> VertexAttribBindingVector;
+
+    struct VAOState {
+        VAOState(GLuint ibo, int nLoc, int nBindings) :
+            element_array_buffer_binding(ibo),
+            attribState(nLoc),
+            bindingState(nBindings) { }
+        VertexAttribStateVector attribState;
+        VertexAttribBindingVector bindingState;
+        GLuint element_array_buffer_binding;
+    };
+
+    typedef std::map<GLuint, VAOState> VAOStateMap;
+    struct VAOStateRef {
+        VAOStateRef() { }
+        VAOStateRef(
+                VAOStateMap::iterator iter) : it(iter) { }
+        VertexAttribState& operator[](size_t k) { return it->second.attribState[k]; }
+        BufferBinding& bufferBinding(size_t k) { return it->second.bindingState[k]; }
+        VertexAttribBindingVector& bufferBindings() { return it->second.bindingState; }
+        const VertexAttribBindingVector& bufferBindings_const() const { return it->second.bindingState; }
+        GLuint vaoId() const { return it->first; }
+        GLuint& iboId() { return it->second.element_array_buffer_binding; }
+        VAOStateMap::iterator it;
+    };
+
     typedef struct {
         int unpack_alignment;
+
+        int unpack_row_length;
+        int unpack_image_height;
+        int unpack_skip_pixels;
+        int unpack_skip_rows;
+        int unpack_skip_images;
+
         int pack_alignment;
+
+        int pack_row_length;
+        int pack_skip_pixels;
+        int pack_skip_rows;
     } PixelStoreState;
 
     enum {
-        MAX_TEXTURE_UNITS = 32,
+        MAX_TEXTURE_UNITS = 256,
     };
 
 public:
-    GLClientState(int nLocations = CODEC_MAX_VERTEX_ATTRIBUTES);
+    GLClientState();
+    GLClientState(int majorVersion, int minorVersion);
     ~GLClientState();
     int nLocations() { return m_nLocations; }
     const PixelStoreState *pixelStoreState() { return &m_pixelStore; }
     int setPixelStore(GLenum param, GLint value);
-    GLuint currentArrayVbo() { return m_currentArrayVbo; }
-    GLuint currentIndexVbo() { return m_currentIndexVbo; }
+    GLuint currentVertexArrayObject() const { return m_currVaoState.vaoId(); }
+    const VertexAttribBindingVector& currentVertexBufferBindings() const {
+        return m_currVaoState.bufferBindings_const();
+    }
+
+    GLuint currentArrayVbo() { return m_arrayBuffer; }
+    GLuint currentIndexVbo() { return m_currVaoState.iboId(); }
     void enable(int location, int state);
-    void setState(int  location, int size, GLenum type, GLboolean normalized, GLsizei stride, const void *data);
-    void setBufferObject(int location, GLuint id);
-    const VertexAttribState  *getState(int location);
-    const VertexAttribState  *getStateAndEnableDirty(int location, bool *enableChanged);
+    // Vertex array objects and vertex attributes
+    void addVertexArrayObjects(GLsizei n, GLuint* arrays);
+    void removeVertexArrayObjects(GLsizei n, const GLuint* arrays);
+    void addVertexArrayObject(GLuint name);
+    void removeVertexArrayObject(GLuint name);
+    void setVertexArrayObject(GLuint vao);
+    bool isVertexArrayObject(GLuint vao) const;
+    void setVertexAttribState(int  location, int size, GLenum type, GLboolean normalized, GLsizei stride, const void *data, bool isInt = false);
+    void setVertexBindingDivisor(int bindingindex, GLuint divisor);
+    const BufferBinding& getCurrAttributeBindingInfo(int attribindex);
+    void setVertexAttribBinding(int attribindex, int bindingindex);
+    void setVertexAttribFormat(int location, int size, GLenum type, GLboolean normalized, GLuint reloffset, bool isInt = false);
+    const VertexAttribState& getState(int location);
+    const VertexAttribState& getStateAndEnableDirty(int location, bool *enableChanged);
     int getLocation(GLenum loc);
     void setActiveTexture(int texUnit) {m_activeTexture = texUnit; };
     int getActiveTexture() const { return m_activeTexture; }
@@ -95,47 +225,53 @@ public:
         m_maxVertexAttribsDirty = false;
     }
 
-    void unBindBuffer(GLuint id)
-    {
-        if (m_currentArrayVbo == id) m_currentArrayVbo = 0;
-        else if (m_currentIndexVbo == id) m_currentIndexVbo = 0;
-    }
+    void addBuffer(GLuint id);
+    void removeBuffer(GLuint id);
+    bool bufferIdExists(GLuint id) const;
+    void unBindBuffer(GLuint id);
 
-    int bindBuffer(GLenum target, GLuint id)
-    {
-        int err = 0;
-        switch(target) {
-        case GL_ARRAY_BUFFER:
-            m_currentArrayVbo = id;
-            break;
-        case GL_ELEMENT_ARRAY_BUFFER:
-            m_currentIndexVbo = id;
-            break;
-        default:
-            err = -1;
-        }
-        return err;
-    }
+    int bindBuffer(GLenum target, GLuint id);
+    void bindIndexedBuffer(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, GLintptr stride, GLintptr effectiveStride);
+    int getMaxIndexedBufferBindings(GLenum target) const;
 
-    int getBuffer(GLenum target)
-    {
-      int ret=0;
-      switch (target) {
-      case GL_ARRAY_BUFFER:
-          ret = m_currentArrayVbo;
-          break;
-      case GL_ELEMENT_ARRAY_BUFFER:
-          ret = m_currentIndexVbo;
-          break;
-      default:
-          ret = -1;
-      }
-      return ret;
-    }
-    size_t pixelDataSize(GLsizei width, GLsizei height, GLenum format, GLenum type, int pack) const;
+    int getBuffer(GLenum target);
+
+    size_t pixelDataSize(GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, int pack) const;
+    size_t pboNeededDataSize(GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, int pack) const;
+    size_t clearBufferNumElts(GLenum buffer) const;
 
     void setCurrentProgram(GLint program) { m_currentProgram = program; }
+    void setCurrentShaderProgram(GLint program) { m_currentShaderProgram = program; }
     GLint currentProgram() const { return m_currentProgram; }
+    GLint currentShaderProgram() const { return m_currentShaderProgram; }
+
+    struct UniformBlockInfoKey {
+        GLuint program;
+        GLuint uniformBlockIndex;
+    };
+    struct UniformBlockInfoKeyCompare {
+        bool operator() (const UniformBlockInfoKey& a,
+                         const UniformBlockInfoKey& b) const {
+            if (a.program != b.program) return a.program < b.program;
+            if (a.uniformBlockIndex != b.uniformBlockIndex) return a.uniformBlockIndex < b.uniformBlockIndex;
+            return false;
+        }
+    };
+    struct UniformBlockUniformInfo {
+        size_t numActiveUniforms;
+    };
+
+    typedef std::map<UniformBlockInfoKey, UniformBlockUniformInfo, UniformBlockInfoKeyCompare> UniformBlockInfoMap;
+    UniformBlockInfoMap m_uniformBlockInfoMap;
+
+    void setNumActiveUniformsInUniformBlock(GLuint program, GLuint uniformBlockIndex, GLint numActiveUniforms);
+    size_t numActiveUniformsInUniformBlock(GLuint program, GLuint uniformBlockIndex) const;
+
+    typedef std::map<GLuint, GLuint> ProgramPipelineMap;
+    typedef ProgramPipelineMap::iterator ProgramPipelineIterator;
+    void associateProgramWithPipeline(GLuint program, GLuint pipeline);
+    ProgramPipelineIterator programPipelineBegin();
+    ProgramPipelineIterator programPipelineEnd();
 
     /* OES_EGL_image_external
      *
@@ -177,51 +313,246 @@ public:
     // For accurate error detection, bindTexture should be called for *all*
     // targets, not just 2D and EXTERNAL_OES.
     GLenum bindTexture(GLenum target, GLuint texture, GLboolean* firstUse);
+    void setBoundEGLImage(GLenum target, GLeglImageOES image);
 
     // Return the texture currently bound to GL_TEXTURE_(2D|EXTERNAL_OES).
     GLuint getBoundTexture(GLenum target) const;
+    // Other publicly-visible texture queries
+    GLenum queryTexLastBoundTarget(GLuint name) const;
+    GLenum queryTexFormat(GLuint name) const;
+    GLint queryTexInternalFormat(GLuint name) const;
+    GLsizei queryTexWidth(GLsizei level, GLuint name) const;
+    GLsizei queryTexHeight(GLsizei level, GLuint name) const;
+    GLsizei queryTexDepth(GLsizei level, GLuint name) const;
+    bool queryTexEGLImageBacked(GLuint name) const;
+
+    // For AMD GPUs, it is easy for the emulator to segfault
+    // (esp. in dEQP) when a cube map is defined using glCopyTexImage2D
+    // and uses GL_LUMINANCE as internal format.
+    // In particular, the segfault happens when negative components of
+    // cube maps are defined before positive ones,
+    // This procedure checks internal state to see if we have defined
+    // the positive component of a cube map already. If not, it returns
+    // which positive component needs to be defined first.
+    // If there is no need for the extra definition, 0 is returned.
+    GLenum copyTexImageLuminanceCubeMapAMDWorkaround(GLenum target, GLint level,
+                                                     GLenum internalformat);
+
+    // Tracks the format of the currently bound texture.
+    // This is to pass dEQP tests for fbo completeness.
+    void setBoundTextureInternalFormat(GLenum target, GLint format);
+    void setBoundTextureFormat(GLenum target, GLenum format);
+    void setBoundTextureType(GLenum target, GLenum type);
+    void setBoundTextureDims(GLenum target, GLsizei level, GLsizei width, GLsizei height, GLsizei depth);
+    void setBoundTextureSamples(GLenum target, GLsizei samples);
+
+    // glTexStorage2D disallows any change in texture format after it is set for a particular texture.
+    void setBoundTextureImmutableFormat(GLenum target);
+    bool isBoundTextureImmutableFormat(GLenum target) const;
 
     // glDeleteTextures(...)
     // Remove references to the to-be-deleted textures.
     void deleteTextures(GLsizei n, const GLuint* textures);
 
+    // Render buffer objects
+    void addRenderbuffers(GLsizei n, GLuint* renderbuffers);
+    void removeRenderbuffers(GLsizei n, const GLuint* renderbuffers);
+    bool usedRenderbufferName(GLuint name) const;
+    void bindRenderbuffer(GLenum target, GLuint name);
+    GLuint boundRenderbuffer() const;
+    void setBoundRenderbufferFormat(GLenum format);
+    void setBoundRenderbufferSamples(GLsizei samples);
+
+    // Frame buffer objects
+    void addFramebuffers(GLsizei n, GLuint* framebuffers);
+    void removeFramebuffers(GLsizei n, const GLuint* framebuffers);
+    bool usedFramebufferName(GLuint name) const;
+    void bindFramebuffer(GLenum target, GLuint name);
+    void setCheckFramebufferStatus(GLenum target, GLenum status);
+    GLenum getCheckFramebufferStatus(GLenum target) const;
+    GLuint boundFramebuffer(GLenum target) const;
+
+    // Texture object -> FBO
+    void attachTextureObject(GLenum target, GLenum attachment, GLuint texture);
+    GLuint getFboAttachmentTextureId(GLenum target, GLenum attachment) const;
+
+    // RBO -> FBO
+    void detachRbo(GLuint renderbuffer);
+    void detachRboFromFbo(GLenum target, GLenum attachment, GLuint renderbuffer);
+    void attachRbo(GLenum target, GLenum attachment, GLuint renderbuffer);
+    GLuint getFboAttachmentRboId(GLenum target, GLenum attachment) const;
+
+    // FBO attachments in general
+    bool attachmentHasObject(GLenum target, GLenum attachment) const;
+    GLuint objectOfAttachment(GLenum target, GLenum attachment) const;
+
+    // Transform feedback state
+    void setTransformFeedbackActiveUnpaused(bool activeUnpaused);
+    bool getTransformFeedbackActiveUnpaused() const;
+
+    void setTextureData(SharedTextureDataMap* sharedTexData);
+    // set eglsurface property on default framebuffer
+    // if coming from eglMakeCurrent
+    void fromMakeCurrent();
+    // set indexed buffer state.
+    // We need to query the underlying OpenGL to get
+    // accurate values for indexed buffers
+    // and # render targets.
+    void initFromCaps(
+        int max_transform_feedback_separate_attribs,
+        int max_uniform_buffer_bindings,
+        int max_atomic_counter_buffer_bindings,
+        int max_shader_storage_buffer_bindings,
+        int max_vertex_attrib_bindings,
+        int max_color_attachments,
+        int max_draw_buffers);
+    bool needsInitFromCaps() const;
+
+    // Queries the format backing the current framebuffer.
+    // Type differs depending on whether the attachment
+    // is a texture or renderbuffer.
+    void getBoundFramebufferFormat(
+            GLenum target,
+            GLenum attachment,
+            FboFormatInfo* res_info) const;
+    FboAttachmentType getBoundFramebufferAttachmentType(
+            GLenum target,
+            GLenum attachment) const;
+    int getMaxColorAttachments() const;
+    int getMaxDrawBuffers() const;
 private:
+    void init();
+    bool m_initialized;
     PixelStoreState m_pixelStore;
-    VertexAttribState *m_states;
+
+    std::set<GLuint> mBufferIds;
+
+    // GL_ARRAY_BUFFER_BINDING is separate from VAO state
+    GLuint m_arrayBuffer;
+    VAOStateMap m_vaoMap;
+    VAOStateRef m_currVaoState;
+
+    // Other buffer id's, other targets
+    GLuint m_copyReadBuffer;
+    GLuint m_copyWriteBuffer;
+
+    GLuint m_pixelPackBuffer;
+    GLuint m_pixelUnpackBuffer;
+
+    GLuint m_transformFeedbackBuffer;
+    GLuint m_uniformBuffer;
+
+    GLuint m_atomicCounterBuffer;
+    GLuint m_dispatchIndirectBuffer;
+    GLuint m_drawIndirectBuffer;
+    GLuint m_shaderStorageBuffer;
+
+    bool m_transformFeedbackActiveUnpaused;
+
+    int m_max_transform_feedback_separate_attribs;
+    int m_max_uniform_buffer_bindings;
+    int m_max_atomic_counter_buffer_bindings;
+    int m_max_shader_storage_buffer_bindings;
+    int m_max_vertex_attrib_bindings;
+    std::vector<BufferBinding> m_indexedTransformFeedbackBuffers;
+    std::vector<BufferBinding> m_indexedUniformBuffers;
+    std::vector<BufferBinding> m_indexedAtomicCounterBuffers;
+    std::vector<BufferBinding> m_indexedShaderStorageBuffers;
+
+    int m_glesMajorVersion;
+    int m_glesMinorVersion;
     int m_maxVertexAttribs;
     bool m_maxVertexAttribsDirty;
     int m_nLocations;
-    GLuint m_currentArrayVbo;
-    GLuint m_currentIndexVbo;
     int m_activeTexture;
     GLint m_currentProgram;
-
-    bool validLocation(int location) { return (location >= 0 && location < m_nLocations); }
+    GLint m_currentShaderProgram;
+    ProgramPipelineMap m_programPipelines;
 
     enum TextureTarget {
         TEXTURE_2D = 0,
         TEXTURE_EXTERNAL = 1,
+        TEXTURE_CUBE_MAP = 2,
+        TEXTURE_2D_ARRAY = 3,
+        TEXTURE_3D = 4,
+        TEXTURE_2D_MULTISAMPLE = 5,
         TEXTURE_TARGET_COUNT
     };
     struct TextureUnit {
         unsigned int enables;
         GLuint texture[TEXTURE_TARGET_COUNT];
     };
-    struct TextureRec {
-        GLuint id;
-        GLenum target;
-    };
     struct TextureState {
         TextureUnit unit[MAX_TEXTURE_UNITS];
         TextureUnit* activeUnit;
-        TextureRec* textures;
-        GLuint numTextures;
-        GLuint allocTextures;
+        // Initialized from shared group.
+        SharedTextureDataMap* textureRecs;
     };
     TextureState m_tex;
 
+    // State tracking of cube map definitions.
+    // Currently used only for driver workarounds
+    // when using GL_LUMINANCE and defining cube maps with
+    // glCopyTexImage2D.
+    struct CubeMapDef {
+        GLuint id;
+        GLenum target;
+        GLint level;
+        GLenum internalformat;
+    };
+    struct CubeMapDefCompare {
+        bool operator() (const CubeMapDef& a,
+                         const CubeMapDef& b) const {
+            if (a.id != b.id) return a.id < b.id;
+            if (a.target != b.target) return a.target < b.target;
+            if (a.level != b.level) return a.level < b.level;
+            if (a.internalformat != b.internalformat)
+                return a.internalformat < b.internalformat;
+            return false;
+        }
+    };
+    std::set<CubeMapDef, CubeMapDefCompare> m_cubeMapDefs;
+    void writeCopyTexImageState(GLenum target, GLint level,
+                                GLenum internalformat);
+    GLenum copyTexImageNeededTarget(GLenum target, GLint level,
+                                    GLenum internalformat);
+
+    int m_max_color_attachments;
+    int m_max_draw_buffers;
+    struct RboState {
+        GLuint boundRenderbuffer;
+        size_t boundRenderbufferIndex;
+        std::vector<RboProps> rboData;
+    };
+    RboState mRboState;
+    void addFreshRenderbuffer(GLuint name);
+    void setBoundRenderbufferIndex();
+    size_t getRboIndex(GLuint name) const;
+    RboProps& boundRboProps();
+    const RboProps& boundRboProps_const() const;
+
+    struct FboState {
+        GLuint boundDrawFramebuffer;
+        GLuint boundReadFramebuffer;
+        size_t boundFramebufferIndex;
+        std::map<GLuint, FboProps> fboData;
+        GLenum drawFboCheckStatus;
+        GLenum readFboCheckStatus;
+    };
+    FboState mFboState;
+    void addFreshFramebuffer(GLuint name);
+    FboProps& boundFboProps(GLenum target);
+    const FboProps& boundFboProps_const(GLenum target) const;
+
+    // Querying framebuffer format
+    GLenum queryRboFormat(GLuint name) const;
+    GLsizei queryRboSamples(GLuint name) const;
+    GLenum queryTexType(GLuint name) const;
+    GLsizei queryTexSamples(GLuint name) const;
+
     static int compareTexId(const void* pid, const void* prec);
     TextureRec* addTextureRec(GLuint id, GLenum target);
+    TextureRec* getTextureRec(GLuint id) const;
 
 public:
     void getClientStatePointer(GLenum pname, GLvoid** params);
@@ -230,31 +561,40 @@ public:
     int getVertexAttribParameter(GLuint index, GLenum param, T *ptr)
     {
         bool handled = true;
-        const VertexAttribState *vertexAttrib = getState(index);
-        if (vertexAttrib == NULL) {
-            ERR("getVeterxAttriParameter for non existant index %d\n", index);
-            // set gl error;
-            return handled;
-        }
+        const VertexAttribState& vertexAttrib = getState(index);
+        const BufferBinding& vertexAttribBufferBinding =
+            m_currVaoState.bufferBindings_const()[vertexAttrib.bindingindex];
 
         switch(param) {
+#define GL_VERTEX_ATTRIB_BINDING 0x82D4
+        case GL_VERTEX_ATTRIB_BINDING:
+            *ptr = (T)vertexAttrib.bindingindex;
+            break;
+#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D5
+        case GL_VERTEX_ATTRIB_RELATIVE_OFFSET:
+            *ptr = (T)vertexAttrib.reloffset;
+            break;
         case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
-            *ptr = (T)(vertexAttrib->bufferObject);
+            *ptr = (T)(vertexAttribBufferBinding.buffer);
             break;
         case GL_VERTEX_ATTRIB_ARRAY_ENABLED:
-            *ptr = (T)(vertexAttrib->enabled);
+            *ptr = (T)(vertexAttrib.enabled);
+            break;
+#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
+        case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
+            *ptr = (T)(vertexAttrib.isInt);
             break;
         case GL_VERTEX_ATTRIB_ARRAY_SIZE:
-            *ptr = (T)(vertexAttrib->size);
+            *ptr = (T)(vertexAttrib.size);
             break;
         case GL_VERTEX_ATTRIB_ARRAY_STRIDE:
-            *ptr = (T)(vertexAttrib->stride);
+            *ptr = (T)(vertexAttribBufferBinding.stride);
             break;
         case GL_VERTEX_ATTRIB_ARRAY_TYPE:
-            *ptr = (T)(vertexAttrib->type);
+            *ptr = (T)(vertexAttrib.type);
             break;
         case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
-            *ptr = (T)(vertexAttrib->normalized);
+            *ptr = (T)(vertexAttrib.normalized);
             break;
         case GL_CURRENT_VERTEX_ATTRIB:
             handled = false;
@@ -267,181 +607,181 @@ public:
     }
 
     template <class T>
-    bool getClientStateParameter(GLenum param, T* ptr)
+    bool getClientStateParameter(GLenum param, T* out)
     {
         bool isClientStateParam = false;
         switch (param) {
         case GL_CLIENT_ACTIVE_TEXTURE: {
             GLint tex = getActiveTexture() + GL_TEXTURE0;
-            *ptr = tex;
+            *out = tex;
             isClientStateParam = true;
             break;
             }
         case GL_VERTEX_ARRAY_SIZE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::VERTEX_LOCATION);
-            *ptr = state->size;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::VERTEX_LOCATION);
+            *out = state.size;
             isClientStateParam = true;
             break;
             }
         case GL_VERTEX_ARRAY_TYPE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::VERTEX_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::VERTEX_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_VERTEX_ARRAY_STRIDE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::VERTEX_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::VERTEX_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_COLOR_ARRAY_SIZE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::COLOR_LOCATION);
-            *ptr = state->size;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::COLOR_LOCATION);
+            *out = state.size;
             isClientStateParam = true;
             break;
             }
         case GL_COLOR_ARRAY_TYPE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::COLOR_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::COLOR_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_COLOR_ARRAY_STRIDE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::COLOR_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::COLOR_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_NORMAL_ARRAY_TYPE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::NORMAL_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::NORMAL_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_NORMAL_ARRAY_STRIDE: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::NORMAL_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::NORMAL_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_TEXTURE_COORD_ARRAY_SIZE: {
-            const GLClientState::VertexAttribState *state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
-            *ptr = state->size;
+            const GLClientState::VertexAttribState& state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
+            *out = state.size;
             isClientStateParam = true;
             break;
             }
         case GL_TEXTURE_COORD_ARRAY_TYPE: {
-            const GLClientState::VertexAttribState *state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_TEXTURE_COORD_ARRAY_STRIDE: {
-            const GLClientState::VertexAttribState *state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(getActiveTexture() + GLClientState::TEXCOORD0_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_POINT_SIZE_ARRAY_TYPE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::POINTSIZE_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::POINTSIZE_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_POINT_SIZE_ARRAY_STRIDE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::POINTSIZE_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::POINTSIZE_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_MATRIX_INDEX_ARRAY_SIZE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::MATRIXINDEX_LOCATION);
-            *ptr = state->size;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::MATRIXINDEX_LOCATION);
+            *out = state.size;
             isClientStateParam = true;
             break;
             }
         case GL_MATRIX_INDEX_ARRAY_TYPE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::MATRIXINDEX_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::MATRIXINDEX_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_MATRIX_INDEX_ARRAY_STRIDE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::MATRIXINDEX_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::MATRIXINDEX_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_WEIGHT_ARRAY_SIZE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::WEIGHT_LOCATION);
-            *ptr = state->size;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::WEIGHT_LOCATION);
+            *out = state.size;
             isClientStateParam = true;
             break;
             }
         case GL_WEIGHT_ARRAY_TYPE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::WEIGHT_LOCATION);
-            *ptr = state->type;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::WEIGHT_LOCATION);
+            *out = state.type;
             isClientStateParam = true;
             break;
             }
         case GL_WEIGHT_ARRAY_STRIDE_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::WEIGHT_LOCATION);
-            *ptr = state->stride;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::WEIGHT_LOCATION);
+            *out = state.stride;
             isClientStateParam = true;
             break;
             }
         case GL_VERTEX_ARRAY_BUFFER_BINDING: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::VERTEX_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::VERTEX_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_NORMAL_ARRAY_BUFFER_BINDING: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::NORMAL_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::NORMAL_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_COLOR_ARRAY_BUFFER_BINDING: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::COLOR_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::COLOR_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING: {
-            const GLClientState::VertexAttribState *state = getState(getActiveTexture()+GLClientState::TEXCOORD0_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(getActiveTexture()+GLClientState::TEXCOORD0_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::POINTSIZE_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::POINTSIZE_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::MATRIXINDEX_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::MATRIXINDEX_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_WEIGHT_ARRAY_BUFFER_BINDING_OES: {
-            const GLClientState::VertexAttribState *state = getState(GLClientState::WEIGHT_LOCATION);
-            *ptr = state->bufferObject;
+            const GLClientState::VertexAttribState& state = getState(GLClientState::WEIGHT_LOCATION);
+            *out = state.bufferObject;
             isClientStateParam = true;
             break;
             }
         case GL_ARRAY_BUFFER_BINDING: {
             int buffer = getBuffer(GL_ARRAY_BUFFER);
-            *ptr = buffer;
+            *out = buffer;
             isClientStateParam = true;
             break;
             }
         case GL_ELEMENT_ARRAY_BUFFER_BINDING: {
             int buffer = getBuffer(GL_ELEMENT_ARRAY_BUFFER);
-            *ptr = buffer;
+            *out = buffer;
             isClientStateParam = true;
             break;
             }
@@ -449,11 +789,11 @@ public:
             if (m_maxVertexAttribsDirty) {
                 isClientStateParam = false;
             } else {
-                *ptr = m_maxVertexAttribs;
+                *out = m_maxVertexAttribs;
                 isClientStateParam = true;
             }
             break;
-            }
+        }
         }
         return isClientStateParam;
     }
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLESTextureUtils.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLESTextureUtils.cpp
new file mode 100644
index 0000000..1aef8cb
--- /dev/null
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLESTextureUtils.cpp
@@ -0,0 +1,287 @@
+#include "GLESTextureUtils.h"
+
+#include "glUtils.h"
+
+#include <cutils/log.h>
+
+namespace GLESTextureUtils {
+
+// Based on computations in
+// https://swiftshader.googlesource.com/SwiftShader/+/master/src/OpenGL/common/Image.cpp
+// such as Image::loadImageData,
+// ComputePitch/ComputePackingOffset
+
+#define HIGHEST_MULTIPLE_OF(align, x) \
+    (( ( x ) + ( align ) - 1) & ~( ( align ) - 1)) \
+
+static int computePixelSize(GLenum format, GLenum type) {
+
+#define FORMAT_ERROR(format, type) \
+    ALOGE("%s:%d unknown format/type 0x%x 0x%x", __FUNCTION__, __LINE__, format, type) \
+
+    switch(type) {
+    case GL_BYTE:
+        switch(format) {
+        case GL_R8:
+        case GL_R8I:
+        case GL_R8_SNORM:
+        case GL_RED:             return sizeof(char);
+        case GL_RED_INTEGER:     return sizeof(char);
+        case GL_RG8:
+        case GL_RG8I:
+        case GL_RG8_SNORM:
+        case GL_RG:              return sizeof(char) * 2;
+        case GL_RG_INTEGER:      return sizeof(char) * 2;
+        case GL_RGB8:
+        case GL_RGB8I:
+        case GL_RGB8_SNORM:
+        case GL_RGB:             return sizeof(char) * 3;
+        case GL_RGB_INTEGER:     return sizeof(char) * 3;
+        case GL_RGBA8:
+        case GL_RGBA8I:
+        case GL_RGBA8_SNORM:
+        case GL_RGBA:            return sizeof(char) * 4;
+        case GL_RGBA_INTEGER:    return sizeof(char) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_UNSIGNED_BYTE:
+        switch(format) {
+        case GL_R8:
+        case GL_R8UI:
+        case GL_RED:             return sizeof(unsigned char);
+        case GL_RED_INTEGER:     return sizeof(unsigned char);
+        case GL_ALPHA8_EXT:
+        case GL_ALPHA:           return sizeof(unsigned char);
+        case GL_LUMINANCE8_EXT:
+        case GL_LUMINANCE:       return sizeof(unsigned char);
+        case GL_LUMINANCE8_ALPHA8_EXT:
+        case GL_LUMINANCE_ALPHA: return sizeof(unsigned char) * 2;
+        case GL_RG8:
+        case GL_RG8UI:
+        case GL_RG:              return sizeof(unsigned char) * 2;
+        case GL_RG_INTEGER:      return sizeof(unsigned char) * 2;
+        case GL_RGB8:
+        case GL_RGB8UI:
+        case GL_SRGB8:
+        case GL_RGB:             return sizeof(unsigned char) * 3;
+        case GL_RGB_INTEGER:     return sizeof(unsigned char) * 3;
+        case GL_RGBA8:
+        case GL_RGBA8UI:
+        case GL_SRGB8_ALPHA8:
+        case GL_RGBA:            return sizeof(unsigned char) * 4;
+        case GL_RGBA_INTEGER:    return sizeof(unsigned char) * 4;
+        case GL_BGRA_EXT:
+        case GL_BGRA8_EXT:       return sizeof(unsigned char)* 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_SHORT:
+        switch(format) {
+        case GL_R16I:
+        case GL_RED_INTEGER:     return sizeof(short);
+        case GL_RG16I:
+        case GL_RG_INTEGER:      return sizeof(short) * 2;
+        case GL_RGB16I:
+        case GL_RGB_INTEGER:     return sizeof(short) * 3;
+        case GL_RGBA16I:
+        case GL_RGBA_INTEGER:    return sizeof(short) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_UNSIGNED_SHORT:
+        switch(format) {
+        case GL_DEPTH_COMPONENT16:
+        case GL_DEPTH_COMPONENT: return sizeof(unsigned short);
+        case GL_R16UI:
+        case GL_RED_INTEGER:     return sizeof(unsigned short);
+        case GL_RG16UI:
+        case GL_RG_INTEGER:      return sizeof(unsigned short) * 2;
+        case GL_RGB16UI:
+        case GL_RGB_INTEGER:     return sizeof(unsigned short) * 3;
+        case GL_RGBA16UI:
+        case GL_RGBA_INTEGER:    return sizeof(unsigned short) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_INT:
+        switch(format) {
+        case GL_R32I:
+        case GL_RED_INTEGER:     return sizeof(int);
+        case GL_RG32I:
+        case GL_RG_INTEGER:      return sizeof(int) * 2;
+        case GL_RGB32I:
+        case GL_RGB_INTEGER:     return sizeof(int) * 3;
+        case GL_RGBA32I:
+        case GL_RGBA_INTEGER:    return sizeof(int) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_UNSIGNED_INT:
+        switch(format) {
+        case GL_DEPTH_COMPONENT16:
+        case GL_DEPTH_COMPONENT24:
+        case GL_DEPTH_COMPONENT32_OES:
+        case GL_DEPTH_COMPONENT: return sizeof(unsigned int);
+        case GL_R32UI:
+        case GL_RED_INTEGER:     return sizeof(unsigned int);
+        case GL_RG32UI:
+        case GL_RG_INTEGER:      return sizeof(unsigned int) * 2;
+        case GL_RGB32UI:
+        case GL_RGB_INTEGER:     return sizeof(unsigned int) * 3;
+        case GL_RGBA32UI:
+        case GL_RGBA_INTEGER:    return sizeof(unsigned int) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_UNSIGNED_SHORT_4_4_4_4:
+    case GL_UNSIGNED_SHORT_5_5_5_1:
+    case GL_UNSIGNED_SHORT_5_6_5:
+    case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT:
+    case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT:
+        return sizeof(unsigned short);
+    case GL_UNSIGNED_INT_10F_11F_11F_REV:
+    case GL_UNSIGNED_INT_5_9_9_9_REV:
+    case GL_UNSIGNED_INT_2_10_10_10_REV:
+    case GL_UNSIGNED_INT_24_8_OES:
+        return sizeof(unsigned int);
+    case GL_FLOAT_32_UNSIGNED_INT_24_8_REV:
+        return sizeof(float) + sizeof(unsigned int);
+    case GL_FLOAT:
+        switch(format) {
+        case GL_DEPTH_COMPONENT32F:
+        case GL_DEPTH_COMPONENT: return sizeof(float);
+        case GL_ALPHA32F_EXT:
+        case GL_ALPHA:           return sizeof(float);
+        case GL_LUMINANCE32F_EXT:
+        case GL_LUMINANCE:       return sizeof(float);
+        case GL_LUMINANCE_ALPHA32F_EXT:
+        case GL_LUMINANCE_ALPHA: return sizeof(float) * 2;
+        case GL_RED:             return sizeof(float);
+        case GL_R32F:            return sizeof(float);
+        case GL_RG:              return sizeof(float) * 2;
+        case GL_RG32F:           return sizeof(float) * 2;
+        case GL_RGB:             return sizeof(float) * 3;
+        case GL_RGB32F:          return sizeof(float) * 3;
+        case GL_RGBA:            return sizeof(float) * 4;
+        case GL_RGBA32F:         return sizeof(float) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    case GL_HALF_FLOAT:
+    case GL_HALF_FLOAT_OES:
+        switch(format) {
+        case GL_ALPHA16F_EXT:
+        case GL_ALPHA:           return sizeof(unsigned short);
+        case GL_LUMINANCE16F_EXT:
+        case GL_LUMINANCE:       return sizeof(unsigned short);
+        case GL_LUMINANCE_ALPHA16F_EXT:
+        case GL_LUMINANCE_ALPHA: return sizeof(unsigned short) * 2;
+        case GL_RED:             return sizeof(unsigned short);
+        case GL_R16F:            return sizeof(unsigned short);
+        case GL_RG:              return sizeof(unsigned short) * 2;
+        case GL_RG16F:           return sizeof(unsigned short) * 2;
+        case GL_RGB:             return sizeof(unsigned short) * 3;
+        case GL_RGB16F:          return sizeof(unsigned short) * 3;
+        case GL_RGBA:            return sizeof(unsigned short) * 4;
+        case GL_RGBA16F:         return sizeof(unsigned short) * 4;
+        default: FORMAT_ERROR(format, type);
+        }
+        break;
+    default: FORMAT_ERROR(format, type);
+    }
+
+    return 0;
+}
+
+static int computePitch(GLsizei inputWidth, GLenum format, GLenum type, int align) {
+    GLsizei unaligned_width = computePixelSize(format, type) * inputWidth;
+    return HIGHEST_MULTIPLE_OF(align, unaligned_width);
+}
+
+static int computePackingOffset(GLenum format, GLenum type, GLsizei width, GLsizei height, int align, int skipPixels, int skipRows, int skipImages) {
+    GLsizei alignedPitch = computePitch(width, format, type, align);
+    int packingOffsetRows =
+        (skipImages * height + skipRows);
+    return packingOffsetRows * alignedPitch + skipPixels * computePixelSize(format, type);
+}
+
+void computeTextureStartEnd(
+        GLsizei width, GLsizei height, GLsizei depth,
+        GLenum format, GLenum type,
+        int unpackAlignment,
+        int unpackRowLength,
+        int unpackImageHeight,
+        int unpackSkipPixels,
+        int unpackSkipRows,
+        int unpackSkipImages,
+        int* start,
+        int* end) {
+
+    GLsizei inputWidth = (unpackRowLength == 0) ? width : unpackRowLength;
+    GLsizei inputPitch = computePitch(inputWidth, format, type, unpackAlignment);
+    GLsizei inputHeight = (unpackImageHeight == 0) ? height : unpackImageHeight;
+
+    ALOGV("%s: input idim %d %d %d w p h %d %d %d:", __FUNCTION__, width, height, depth, inputWidth, inputPitch, inputHeight);
+
+    int startVal = computePackingOffset(format, type, inputWidth, inputHeight, unpackAlignment, unpackSkipPixels, unpackSkipRows, unpackSkipImages);
+    int endVal = startVal + inputPitch * inputHeight * depth;
+
+    if (start) *start = startVal;
+    if (end) *end = endVal;
+
+    ALOGV("%s: start/end: %d %d", __FUNCTION__, *start, *end);
+
+}
+
+int computeTotalImageSize(
+        GLsizei width, GLsizei height, GLsizei depth,
+        GLenum format, GLenum type,
+        int unpackAlignment,
+        int unpackRowLength,
+        int unpackImageHeight,
+        int unpackSkipPixels,
+        int unpackSkipRows,
+        int unpackSkipImages) {
+
+    int start, end;
+    computeTextureStartEnd(
+            width, height, depth,
+            format, type,
+            unpackAlignment,
+            unpackRowLength,
+            unpackImageHeight,
+            unpackSkipPixels,
+            unpackSkipRows,
+            unpackSkipImages,
+            &start,
+            &end);
+    return end;
+}
+
+int computeNeededBufferSize(
+        GLsizei width, GLsizei height, GLsizei depth,
+        GLenum format, GLenum type,
+        int unpackAlignment,
+        int unpackRowLength,
+        int unpackImageHeight,
+        int unpackSkipPixels,
+        int unpackSkipRows,
+        int unpackSkipImages) {
+
+    int start, end;
+    computeTextureStartEnd(
+            width, height, depth,
+            format, type,
+            unpackAlignment,
+            unpackRowLength,
+            unpackImageHeight,
+            unpackSkipPixels,
+            unpackSkipRows,
+            unpackSkipImages,
+            &start,
+            &end);
+    return end - start;
+}
+
+} // namespace GLESTextureUtils
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLESTextureUtils.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLESTextureUtils.h
new file mode 100644
index 0000000..906e590
--- /dev/null
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLESTextureUtils.h
@@ -0,0 +1,42 @@
+#ifndef GLES_TEXTURE_UTILS_H
+#define GLES_TEXTURE_UTILS_H
+
+#include <GLES3/gl31.h>
+
+namespace GLESTextureUtils {
+
+void computeTextureStartEnd(
+        GLsizei width, GLsizei height, GLsizei depth,
+        GLenum format, GLenum type,
+        int unpackAlignment,
+        int unpackRowLength,
+        int unpackImageHeight,
+        int unpackSkipPixels,
+        int unpackSkipRows,
+        int unpackSkipImages,
+        int* start,
+        int* end);
+
+int computeTotalImageSize(
+        GLsizei width, GLsizei height, GLsizei depth,
+        GLenum format, GLenum type,
+        int unpackAlignment,
+        int unpackRowLength,
+        int unpackImageHeight,
+        int unpackSkipPixels,
+        int unpackSkipRows,
+        int unpackSkipImages);
+
+int computeNeededBufferSize(
+        GLsizei width, GLsizei height, GLsizei depth,
+        GLenum format, GLenum type,
+        int unpackAlignment,
+        int unpackRowLength,
+        int unpackImageHeight,
+        int unpackSkipPixels,
+        int unpackSkipRows,
+        int unpackSkipImages);
+
+
+} // namespace GLESTextureUtils
+#endif
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.cpp
old mode 100755
new mode 100644
index b079b6d..9da011a
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.cpp
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.cpp
@@ -27,8 +27,8 @@ static void clearObjectMap(android::DefaultKeyedVector<GLuint, T>& v) {
 
 /**** BufferData ****/
 
-BufferData::BufferData() : m_size(0) {};
-BufferData::BufferData(GLsizeiptr size, void * data) : m_size(size)
+BufferData::BufferData() : m_size(0), m_usage(0), m_mapped(false) {};
+BufferData::BufferData(GLsizeiptr size, void * data) : m_size(size), m_usage(0), m_mapped(false)
 {
     void * buffer = NULL;
     if (size>0) buffer = m_fixedBuffer.alloc(size);
@@ -227,7 +227,8 @@ bool ProgramData::detachShader(GLuint shader)
 GLSharedGroup::GLSharedGroup() :
     m_buffers(android::DefaultKeyedVector<GLuint, BufferData*>(NULL)),
     m_programs(android::DefaultKeyedVector<GLuint, ProgramData*>(NULL)),
-    m_shaders(android::DefaultKeyedVector<GLuint, ShaderData*>(NULL))
+    m_shaders(android::DefaultKeyedVector<GLuint, ShaderData*>(NULL)),
+    m_shaderPrograms(android::DefaultKeyedVector<GLuint, ShaderProgramData*>(NULL))
 {
 }
 
@@ -238,12 +239,15 @@ GLSharedGroup::~GLSharedGroup()
     clearObjectMap(m_buffers);
     clearObjectMap(m_programs);
     clearObjectMap(m_shaders);
+    clearObjectMap(m_shaderPrograms);
 }
 
-bool GLSharedGroup::isObject(GLuint obj)
+bool GLSharedGroup::isShaderOrProgramObject(GLuint obj)
 {
     android::AutoMutex _lock(m_lock);
-    return ((m_shaders.valueFor(obj)!=NULL) || (m_programs.valueFor(obj)!=NULL));
+    return ((m_shaders.valueFor(obj)!=NULL) ||
+            (m_programs.valueFor(obj)!=NULL) ||
+            (m_shaderPrograms.valueFor(m_shaderProgramIdMap[obj]) !=NULL));
 }
 
 BufferData * GLSharedGroup::getBufferData(GLuint bufferId)
@@ -252,6 +256,10 @@ BufferData * GLSharedGroup::getBufferData(GLuint bufferId)
     return m_buffers.valueFor(bufferId);
 }
 
+SharedTextureDataMap* GLSharedGroup::getTextureData() {
+    return &m_textureRecs;
+}
+
 void GLSharedGroup::addBufferData(GLuint bufferId, GLsizeiptr size, void * data)
 {
     android::AutoMutex _lock(m_lock);
@@ -270,6 +278,32 @@ void GLSharedGroup::updateBufferData(GLuint bufferId, GLsizeiptr size, void * da
     }
 }
 
+void GLSharedGroup::setBufferUsage(GLuint bufferId, GLenum usage) {
+    android::AutoMutex _lock(m_lock);
+    ssize_t idx = m_buffers.indexOfKey(bufferId);
+    if (idx >= 0) {
+        m_buffers.editValueAt(idx)->m_usage = usage;
+    }
+}
+
+void GLSharedGroup::setBufferMapped(GLuint bufferId, bool mapped) {
+    BufferData * buf = m_buffers.valueFor(bufferId);
+    if (!buf) return;
+    buf->m_mapped = mapped;
+}
+
+GLenum GLSharedGroup::getBufferUsage(GLuint bufferId) {
+    BufferData * buf = m_buffers.valueFor(bufferId);
+    if (!buf) return 0;
+    return buf->m_usage;
+}
+
+bool GLSharedGroup::isBufferMapped(GLuint bufferId) {
+    BufferData * buf = m_buffers.valueFor(bufferId);
+    if (!buf) return false;
+    return buf->m_mapped;
+}
+
 GLenum GLSharedGroup::subUpdateBufferData(GLuint bufferId, GLintptr offset, GLsizeiptr size, void * data)
 {
     android::AutoMutex _lock(m_lock);
@@ -278,6 +312,8 @@ GLenum GLSharedGroup::subUpdateBufferData(GLuint bufferId, GLintptr offset, GLsi
 
     //it's safe to update now
     memcpy((char*)buf->m_fixedBuffer.ptr() + offset, data, size);
+
+    buf->m_indexRangeCache.invalidateRange((size_t)offset, (size_t)size);
     return GL_NO_ERROR;
 }
 
@@ -322,6 +358,11 @@ bool GLSharedGroup::isProgramInitialized(GLuint program)
     {
         return pData->isInitialized();
     }
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return false;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) {
+        return spData->programData->isInitialized();
+    }
     return false;
 }
 
@@ -329,11 +370,21 @@ void GLSharedGroup::deleteProgramData(GLuint program)
 {
     android::AutoMutex _lock(m_lock);
     ProgramData *pData = m_programs.valueFor(program);
-    if (pData)
+    if (pData) {
         delete pData;
+    }
     m_programs.removeItem(program);
+
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) {
+        delete spData;
+    }
+    m_shaderPrograms.removeItem(m_shaderProgramIdMap[program]);
+    m_shaderProgramIdMap.erase(program);
 }
 
+// No such thing for separable shader programs.
 void GLSharedGroup::attachShader(GLuint program, GLuint shader)
 {
     android::AutoMutex _lock(m_lock);
@@ -358,6 +409,7 @@ void GLSharedGroup::detachShader(GLuint program, GLuint shader)
     }
 }
 
+// Not needed/used for separate shader programs.
 void GLSharedGroup::setProgramIndexInfo(GLuint program, GLuint index, GLint base, GLint size, GLenum type, const char* name)
 {
     android::AutoMutex _lock(m_lock);
@@ -391,10 +443,14 @@ GLenum GLSharedGroup::getProgramUniformType(GLuint program, GLint location)
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
     GLenum type=0;
-    if (pData)
-    {
+    if (pData) {
         type = pData->getTypeForLocation(location);
     }
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return type;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) {
+        type = spData->programData->getTypeForLocation(location);
+    }
     return type;
 }
 
@@ -402,7 +458,11 @@ bool  GLSharedGroup::isProgram(GLuint program)
 {
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
-    return (pData!=NULL);
+    if (pData) return true;
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return false;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) return true;
+    return false;
 }
 
 void GLSharedGroup::setupLocationShiftWAR(GLuint program)
@@ -417,7 +477,10 @@ GLint GLSharedGroup::locationWARHostToApp(GLuint program, GLint hostLoc, GLint a
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
     if (pData) return pData->locationWARHostToApp(hostLoc, arrIndex);
-    else return hostLoc;
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return hostLoc;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) return spData->programData->locationWARHostToApp(hostLoc, arrIndex);
+    return hostLoc;
 }
 
 GLint GLSharedGroup::locationWARAppToHost(GLuint program, GLint appLoc)
@@ -425,7 +488,10 @@ GLint GLSharedGroup::locationWARAppToHost(GLuint program, GLint appLoc)
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
     if (pData) return pData->locationWARAppToHost(appLoc);
-    else return appLoc;
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return appLoc;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) return spData->programData->locationWARAppToHost(appLoc);
+    return appLoc;
 }
 
 bool GLSharedGroup::needUniformLocationWAR(GLuint program)
@@ -433,6 +499,9 @@ bool GLSharedGroup::needUniformLocationWAR(GLuint program)
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
     if (pData) return pData->needUniformLocationWAR();
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return false;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) return spData->programData->needUniformLocationWAR();
     return false;
 }
 
@@ -440,14 +509,29 @@ GLint GLSharedGroup::getNextSamplerUniform(GLuint program, GLint index, GLint* v
 {
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
-    return pData ? pData->getNextSamplerUniform(index, val, target) : -1;
+    if (pData) return pData->getNextSamplerUniform(index, val, target);
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return -1;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap.find(program)->second);
+    if (spData) return spData->programData->getNextSamplerUniform(index, val, target);
+    return -1;
 }
 
 bool GLSharedGroup::setSamplerUniform(GLuint program, GLint appLoc, GLint val, GLenum* target)
 {
     android::AutoMutex _lock(m_lock);
     ProgramData* pData = m_programs.valueFor(program);
-    return pData ? pData->setSamplerUniform(appLoc, val, target) : false;
+    if (pData) return pData->setSamplerUniform(appLoc, val, target);
+    if (m_shaderProgramIdMap.find(program) == m_shaderProgramIdMap.end()) return false;
+    ShaderProgramData* spData = m_shaderPrograms.valueFor(m_shaderProgramIdMap[program]);
+    if (spData) return spData->programData->setSamplerUniform(appLoc, val, target);
+    return false;
+}
+
+bool  GLSharedGroup::isShader(GLuint shader)
+{
+    android::AutoMutex _lock(m_lock);
+    ShaderData* pData = m_shaders.valueFor(shader);
+    return (pData!=NULL);
 }
 
 bool GLSharedGroup::addShaderData(GLuint shader)
@@ -495,3 +579,80 @@ void GLSharedGroup::unrefShaderDataLocked(ssize_t shaderIdx)
         m_shaders.removeItemsAt(shaderIdx);
     }
 }
+
+uint32_t GLSharedGroup::addNewShaderProgramData() {
+    android::AutoMutex _lock(m_lock);
+    ShaderProgramData* data = new ShaderProgramData;
+    uint32_t currId = m_shaderProgramId;
+    ALOGD("%s: new data %p id %u", __FUNCTION__, data, currId);
+    m_shaderPrograms.add(currId, data);
+    m_shaderProgramId++;
+    return currId;
+}
+
+void GLSharedGroup::associateGLShaderProgram(GLuint shaderProgramName, uint32_t shaderProgramId) {
+    android::AutoMutex _lock(m_lock);
+    m_shaderProgramIdMap[shaderProgramName] = shaderProgramId;
+}
+
+ShaderProgramData* GLSharedGroup::getShaderProgramDataById(uint32_t id) {
+    android::AutoMutex _lock(m_lock);
+    ShaderProgramData* res = m_shaderPrograms.valueFor(id);
+    ALOGD("%s: id=%u res=%p", __FUNCTION__, id, res);
+    return res;
+}
+
+ShaderProgramData* GLSharedGroup::getShaderProgramData(GLuint shaderProgramName) {
+    android::AutoMutex _lock(m_lock);
+    return m_shaderPrograms.valueFor(m_shaderProgramIdMap[shaderProgramName]);
+}
+
+void GLSharedGroup::deleteShaderProgramDataById(uint32_t id) {
+    android::AutoMutex _lock(m_lock);
+    ShaderProgramData* data = m_shaderPrograms.valueFor(id);
+    delete data;
+    m_shaderPrograms.removeItemsAt(id);
+}
+
+
+void GLSharedGroup::deleteShaderProgramData(GLuint shaderProgramName) {
+    android::AutoMutex _lock(m_lock);
+    uint32_t id = m_shaderProgramIdMap[shaderProgramName];
+    ShaderProgramData* data = m_shaderPrograms.valueFor(id);
+    delete data;
+    m_shaderPrograms.removeItemsAt(id);
+    m_shaderProgramIdMap.erase(shaderProgramName);
+}
+
+void GLSharedGroup::initShaderProgramData(GLuint shaderProgram, GLuint numIndices) {
+    ShaderProgramData* spData = getShaderProgramData(shaderProgram);
+    spData->programData->initProgramData(numIndices);
+}
+
+void GLSharedGroup::setShaderProgramIndexInfo(GLuint shaderProgram, GLuint index, GLint base, GLint size, GLenum type, const char* name) {
+    ShaderProgramData* spData = getShaderProgramData(shaderProgram);
+    ProgramData* pData = spData->programData;
+    ShaderData* sData = spData->shaderData;
+
+    if (pData)
+    {
+        pData->setIndexInfo(index, base, size, type);
+
+        if (type == GL_SAMPLER_2D) {
+            ShaderData::StringList::iterator nameIter = sData->samplerExternalNames.begin();
+            ShaderData::StringList::iterator nameEnd  = sData->samplerExternalNames.end();
+            while (nameIter != nameEnd) {
+                if (*nameIter == name) {
+                    pData->setIndexFlags(index, ProgramData::INDEX_FLAG_SAMPLER_EXTERNAL);
+                    break;
+                }
+                ++nameIter;
+            }
+        }
+    }
+}
+
+void GLSharedGroup::setupShaderProgramLocationShiftWAR(GLuint shaderProgram) {
+    ShaderProgramData* spData = getShaderProgramData(shaderProgram);
+    spData->programData->setupLocationShiftWAR();
+}
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.h
old mode 100755
new mode 100644
index 6dfcd8f..ca33836
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/GLSharedGroup.h
@@ -22,11 +22,17 @@
 #define GL_APIENTRYP
 #endif
 
+#include "TextureSharedData.h"
+
 #include <GLES/gl.h>
 #include <GLES/glext.h>
 #include <GLES2/gl2.h>
 #include <GLES2/gl2ext.h>
 
+#include <map>
+#include <string>
+#include <vector>
+
 #include <stdio.h>
 #include <stdlib.h>
 #include "ErrorLog.h"
@@ -35,13 +41,26 @@
 #include <utils/String8.h>
 #include <utils/threads.h>
 #include "FixedBuffer.h"
+#include "IndexRangeCache.h"
 #include "SmartPtr.h"
 
 struct BufferData {
     BufferData();
     BufferData(GLsizeiptr size, void * data);
-    GLsizeiptr  m_size;
-    FixedBuffer m_fixedBuffer;    
+
+    // General buffer state
+    GLsizeiptr m_size;
+    GLenum m_usage;
+
+    // Mapped buffer state
+    bool m_mapped;
+    GLbitfield m_mappedAccess;
+    GLintptr m_mappedOffset;
+    GLsizeiptr m_mappedLength;
+
+    // Internal bookkeeping
+    FixedBuffer m_fixedBuffer; // actual buffer is shadowed here
+    IndexRangeCache m_indexRangeCache;
 };
 
 class ProgramData {
@@ -95,25 +114,51 @@ struct ShaderData {
     typedef android::List<android::String8> StringList;
     StringList samplerExternalNames;
     int refcount;
+    std::vector<std::string> sources;
+};
+
+class ShaderProgramData {
+public:
+    ShaderProgramData() {
+        shaderData = new ShaderData();
+        programData = new ProgramData();
+    }
+    ~ShaderProgramData() {
+        delete shaderData;
+        delete programData;
+    }
+    ShaderData* shaderData;
+    ProgramData* programData;
 };
 
 class GLSharedGroup {
 private:
+    SharedTextureDataMap m_textureRecs;
     android::DefaultKeyedVector<GLuint, BufferData*> m_buffers;
     android::DefaultKeyedVector<GLuint, ProgramData*> m_programs;
     android::DefaultKeyedVector<GLuint, ShaderData*> m_shaders;
+    android::DefaultKeyedVector<uint32_t, ShaderProgramData*> m_shaderPrograms;
+    std::map<GLuint, uint32_t> m_shaderProgramIdMap;
+
     mutable android::Mutex m_lock;
 
     void refShaderDataLocked(ssize_t shaderIdx);
     void unrefShaderDataLocked(ssize_t shaderIdx);
 
+    uint32_t m_shaderProgramId;
+
 public:
     GLSharedGroup();
     ~GLSharedGroup();
-    bool isObject(GLuint obj);
+    bool isShaderOrProgramObject(GLuint obj);
     BufferData * getBufferData(GLuint bufferId);
+    SharedTextureDataMap* getTextureData();
     void    addBufferData(GLuint bufferId, GLsizeiptr size, void * data);
     void    updateBufferData(GLuint bufferId, GLsizeiptr size, void * data);
+    void    setBufferUsage(GLuint bufferId, GLenum usage);
+    void    setBufferMapped(GLuint bufferId, bool mapped);
+    GLenum    getBufferUsage(GLuint bufferId);
+    bool    isBufferMapped(GLuint bufferId);
     GLenum  subUpdateBufferData(GLuint bufferId, GLintptr offset, GLsizeiptr size, void * data);
     void    deleteBufferData(GLuint);
 
@@ -133,10 +178,22 @@ public:
     GLint   getNextSamplerUniform(GLuint program, GLint index, GLint* val, GLenum* target) const;
     bool    setSamplerUniform(GLuint program, GLint appLoc, GLint val, GLenum* target);
 
+    bool    isShader(GLuint shader);
     bool    addShaderData(GLuint shader);
     // caller must hold a reference to the shader as long as it holds the pointer
     ShaderData* getShaderData(GLuint shader);
     void    unrefShaderData(GLuint shader);
+
+    // For separable shader programs.
+    uint32_t addNewShaderProgramData();
+    void associateGLShaderProgram(GLuint shaderProgramName, uint32_t shaderProgramId);
+    ShaderProgramData* getShaderProgramDataById(uint32_t id);
+    ShaderProgramData* getShaderProgramData(GLuint shaderProgramName);
+    void deleteShaderProgramDataById(uint32_t id);
+    void deleteShaderProgramData(GLuint shaderProgramName);
+    void initShaderProgramData(GLuint shaderProgram, GLuint numIndices);
+    void setShaderProgramIndexInfo(GLuint shaderProgram, GLuint index, GLint base, GLint size, GLenum type, const char* name);
+    void setupShaderProgramLocationShiftWAR(GLuint shaderProgram);
 };
 
 typedef SmartPtr<GLSharedGroup> GLSharedGroupPtr; 
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/IndexRangeCache.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/IndexRangeCache.cpp
new file mode 100644
index 0000000..c94e70c
--- /dev/null
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/IndexRangeCache.cpp
@@ -0,0 +1,84 @@
+/*
+* Copyright (C) 2016 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "IndexRangeCache.h"
+
+// This is almost literally
+// external/angle/src/libANGLE/IndexRangeCache.cpp
+
+void IndexRangeCache::addRange(GLenum type,
+                               size_t offset,
+                               size_t count,
+                               bool primitiveRestartEnabled,
+                               int start,
+                               int end) {
+    IndexRange r;
+    r.start = start;
+    r.end = end;
+    mIndexRangeCache[IndexRangeKey(type, offset, count, primitiveRestartEnabled)] = r;
+}
+
+bool IndexRangeCache::findRange(GLenum type,
+                                size_t offset,
+                                size_t count,
+                                bool primitiveRestartEnabled,
+                                int* start_out,
+                                int* end_out) const {
+    IndexRangeMap::const_iterator it =
+        mIndexRangeCache.find(
+                IndexRangeKey(type, offset, count, primitiveRestartEnabled));
+
+    if (it != mIndexRangeCache.end()) {
+        if (start_out) *start_out = it->second.start;
+        if (end_out) *end_out = it->second.end;
+        return true;
+    } else {
+        if (start_out) *start_out = 0;
+        if (end_out) *end_out = 0;
+        return false;
+    }
+}
+
+
+void IndexRangeCache::invalidateRange(size_t offset, size_t size) {
+    size_t invalidateStart = offset;
+    size_t invalidateEnd = offset + size;
+
+    IndexRangeMap::iterator it =
+        mIndexRangeCache.lower_bound(
+                IndexRangeKey(GL_UNSIGNED_BYTE,
+                              offset,
+                              size,
+                              false));
+
+    while (it != mIndexRangeCache.end()) {
+        size_t rangeStart = it->first.offset;
+        size_t rangeEnd =
+            it->first.offset +
+            it->first.count * glSizeof(it->first.type);
+
+        if (invalidateEnd < rangeStart ||
+            invalidateStart > rangeEnd) {
+            ++it;
+        } else {
+            mIndexRangeCache.erase(it++);
+        }
+    }
+}
+
+void IndexRangeCache::clear() {
+    mIndexRangeCache.clear();
+}
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/IndexRangeCache.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/IndexRangeCache.h
new file mode 100644
index 0000000..f19bd24
--- /dev/null
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/IndexRangeCache.h
@@ -0,0 +1,104 @@
+/*
+* Copyright (C) 2016 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+// This is almost literally
+// external/angle/src/common/mathutil.h: IndexRange +
+// external/angle/src/libANGLE/IndexRangeCache.h: IndexRangeCache,
+// with adaptations to work with goldfish opengl driver.
+// Currently, primitive restart is not supported, so there
+// is a very minimal incorporation of that.
+
+#ifndef _GL_INDEX_RANGE_CACHE_H_
+#define _GL_INDEX_RANGE_CACHE_H_
+
+#include <GLES/gl.h>
+#include <GLES/glext.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include "glUtils.h"
+
+#include <map>
+
+struct IndexRange {
+    // Inclusive range of indices that are not primitive restart
+    int start;
+    int end;
+
+    // Number of non-primitive restart indices
+    size_t vertexIndexCount; // TODO; not being accounted yet (GLES3 feature)
+};
+
+class IndexRangeCache {
+public:
+    void addRange(GLenum type,
+                  size_t offset,
+                  size_t count,
+                  bool primitiveRestartEnabled,
+                  int start,
+                  int end);
+    bool findRange(GLenum type,
+                   size_t offset,
+                   size_t count,
+                   bool primitiveRestartEnabled,
+                   int* start_out,
+                   int* end_out) const;
+    void invalidateRange(size_t offset, size_t size);
+    void clear();
+private:
+    struct IndexRangeKey {
+        IndexRangeKey() :
+            type(GL_NONE),
+            offset(0),
+            count(0),
+            primitiveRestartEnabled(false) { }
+        IndexRangeKey(GLenum _type,
+                      size_t _offset,
+                      size_t _count,
+                      bool _primitiveRestart) :
+            type(_type),
+            offset(_offset),
+            count(_count),
+            primitiveRestartEnabled(_primitiveRestart) { }
+
+        bool operator<(const IndexRangeKey& rhs) const {
+            size_t start = offset;
+            size_t start_other = rhs.offset;
+            size_t end = offset + count * glSizeof(type);
+            size_t end_other = rhs.offset + rhs.count * glSizeof(rhs.type);
+
+            if (end <= start_other) {
+                return true;
+            }
+
+            if (type != rhs.type) return type < rhs.type;
+            if (count != rhs.count) return count < rhs.count;
+            if (primitiveRestartEnabled != rhs.primitiveRestartEnabled)
+                return primitiveRestartEnabled;
+            return false;
+        }
+
+        GLenum type;
+        size_t offset;
+        size_t count;
+        bool primitiveRestartEnabled;
+    };
+
+    typedef std::map<IndexRangeKey, IndexRange> IndexRangeMap;
+    IndexRangeMap mIndexRangeCache;
+};
+
+#endif
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TcpStream.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TcpStream.cpp
index 4da2cec..2090ae0 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TcpStream.cpp
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TcpStream.cpp
@@ -28,6 +28,38 @@
 #include <ws2tcpip.h>
 #endif
 
+static int _socket_loopback_server(int port, int type)
+{
+    struct sockaddr_in addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(port);
+    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+
+    int s = socket(AF_INET, type, 0);
+    if (s < 0)
+        return -1;
+
+    int n = 1;
+    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (const char *) &n, sizeof(n));
+
+    if (bind(s, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
+        close(s);
+        return -1;
+    }
+
+    if (type == SOCK_STREAM) {
+        if (listen(s, 4) < 0) {
+            close(s);
+            return -1;
+        }
+    }
+
+    return s;
+}
+
 TcpStream::TcpStream(size_t bufSize) :
     SocketStream(bufSize)
 {
@@ -49,7 +81,7 @@ TcpStream::TcpStream(int sock, size_t bufSize) :
 
 int TcpStream::listen(unsigned short port)
 {
-    m_sock = socket_loopback_server(port, SOCK_STREAM);
+    m_sock = _socket_loopback_server(port, SOCK_STREAM);
     if (!valid()) return int(ERR_INVALID_SOCKET);
 
     return 0;
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TextureSharedData.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TextureSharedData.h
new file mode 100644
index 0000000..1372f7a
--- /dev/null
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/TextureSharedData.h
@@ -0,0 +1,42 @@
+/*
+* Copyright (C) 2016 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#ifndef _GL_TEXTURE_SHARED_DATA_H_
+#define _GL_TEXTURE_SHARED_DATA_H_
+
+#include <GLES/gl.h>
+#include <map>
+
+struct TextureDims {
+    std::map<GLsizei, GLsizei> widths;
+    std::map<GLsizei, GLsizei> heights;
+    std::map<GLsizei, GLsizei> depths;
+};
+
+struct TextureRec {
+    GLuint id;
+    GLenum target;
+    GLint internalformat;
+    GLenum format;
+    GLenum type;
+    GLsizei multisamples;
+    TextureDims* dims;
+    bool immutable;
+    bool boundEGLImage;
+};
+
+typedef std::map<GLuint, TextureRec*> SharedTextureDataMap;
+
+#endif
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/codec_defs.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/codec_defs.h
index f19f514..8fab90c 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/codec_defs.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/codec_defs.h
@@ -18,6 +18,10 @@
 
 #define CODEC_SERVER_PORT 22468
 
-#define CODEC_MAX_VERTEX_ATTRIBUTES 64
+enum {
+
+CODEC_MAX_VERTEX_ATTRIBUTES = 64,
+
+};
 
 #endif
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.cpp b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.cpp
index a61f76f..7e5e4a2 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.cpp
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.cpp
@@ -18,6 +18,8 @@
 #include "ErrorLog.h"
 #include <IOStream.h>
 
+#include <GLES3/gl31.h>
+
 size_t glSizeof(GLenum type)
 {
     size_t retval = 0;
@@ -28,9 +30,12 @@ size_t glSizeof(GLenum type)
         break;
     case GL_SHORT:
     case GL_UNSIGNED_SHORT:
+    case GL_HALF_FLOAT:
     case GL_HALF_FLOAT_OES:
         retval = 2;
         break;
+    case GL_IMAGE_2D:
+    case GL_IMAGE_3D:
     case GL_UNSIGNED_INT:
     case GL_INT:
     case GL_FLOAT:
@@ -45,10 +50,12 @@ size_t glSizeof(GLenum type)
 #endif
     case GL_FLOAT_VEC2:
     case GL_INT_VEC2:
+    case GL_UNSIGNED_INT_VEC2:
     case GL_BOOL_VEC2:
         retval = 8;
         break;
     case GL_INT_VEC3:
+    case GL_UNSIGNED_INT_VEC3:
     case GL_BOOL_VEC3:
     case GL_FLOAT_VEC3:
         retval = 12;
@@ -56,6 +63,7 @@ size_t glSizeof(GLenum type)
     case GL_FLOAT_VEC4:
     case GL_BOOL_VEC4:
     case GL_INT_VEC4:
+    case GL_UNSIGNED_INT_VEC4:
     case GL_FLOAT_MAT2:
         retval = 16;
         break;
@@ -65,12 +73,43 @@ size_t glSizeof(GLenum type)
     case GL_FLOAT_MAT4:
         retval = 64;
         break;
+    case GL_FLOAT_MAT2x3:
+    case GL_FLOAT_MAT3x2:
+        retval = 4 * 6;
+        break;
+    case GL_FLOAT_MAT2x4:
+    case GL_FLOAT_MAT4x2:
+        retval = 4 * 8;
+        break;
+    case GL_FLOAT_MAT3x4:
+    case GL_FLOAT_MAT4x3:
+        retval = 4 * 12;
+        break;
     case GL_SAMPLER_2D:
+    case GL_SAMPLER_3D:
     case GL_SAMPLER_CUBE:
         retval = 4;
         break;
+    case GL_UNSIGNED_SHORT_4_4_4_4:
+	case GL_UNSIGNED_SHORT_5_5_5_1:
+	case GL_UNSIGNED_SHORT_5_6_5:
+	case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT:
+	case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT:
+        retval = 2;
+        break;
+	case GL_INT_2_10_10_10_REV:
+	case GL_UNSIGNED_INT_10F_11F_11F_REV:
+	case GL_UNSIGNED_INT_5_9_9_9_REV:
+	case GL_UNSIGNED_INT_2_10_10_10_REV:
+	case GL_UNSIGNED_INT_24_8_OES:;
+        retval = 4;
+        break;
+	case GL_FLOAT_32_UNSIGNED_INT_24_8_REV:
+		retval = 4 + 4;
+        break;
     default:
-        ERR("**** ERROR unknown type 0x%x (%s,%d)\n", type, __FUNCTION__,__LINE__);
+        ALOGE("**** ERROR unknown type 0x%x (%s,%d)\n", type, __FUNCTION__,__LINE__);
+        retval = 4;
     }
     return retval;
 
@@ -260,16 +299,9 @@ size_t glUtilsParamSize(GLenum param)
     case GL_BLEND_SRC_ALPHA_OES:
     case GL_MAX_LIGHTS:
     case GL_SHADER_TYPE:
-    case GL_DELETE_STATUS:
     case GL_COMPILE_STATUS:
-    case GL_INFO_LOG_LENGTH:
     case GL_SHADER_SOURCE_LENGTH:
     case GL_CURRENT_PROGRAM:
-    case GL_LINK_STATUS:
-    case GL_VALIDATE_STATUS:
-    case GL_ATTACHED_SHADERS:
-    case GL_ACTIVE_UNIFORMS:
-    case GL_ACTIVE_ATTRIBUTES:
     case GL_SUBPIXEL_BITS:
     case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
     case GL_NUM_SHADER_BINARY_FORMATS:
@@ -285,6 +317,38 @@ size_t glUtilsParamSize(GLenum param)
     case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
     case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:
     case GL_LINE_WIDTH:
+    case GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:
+    case GL_MAX_UNIFORM_BUFFER_BINDINGS:
+    case GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS:
+    case GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS:
+    case GL_UNIFORM_BLOCK_BINDING:
+    case GL_UNIFORM_BLOCK_DATA_SIZE:
+    case GL_UNIFORM_BLOCK_NAME_LENGTH:
+    case GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS:
+    case GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:
+    case GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:
+    case GL_CURRENT_QUERY:
+    case GL_QUERY_RESULT:
+    case GL_QUERY_RESULT_AVAILABLE:
+    case GL_READ_BUFFER:
+
+    case GL_ACTIVE_ATOMIC_COUNTER_BUFFERS:
+    case GL_ACTIVE_ATTRIBUTES:
+    case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
+    case GL_ACTIVE_UNIFORM_BLOCKS:
+    case GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:
+    case GL_ACTIVE_UNIFORMS:
+    case GL_ACTIVE_UNIFORM_MAX_LENGTH:
+    case GL_ATTACHED_SHADERS:
+    case GL_DELETE_STATUS:
+    case GL_INFO_LOG_LENGTH:
+    case GL_LINK_STATUS:
+    case GL_PROGRAM_BINARY_RETRIEVABLE_HINT:
+    case GL_PROGRAM_SEPARABLE:
+    case GL_TRANSFORM_FEEDBACK_BUFFER_MODE:
+    case GL_TRANSFORM_FEEDBACK_VARYINGS:
+    case GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH:
+    case GL_VALIDATE_STATUS:
         s = 1;
         break;
     case GL_ALIASED_LINE_WIDTH_RANGE:
@@ -293,11 +357,13 @@ size_t glUtilsParamSize(GLenum param)
     case GL_MAX_VIEWPORT_DIMS:
     case GL_SMOOTH_POINT_SIZE_RANGE:
     case GL_SMOOTH_LINE_WIDTH_RANGE:
+    case GL_SAMPLE_POSITION:
         s= 2;
         break;
     case GL_SPOT_DIRECTION:
     case GL_POINT_DISTANCE_ATTENUATION:
     case GL_CURRENT_NORMAL:
+    case GL_COMPUTE_WORK_GROUP_SIZE:
         s =  3;
         break;
     case GL_CURRENT_VERTEX_ATTRIB:
@@ -337,6 +403,15 @@ void glUtilsPackPointerData(unsigned char *dst, unsigned char *src,
                      unsigned int datalen)
 {
     unsigned int  vsize = size * glSizeof(type);
+    switch (type) {
+    case GL_INT_2_10_10_10_REV:
+    case GL_UNSIGNED_INT_2_10_10_10_REV:
+        vsize = vsize / 4;
+        break;
+    default:
+        break;
+    }
+
     if (stride == 0) stride = vsize;
 
     if (stride == vsize) {
@@ -473,3 +548,85 @@ int glUtilsCalcShaderSourceLen( char **strings,  GLint *length, GLsizei count)
     return len;
 
 }
+
+// helper to get GL_COLOR_ATTACHMENTn names
+GLenum glUtilsColorAttachmentName(int i) {
+#undef COLOR_ATTACHMENT_CASE
+#define COLOR_ATTACHMENT_CASE(i) \
+    case i: \
+        return GL_COLOR_ATTACHMENT##i; \
+
+    switch (i) {
+        COLOR_ATTACHMENT_CASE(0)
+        COLOR_ATTACHMENT_CASE(1)
+        COLOR_ATTACHMENT_CASE(2)
+        COLOR_ATTACHMENT_CASE(3)
+        COLOR_ATTACHMENT_CASE(4)
+        COLOR_ATTACHMENT_CASE(5)
+        COLOR_ATTACHMENT_CASE(6)
+        COLOR_ATTACHMENT_CASE(7)
+        COLOR_ATTACHMENT_CASE(8)
+        COLOR_ATTACHMENT_CASE(9)
+        COLOR_ATTACHMENT_CASE(10)
+        COLOR_ATTACHMENT_CASE(11)
+        COLOR_ATTACHMENT_CASE(12)
+        COLOR_ATTACHMENT_CASE(13)
+        COLOR_ATTACHMENT_CASE(14)
+        COLOR_ATTACHMENT_CASE(15)
+    }
+    return GL_NONE;
+#undef COLOR_ATTACHMENT_CASE
+}
+
+int glUtilsColorAttachmentIndex(GLenum attachment) {
+#undef COLOR_ATTACHMENT_CASE
+#define COLOR_ATTACHMENT_CASE(i) \
+    case GL_COLOR_ATTACHMENT##i: \
+        return i; \
+
+    switch (attachment) {
+        COLOR_ATTACHMENT_CASE(0)
+        COLOR_ATTACHMENT_CASE(1)
+        COLOR_ATTACHMENT_CASE(2)
+        COLOR_ATTACHMENT_CASE(3)
+        COLOR_ATTACHMENT_CASE(4)
+        COLOR_ATTACHMENT_CASE(5)
+        COLOR_ATTACHMENT_CASE(6)
+        COLOR_ATTACHMENT_CASE(7)
+        COLOR_ATTACHMENT_CASE(8)
+        COLOR_ATTACHMENT_CASE(9)
+        COLOR_ATTACHMENT_CASE(10)
+        COLOR_ATTACHMENT_CASE(11)
+        COLOR_ATTACHMENT_CASE(12)
+        COLOR_ATTACHMENT_CASE(13)
+        COLOR_ATTACHMENT_CASE(14)
+        COLOR_ATTACHMENT_CASE(15)
+    }
+    return -1;
+#undef COLOR_ATTACHMENT_CASE
+}
+
+struct glUtilsDrawArraysIndirectCommand {
+    GLuint count;
+    GLuint primCount;
+    GLuint first;
+    GLuint reserved;
+};
+
+struct glUtilsDrawElementsIndirectCommand {
+    GLuint count;
+    GLuint primCount;
+    GLuint first;
+    GLint baseVertex;
+    GLuint reserved;
+};
+
+GLuint glUtilsIndirectStructSize(IndirectCommandType cmdType) {
+    switch (cmdType) {
+    case INDIRECT_COMMAND_DRAWARRAYS:
+        return sizeof(glUtilsDrawArraysIndirectCommand);
+    case INDIRECT_COMMAND_DRAWELEMENTS:
+        return sizeof(glUtilsDrawElementsIndirectCommand);
+    }
+    return 4;
+}
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.h
index f8857f1..2210699 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/glUtils.h
@@ -46,6 +46,11 @@
 extern "C" {
 #endif
 
+typedef enum {
+    INDIRECT_COMMAND_DRAWARRAYS = 0,
+    INDIRECT_COMMAND_DRAWELEMENTS = 1,
+} IndirectCommandType;
+
     size_t glSizeof(GLenum type);
     size_t glUtilsParamSize(GLenum param);
     void   glUtilsPackPointerData(unsigned char *dst, unsigned char *str,
@@ -57,16 +62,21 @@ extern "C" {
     int glUtilsPixelBitSize(GLenum format, GLenum type);
     void   glUtilsPackStrings(char *ptr, char **strings, GLint *length, GLsizei count);
     int glUtilsCalcShaderSourceLen(char **strings, GLint *length, GLsizei count);
+    GLenum glUtilsColorAttachmentName(int i);
+    int glUtilsColorAttachmentIndex(GLenum attachment);
+
+    GLuint glUtilsIndirectStructSize(IndirectCommandType cmdType);
+
 #ifdef __cplusplus
 };
 #endif
 
 namespace GLUtils {
 
-    template <class T> void minmax(T *indices, int count, int *min, int *max) {
+    template <class T> void minmax(const T *indices, int count, int *min, int *max) {
         *min = -1;
         *max = -1;
-        T *ptr = indices;
+        const T *ptr = indices;
         for (int i = 0; i < count; i++) {
             if (*min == -1 || *ptr < *min) *min = *ptr;
             if (*max == -1 || *ptr > *max) *max = *ptr;
@@ -74,6 +84,24 @@ namespace GLUtils {
         }
     }
 
+    template <class T> void minmaxExcept
+        (const T *indices, int count, int *min, int *max,
+         bool shouldExclude, T whatExclude) {
+
+        if (!shouldExclude) return minmax(indices, count, min, max);
+
+        *min = -1;
+        *max = -1;
+        const T *ptr = indices;
+        for (int i = 0; i < count; i++) {
+            if (*ptr != whatExclude) {
+                if (*min == -1 || *ptr < *min) *min = *ptr;
+                if (*max == -1 || *ptr > *max) *max = *ptr;
+            }
+            ptr++;
+        }
+    }
+
     template <class T> void shiftIndices(T *indices, int count,  int offset) {
         T *ptr = indices;
         for (int i = 0; i < count; i++) {
@@ -83,7 +111,7 @@ namespace GLUtils {
     }
 
 
-    template <class T> void shiftIndices(T *src, T *dst, int count, int offset)
+    template <class T> void shiftIndices(const T *src, T *dst, int count, int offset)
     {
         for (int i = 0; i < count; i++) {
             *dst = *src + offset;
@@ -91,5 +119,42 @@ namespace GLUtils {
             src++;
         }
     }
+
+    template <class T> void shiftIndicesExcept
+        (T *indices, int count, int offset,
+         bool shouldExclude, T whatExclude) {
+
+        if (!shouldExclude) return shiftIndices(indices, count, offset);
+
+        T *ptr = indices;
+        for (int i = 0; i < count; i++) {
+            if (*ptr != whatExclude) {
+                *ptr += offset;
+            }
+            ptr++;
+        }
+    }
+
+    template <class T> void shiftIndicesExcept
+        (const T *src, T *dst, int count, int offset,
+         bool shouldExclude, T whatExclude) {
+
+        if (!shouldExclude) return shiftIndices(src, dst, count, offset);
+
+        for (int i = 0; i < count; i++) {
+            if (*src == whatExclude) {
+                *dst = *src;
+            } else {
+                *dst = *src + offset;
+            }
+            dst++;
+            src++;
+        }
+    }
+
+    template<class T> T primitiveRestartIndex() {
+        return -1;
+    }
+
 }; // namespace GLUtils
 #endif
diff --git a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/gl_base_types.h b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/gl_base_types.h
index d7ecf95..70cb325 100644
--- a/vendor/anbox/android/opengl/shared/OpenglCodecCommon/gl_base_types.h
+++ b/vendor/anbox/android/opengl/shared/OpenglCodecCommon/gl_base_types.h
@@ -18,12 +18,12 @@
 
 #include <KHR/khrplatform.h>
 
-#ifndef gl_APIENTRY
-#define gl_APIENTRY KHRONOS_APIENTRY
+#ifndef gles1_APIENTRY
+#define gles1_APIENTRY KHRONOS_APIENTRY
 #endif
 
-#ifndef gl2_APIENTRY
-#define gl2_APIENTRY KHRONOS_APIENTRY
+#ifndef gles2_APIENTRY
+#define gles2_APIENTRY KHRONOS_APIENTRY
 #endif
 
 typedef void             GLvoid;
@@ -47,6 +47,9 @@ typedef khronos_ssize_t  GLsizeiptr;
 typedef char *GLstr;
 /* JR XXX Treating this as an in handle - is this correct? */
 typedef void * GLeglImageOES;
+typedef struct __GLsync *GLsync;
+typedef khronos_int64_t GLint64;
+typedef khronos_uint64_t GLuint64;
 
 /* ErrorCode */
 #ifndef GL_INVALID_ENUM
@@ -57,7 +60,6 @@ typedef void * GLeglImageOES;
 #define GL_STACK_OVERFLOW                 0x0503
 #define GL_STACK_UNDERFLOW                0x0504
 #define GL_OUT_OF_MEMORY                  0x0505
-#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
 #endif
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/GLESv1/Android.mk b/vendor/anbox/android/opengl/system/GLESv1/Android.mk
index 8762c11..1090603 100644
--- a/vendor/anbox/android/opengl/system/GLESv1/Android.mk
+++ b/vendor/anbox/android/opengl/system/GLESv1/Android.mk
@@ -7,6 +7,10 @@ $(call emugl-import,libOpenglSystemCommon libGLESv1_enc lib_renderControl_enc)
 LOCAL_CFLAGS += -DLOG_TAG=\"GLES_emulation\" -DGL_GLEXT_PROTOTYPES
 
 LOCAL_SRC_FILES := gl.cpp
-LOCAL_MODULE_RELATIVE_PATH := egl
+ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 21 && echo PreLollipop),PreLollipop)
+    LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/egl
+else
+    LOCAL_MODULE_RELATIVE_PATH := egl
+endif
 
 $(call emugl-end-module)
diff --git a/vendor/anbox/android/opengl/system/GLESv1/gl.cpp b/vendor/anbox/android/opengl/system/GLESv1/gl.cpp
index 8aaf347..e20b45d 100644
--- a/vendor/anbox/android/opengl/system/GLESv1/gl.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv1/gl.cpp
@@ -54,7 +54,7 @@ void glEGLImageTargetTexture2DOES(void * self, GLenum target, GLeglImageOES img)
     (void)self;
 
     DBG("glEGLImageTargetTexture2DOES v1 target=%#x img=%p", target, img);
-
+    
     EGLImage_t *image = (EGLImage_t*)img;
 
     if (image->target == EGL_NATIVE_BUFFER_ANDROID) {
@@ -127,12 +127,31 @@ void finish()
     glFinish();
 }
 
+void getIntegerv(unsigned int pname, int* param)
+{
+    glGetIntegerv((GLenum)pname, (GLint*)param);
+}
+
 const GLubyte *my_glGetString (void *self, GLenum name)
 {
     (void)self;
 
-    if (s_egl) {
-        return (const GLubyte*)s_egl->getGLString(name);
+    //see ref in https://www.khronos.org/opengles/sdk/docs/man
+    //name in glGetString can be one of the following five values
+    switch (name) {
+        case GL_VERSION:
+        case GL_VENDOR:
+        case GL_RENDERER:
+        case GL_SHADING_LANGUAGE_VERSION:
+        case GL_EXTENSIONS:
+            if (s_egl) {
+                return (const GLubyte*)s_egl->getGLString(name);
+            }
+            break;
+        default:
+            GET_CONTEXT;
+            ctx->setError(GL_INVALID_ENUM);
+            break;
     }
     return NULL;
 }
@@ -156,6 +175,7 @@ EGLClient_glesInterface * init_emul_gles(EGLClient_eglInterface *eglIface)
         s_gl->getProcAddress = getProcAddress;
         s_gl->finish = finish;
         s_gl->init = init;
+        s_gl->getIntegerv = getIntegerv;
     }
 
     return s_gl;
diff --git a/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.cpp b/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.cpp
index 8556c27..b698fae 100644
--- a/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.cpp
@@ -267,28 +267,28 @@ void GLEncoder::s_glVertexPointer(void *self, int size, GLenum type, GLsizei str
 {
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
-    ctx->m_state->setState(GLClientState::VERTEX_LOCATION, size, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(GLClientState::VERTEX_LOCATION, size, type, false, stride, data);
 }
 
 void GLEncoder::s_glNormalPointer(void *self, GLenum type, GLsizei stride, const void *data)
 {
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
-    ctx->m_state->setState(GLClientState::NORMAL_LOCATION, 3, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(GLClientState::NORMAL_LOCATION, 3, type, false, stride, data);
 }
 
 void GLEncoder::s_glColorPointer(void *self, int size, GLenum type, GLsizei stride, const void *data)
 {
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
-    ctx->m_state->setState(GLClientState::COLOR_LOCATION, size, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(GLClientState::COLOR_LOCATION, size, type, false, stride, data);
 }
 
 void GLEncoder::s_glPointSizePointerOES(void *self, GLenum type, GLsizei stride, const void *data)
 {
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
-    ctx->m_state->setState(GLClientState::POINTSIZE_LOCATION, 1, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(GLClientState::POINTSIZE_LOCATION, 1, type, false, stride, data);
 }
 
 void GLEncoder::s_glClientActiveTexture(void *self, GLenum texture)
@@ -303,7 +303,7 @@ void GLEncoder::s_glTexCoordPointer(void *self, int size, GLenum type, GLsizei s
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
     int loc = ctx->m_state->getLocation(GL_TEXTURE_COORD_ARRAY);
-    ctx->m_state->setState(loc, size, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(loc, size, type, false, stride, data);
 }
 
 void GLEncoder::s_glMatrixIndexPointerOES(void *self, int size, GLenum type, GLsizei stride, const void * data)
@@ -311,7 +311,7 @@ void GLEncoder::s_glMatrixIndexPointerOES(void *self, int size, GLenum type, GLs
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
     int loc = ctx->m_state->getLocation(GL_MATRIX_INDEX_ARRAY_OES);
-    ctx->m_state->setState(loc, size, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(loc, size, type, false, stride, data);
 }
 
 void GLEncoder::s_glWeightPointerOES(void * self, int size, GLenum type, GLsizei stride, const void * data)
@@ -319,7 +319,7 @@ void GLEncoder::s_glWeightPointerOES(void * self, int size, GLenum type, GLsizei
     GLEncoder *ctx = (GLEncoder *)self;
     assert(ctx->m_state != NULL);
     int loc = ctx->m_state->getLocation(GL_WEIGHT_ARRAY_OES);
-    ctx->m_state->setState(loc, size, type, false, stride, data);
+    ctx->m_state->setVertexAttribState(loc, size, type, false, stride, data);
 }
 
 void GLEncoder::s_glEnableClientState(void *self, GLenum state)
@@ -343,12 +343,8 @@ GLboolean GLEncoder::s_glIsEnabled(void *self, GLenum cap)
     GLEncoder *ctx = (GLEncoder *) self;
     assert(ctx->m_state != NULL);
     int loc = ctx->m_state->getLocation(cap);
-    const GLClientState::VertexAttribState *state = ctx->m_state->getState(loc);
-
-    if (state!=NULL)
-      return state->enabled;
-
-    return ctx->m_glIsEnabled_enc(self,cap);
+    const GLClientState::VertexAttribState& state = ctx->m_state->getState(loc);
+    return state.enabled;
 }
 
 void GLEncoder::s_glBindBuffer(void *self, GLenum target, GLuint id)
@@ -396,46 +392,43 @@ void GLEncoder::s_glDeleteBuffers(void * self, GLsizei n, const GLuint * buffers
 void GLEncoder::sendVertexData(unsigned int first, unsigned int count)
 {
     assert(m_state != NULL);
+    GLenum prevActiveTexUnit = m_state->getActiveTextureUnit();
     for (int i = 0; i < GLClientState::LAST_LOCATION; i++) {
         bool enableDirty;
-        const GLClientState::VertexAttribState *state = m_state->getStateAndEnableDirty(i, &enableDirty);
-
-        // do not process if state not valid
-        if (!state) continue;
+        const GLClientState::VertexAttribState& state = m_state->getStateAndEnableDirty(i, &enableDirty);
 
         // do not send disable state if state was already disabled
-        if (!enableDirty && !state->enabled) continue;
+        if (!enableDirty && !state.enabled) continue;
 
         if ( i >= GLClientState::TEXCOORD0_LOCATION &&
             i <= GLClientState::TEXCOORD7_LOCATION ) {
             m_glClientActiveTexture_enc(this, GL_TEXTURE0 + i - GLClientState::TEXCOORD0_LOCATION);
         }
 
-        if (state->enabled) {
-
+        if (state.enabled) {
             if (enableDirty)
-                m_glEnableClientState_enc(this, state->glConst);
+                m_glEnableClientState_enc(this, state.glConst);
 
-            unsigned int datalen = state->elementSize * count;
-            int stride = state->stride;
-            if (stride == 0) stride = state->elementSize;
+            unsigned int datalen = state.elementSize * count;
+            int stride = state.stride;
+            if (stride == 0) stride = state.elementSize;
             int firstIndex = stride * first;
 
-            this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, state->bufferObject);
-            if (state->bufferObject == 0) {
+            this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, state.bufferObject);
+            if (state.bufferObject == 0) {
 
                 switch(i) {
                 case GLClientState::VERTEX_LOCATION:
-                    this->glVertexPointerData(this, state->size, state->type, state->stride,
-                                              (unsigned char *)state->data + firstIndex, datalen);
+                    this->glVertexPointerData(this, state.size, state.type, state.stride,
+                                              (unsigned char *)state.data + firstIndex, datalen);
                     break;
                 case GLClientState::NORMAL_LOCATION:
-                    this->glNormalPointerData(this, state->type, state->stride,
-                                              (unsigned char *)state->data + firstIndex, datalen);
+                    this->glNormalPointerData(this, state.type, state.stride,
+                                              (unsigned char *)state.data + firstIndex, datalen);
                     break;
                 case GLClientState::COLOR_LOCATION:
-                    this->glColorPointerData(this, state->size, state->type, state->stride,
-                                             (unsigned char *)state->data + firstIndex, datalen);
+                    this->glColorPointerData(this, state.size, state.type, state.stride,
+                                             (unsigned char *)state.data + firstIndex, datalen);
                     break;
                 case GLClientState::TEXCOORD0_LOCATION:
                 case GLClientState::TEXCOORD1_LOCATION:
@@ -445,40 +438,43 @@ void GLEncoder::sendVertexData(unsigned int first, unsigned int count)
                 case GLClientState::TEXCOORD5_LOCATION:
                 case GLClientState::TEXCOORD6_LOCATION:
                 case GLClientState::TEXCOORD7_LOCATION:
-                    this->glTexCoordPointerData(this, i - GLClientState::TEXCOORD0_LOCATION, state->size, state->type, state->stride,
-                                                (unsigned char *)state->data + firstIndex, datalen);
+                    m_state->setActiveTextureUnit(i - GLClientState::TEXCOORD0_LOCATION + GL_TEXTURE0);
+                    if (m_state->getPriorityEnabledTarget(GL_INVALID_ENUM) != GL_INVALID_ENUM) {
+                        this->glTexCoordPointerData(this, i - GLClientState::TEXCOORD0_LOCATION, state.size, state.type, state.stride,
+                                                (unsigned char *)state.data + firstIndex, datalen);
+                    }
                     break;
                 case GLClientState::POINTSIZE_LOCATION:
-                    this->glPointSizePointerData(this, state->type, state->stride,
-                                                 (unsigned char *) state->data + firstIndex, datalen);
+                    this->glPointSizePointerData(this, state.type, state.stride,
+                                                 (unsigned char *) state.data + firstIndex, datalen);
                     break;
                 case GLClientState::WEIGHT_LOCATION:
-                    this->glWeightPointerData(this, state->size, state->type, state->stride,
-                                              (unsigned char * ) state->data + firstIndex, datalen);
+                    this->glWeightPointerData(this, state.size, state.type, state.stride,
+                                              (unsigned char * ) state.data + firstIndex, datalen);
                     break;
                 case GLClientState::MATRIXINDEX_LOCATION:
-                    this->glMatrixIndexPointerData(this, state->size, state->type, state->stride,
-                                                  (unsigned char *)state->data + firstIndex, datalen);
+                    this->glMatrixIndexPointerData(this, state.size, state.type, state.stride,
+                                                  (unsigned char *)state.data + firstIndex, datalen);
                     break;
                 }
             } else {
 
                 switch(i) {
                 case GLClientState::VERTEX_LOCATION:
-                    this->glVertexPointerOffset(this, state->size, state->type, state->stride,
-                                                (uintptr_t)state->data + firstIndex);
+                    this->glVertexPointerOffset(this, state.size, state.type, state.stride,
+                                                (uintptr_t)state.data + firstIndex);
                     break;
                 case GLClientState::NORMAL_LOCATION:
-                    this->glNormalPointerOffset(this, state->type, state->stride,
-                                                (uintptr_t)state->data + firstIndex);
+                    this->glNormalPointerOffset(this, state.type, state.stride,
+                                                (uintptr_t)state.data + firstIndex);
                     break;
                 case GLClientState::POINTSIZE_LOCATION:
-                    this->glPointSizePointerOffset(this, state->type, state->stride,
-                                                   (uintptr_t)state->data + firstIndex);
+                    this->glPointSizePointerOffset(this, state.type, state.stride,
+                                                   (uintptr_t)state.data + firstIndex);
                     break;
                 case GLClientState::COLOR_LOCATION:
-                    this->glColorPointerOffset(this, state->size, state->type, state->stride,
-                                               (uintptr_t)state->data + firstIndex);
+                    this->glColorPointerOffset(this, state.size, state.type, state.stride,
+                                               (uintptr_t)state.data + firstIndex);
                     break;
                 case GLClientState::TEXCOORD0_LOCATION:
                 case GLClientState::TEXCOORD1_LOCATION:
@@ -488,24 +484,25 @@ void GLEncoder::sendVertexData(unsigned int first, unsigned int count)
                 case GLClientState::TEXCOORD5_LOCATION:
                 case GLClientState::TEXCOORD6_LOCATION:
                 case GLClientState::TEXCOORD7_LOCATION:
-                    this->glTexCoordPointerOffset(this, state->size, state->type, state->stride,
-                                                  (uintptr_t)state->data + firstIndex);
+                    this->glTexCoordPointerOffset(this, state.size, state.type, state.stride,
+                                                  (uintptr_t)state.data + firstIndex);
                     break;
                 case GLClientState::WEIGHT_LOCATION:
-                    this->glWeightPointerOffset(this,state->size,state->type,state->stride,
-                                                (uintptr_t)state->data+firstIndex);
+                    this->glWeightPointerOffset(this,state.size,state.type,state.stride,
+                                                (uintptr_t)state.data+firstIndex);
                     break;
                 case GLClientState::MATRIXINDEX_LOCATION:
-                    this->glMatrixIndexPointerOffset(this,state->size,state->type,state->stride,
-                                              (uintptr_t)state->data+firstIndex);
+                    this->glMatrixIndexPointerOffset(this,state.size,state.type,state.stride,
+                                              (uintptr_t)state.data+firstIndex);
                     break;
                 }
             }
             this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, m_state->currentArrayVbo());
         } else {
-            this->m_glDisableClientState_enc(this, state->glConst);
+            this->m_glDisableClientState_enc(this, state.glConst);
         }
     }
+    m_state->setActiveTextureUnit(prevActiveTexUnit);
 }
 
 void GLEncoder::s_glDrawArrays(void *self, GLenum mode, GLint first, GLsizei count)
@@ -514,9 +511,9 @@ void GLEncoder::s_glDrawArrays(void *self, GLenum mode, GLint first, GLsizei cou
 
     bool has_arrays = false;
     for (int i = 0; i < GLClientState::LAST_LOCATION; i++) {
-        const GLClientState::VertexAttribState *state = ctx->m_state->getState(i);
-        if (state->enabled) {
-            if (state->bufferObject || state->data) {
+        const GLClientState::VertexAttribState& state = ctx->m_state->getState(i);
+        if (state.enabled) {
+            if (state.bufferObject || state.data) {
                 has_arrays = true;
             } else {
                 ALOGE("glDrawArrays: a vertex attribute array is enabled with no data bound\n");
@@ -532,6 +529,7 @@ void GLEncoder::s_glDrawArrays(void *self, GLenum mode, GLint first, GLsizei cou
 
     ctx->sendVertexData(first, count);
     ctx->m_glDrawArrays_enc(ctx, mode, /*first*/ 0, count);
+    ctx->m_stream->flush();
 }
 
 void GLEncoder::s_glDrawElements(void *self, GLenum mode, GLsizei count, GLenum type, const void *indices)
@@ -545,11 +543,11 @@ void GLEncoder::s_glDrawElements(void *self, GLenum mode, GLsizei count, GLenum
     bool has_indirect_arrays = false;
 
     for (int i = 0; i < GLClientState::LAST_LOCATION; i++) {
-        const GLClientState::VertexAttribState *state = ctx->m_state->getState(i);
-        if (state->enabled) {
-            if (state->bufferObject != 0) {
+        const GLClientState::VertexAttribState& state = ctx->m_state->getState(i);
+        if (state.enabled) {
+            if (state.bufferObject != 0) {
                 has_indirect_arrays = true;
-            } else if (state->data) {
+            } else if (state.data) {
                 has_immediate_arrays = true;
             } else {
                 ALOGE("glDrawElements: a vertex attribute array is enabled with no data bound\n");
@@ -570,6 +568,7 @@ void GLEncoder::s_glDrawElements(void *self, GLenum mode, GLsizei count, GLenum
             ctx->sendVertexData(0, count);
             ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, ctx->m_state->currentIndexVbo());
             ctx->glDrawElementsOffset(ctx, mode, count, type, (uintptr_t)indices);
+            ctx->m_stream->flush();
             adjustIndices = false;
         } else {
             BufferData * buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
@@ -619,6 +618,7 @@ void GLEncoder::s_glDrawElements(void *self, GLenum mode, GLsizei count, GLenum
             ctx->sendVertexData(minIndex, maxIndex - minIndex + 1);
             ctx->glDrawElementsData(ctx, mode, count, type, adjustedIndices,
                                       count * glSizeof(type));
+            ctx->m_stream->flush();
             // XXX - OPTIMIZATION (see the other else branch) should be implemented
             if(!has_indirect_arrays) {
                 //ALOGD("unoptimized drawelements !!!\n");
@@ -950,6 +950,78 @@ void GLEncoder::restore2DTextureTarget()
             m_state->getBoundTexture(priorityTarget));
 }
 
+void GLEncoder::s_glGenFramebuffersOES(void* self,
+        GLsizei n, GLuint* framebuffers) {
+    GLEncoder* ctx = (GLEncoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glGenFramebuffersOES_enc(self, n, framebuffers);
+    state->addFramebuffers(n, framebuffers);
+}
+
+void GLEncoder::s_glDeleteFramebuffersOES(void* self,
+        GLsizei n, const GLuint* framebuffers) {
+    GLEncoder* ctx = (GLEncoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glDeleteFramebuffersOES_enc(self, n, framebuffers);
+    state->removeFramebuffers(n, framebuffers);
+}
+
+void GLEncoder::s_glBindFramebufferOES(void* self,
+        GLenum target, GLuint framebuffer) {
+    GLEncoder* ctx = (GLEncoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF((target != GL_FRAMEBUFFER),
+                 GL_INVALID_ENUM);
+
+    state->bindFramebuffer(target, framebuffer);
+
+    ctx->m_glBindFramebufferOES_enc(self, target, framebuffer);
+}
+
+void GLEncoder::s_glFramebufferTexture2DOES(void*self,
+        GLenum target, GLenum attachment,
+        GLenum textarget, GLuint texture, GLint level) {
+    GLEncoder* ctx = (GLEncoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    state->attachTextureObject(target, attachment, texture);
+
+    ctx->m_glFramebufferTexture2DOES_enc(self, target, attachment, textarget, texture, level);
+}
+
+void GLEncoder::s_glFramebufferTexture2DMultisampleIMG(void* self,
+        GLenum target, GLenum attachment,
+        GLenum textarget, GLuint texture, GLint level, GLsizei samples) {
+    GLEncoder* ctx = (GLEncoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    state->attachTextureObject(target, attachment, texture);
+
+    ctx->m_glFramebufferTexture2DMultisampleIMG_enc(self, target, attachment, textarget, texture, level, samples);
+}
+
+void GLEncoder::s_glGetFramebufferAttachmentParameterivOES(void* self,
+        GLenum target, GLenum attachment, GLenum pname, GLint* params)
+{
+    GLEncoder* ctx = (GLEncoder*)self;
+    const GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(state->boundFramebuffer(GL_FRAMEBUFFER) == 0,
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF((pname != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) &&
+                 (!state->attachmentHasObject(GL_FRAMEBUFFER, attachment)),
+                 GL_INVALID_ENUM);
+
+    ctx->m_glGetFramebufferAttachmentParameterivOES_enc(self, target, attachment, pname, params);
+}
+
 GLEncoder::GLEncoder(IOStream *stream, ChecksumCalculator *protocol)
         : gl_encoder_context_t(stream, protocol)
 {
@@ -1009,6 +1081,13 @@ GLEncoder::GLEncoder(IOStream *stream, ChecksumCalculator *protocol)
     OVERRIDE(glTexParameterx);
     OVERRIDE(glTexParameteriv);
     OVERRIDE(glTexParameterxv);
+
+    OVERRIDE(glGenFramebuffersOES);
+    OVERRIDE(glDeleteFramebuffersOES);
+    OVERRIDE(glBindFramebufferOES);
+    OVERRIDE(glFramebufferTexture2DOES);
+    OVERRIDE(glFramebufferTexture2DMultisampleIMG);
+    OVERRIDE(glGetFramebufferAttachmentParameterivOES);
 }
 
 GLEncoder::~GLEncoder()
@@ -1019,7 +1098,7 @@ GLEncoder::~GLEncoder()
 size_t GLEncoder::pixelDataSize(GLsizei width, GLsizei height, GLenum format, GLenum type, int pack)
 {
     assert(m_state != NULL);
-    return m_state->pixelDataSize(width, height, format, type, pack);
+    return m_state->pixelDataSize(width, height, 1, format, type, pack);
 }
 
 void GLEncoder::s_glFinish(void *self)
diff --git a/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.h b/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.h
index f6d4b6a..1518030 100644
--- a/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.h
+++ b/vendor/anbox/android/opengl/system/GLESv1_enc/GLEncoder.h
@@ -30,7 +30,11 @@ public:
     void setClientState(GLClientState *state) {
         m_state = state;
     }
-    void setSharedGroup(GLSharedGroupPtr shared) { m_shared = shared; }
+    void setSharedGroup(GLSharedGroupPtr shared) {
+        m_shared = shared;
+        if (m_state && m_shared.Ptr())
+            m_state->setTextureData(m_shared->getTextureData());
+    }
     void flush() { m_stream->flush(); }
     size_t pixelDataSize(GLsizei width, GLsizei height, GLenum format, GLenum type, int pack);
 
@@ -99,6 +103,13 @@ private:
     glTexParameteriv_client_proc_t m_glTexParameteriv_enc;
     glTexParameterxv_client_proc_t m_glTexParameterxv_enc;
 
+    glGenFramebuffersOES_client_proc_t m_glGenFramebuffersOES_enc;
+    glDeleteFramebuffersOES_client_proc_t m_glDeleteFramebuffersOES_enc;
+    glBindFramebufferOES_client_proc_t m_glBindFramebufferOES_enc;
+    glFramebufferTexture2DOES_client_proc_t m_glFramebufferTexture2DOES_enc;
+    glFramebufferTexture2DMultisampleIMG_client_proc_t m_glFramebufferTexture2DMultisampleIMG_enc;
+    glGetFramebufferAttachmentParameterivOES_client_proc_t m_glGetFramebufferAttachmentParameterivOES_enc;
+
     // statics
     static GLenum s_glGetError(void * self);
     static void s_glGetIntegerv(void *self, GLenum pname, GLint *ptr);
@@ -147,6 +158,13 @@ private:
     static void s_glTexParameteriv(void* self, GLenum target, GLenum pname, const GLint* params);
     static void s_glTexParameterxv(void* self, GLenum target, GLenum pname, const GLfixed* params);
 
+    static void s_glGenFramebuffersOES(void* self, GLsizei n, GLuint* framebuffers);
+    static void s_glDeleteFramebuffersOES(void* self, GLsizei n, const GLuint* framebuffers);
+    static void s_glBindFramebufferOES(void* self, GLenum target, GLuint framebuffer);
+    static void s_glFramebufferTexture2DOES(void* self, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    static void s_glFramebufferTexture2DMultisampleIMG(void* self, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
+    static void s_glGetFramebufferAttachmentParameterivOES(void* self, GLenum target, GLenum attachment, GLenum pname, GLint* params);
+
 public:
     glEGLImageTargetTexture2DOES_client_proc_t m_glEGLImageTargetTexture2DOES_enc;
 
diff --git a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_client_context.h b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_client_context.h
index 8074095..6d46a9b 100644
--- a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_client_context.h
+++ b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_client_context.h
@@ -301,7 +301,7 @@ struct gl_client_context_t {
 	glExtGetProgramBinarySourceQCOM_client_proc_t glExtGetProgramBinarySourceQCOM;
 	glStartTilingQCOM_client_proc_t glStartTilingQCOM;
 	glEndTilingQCOM_client_proc_t glEndTilingQCOM;
-	 virtual ~gl_client_context_t() {}
+	virtual ~gl_client_context_t() {}
 
 	typedef gl_client_context_t *CONTEXT_ACCESSOR_TYPE(void);
 	static void setContextAccessor(CONTEXT_ACCESSOR_TYPE *f);
diff --git a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.cpp b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.cpp
index 6206cce..79df3d7 100644
--- a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.cpp
@@ -2,7 +2,6 @@
 // generated by 'emugen'
 
 
-#include <memory>
 #include <string.h>
 #include "gl_opcodes.h"
 
@@ -274,7 +273,7 @@ void glGetClipPlanef_enc(void *self , GLenum pname, GLfloat* eqn)
 	const unsigned int __size_eqn =  (4 * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_eqn + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -291,9 +290,11 @@ void glGetClipPlanef_enc(void *self , GLenum pname, GLfloat* eqn)
 	stream->readback(eqn, __size_eqn);
 	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetClipPlanef: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -311,7 +312,7 @@ void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -328,9 +329,11 @@ void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFloatv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -348,7 +351,7 @@ void glGetLightfv_enc(void *self , GLenum light, GLenum pname, GLfloat* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -366,9 +369,11 @@ void glGetLightfv_enc(void *self , GLenum light, GLenum pname, GLfloat* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetLightfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -386,7 +391,7 @@ void glGetMaterialfv_enc(void *self , GLenum face, GLenum pname, GLfloat* params
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -404,9 +409,11 @@ void glGetMaterialfv_enc(void *self , GLenum face, GLenum pname, GLfloat* params
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetMaterialfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -424,7 +431,7 @@ void glGetTexEnvfv_enc(void *self , GLenum env, GLenum pname, GLfloat* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -442,9 +449,11 @@ void glGetTexEnvfv_enc(void *self , GLenum env, GLenum pname, GLfloat* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexEnvfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -462,7 +471,7 @@ void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat*
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -480,9 +489,11 @@ void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat*
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexParameterfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2105,7 +2116,7 @@ void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLboolean));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2122,9 +2133,11 @@ void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetBooleanv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2142,7 +2155,7 @@ void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint*
 	const unsigned int __size_params =  (sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2160,9 +2173,11 @@ void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint*
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetBufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2208,7 +2223,7 @@ void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
 	const unsigned int __size_buffers =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffers + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2225,9 +2240,11 @@ void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
 	stream->readback(buffers, __size_buffers);
 	if (useChecksum) checksumCalculator->addBuffer(buffers, __size_buffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenBuffers: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2245,7 +2262,7 @@ void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
 	const unsigned int __size_textures =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_textures + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2262,9 +2279,11 @@ void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
 	stream->readback(textures, __size_textures);
 	if (useChecksum) checksumCalculator->addBuffer(textures, __size_textures);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenTextures: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2298,9 +2317,11 @@ GLenum glGetError_enc(void *self )
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetError: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2319,7 +2340,7 @@ void glGetFixedv_enc(void *self , GLenum pname, GLfixed* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2336,9 +2357,11 @@ void glGetFixedv_enc(void *self , GLenum pname, GLfixed* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFixedv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2356,7 +2379,7 @@ void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2373,9 +2396,11 @@ void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetIntegerv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2393,7 +2418,7 @@ void glGetLightxv_enc(void *self , GLenum light, GLenum pname, GLfixed* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2411,9 +2436,11 @@ void glGetLightxv_enc(void *self , GLenum light, GLenum pname, GLfixed* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetLightxv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2431,7 +2458,7 @@ void glGetMaterialxv_enc(void *self , GLenum face, GLenum pname, GLfixed* params
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2449,9 +2476,11 @@ void glGetMaterialxv_enc(void *self , GLenum face, GLenum pname, GLfixed* params
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetMaterialxv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2469,7 +2498,7 @@ void glGetTexEnviv_enc(void *self , GLenum env, GLenum pname, GLint* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2487,9 +2516,11 @@ void glGetTexEnviv_enc(void *self , GLenum env, GLenum pname, GLint* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexEnviv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2507,7 +2538,7 @@ void glGetTexEnvxv_enc(void *self , GLenum env, GLenum pname, GLfixed* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2525,9 +2556,11 @@ void glGetTexEnvxv_enc(void *self , GLenum env, GLenum pname, GLfixed* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexEnvxv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2545,7 +2578,7 @@ void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* pa
 	const unsigned int __size_params =  (sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2563,9 +2596,11 @@ void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* pa
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexParameteriv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2583,7 +2618,7 @@ void glGetTexParameterxv_enc(void *self , GLenum target, GLenum pname, GLfixed*
 	const unsigned int __size_params =  (sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2601,9 +2636,11 @@ void glGetTexParameterxv_enc(void *self , GLenum target, GLenum pname, GLfixed*
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexParameterxv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2664,9 +2701,11 @@ GLboolean glIsBuffer_enc(void *self , GLuint buffer)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsBuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2702,9 +2741,11 @@ GLboolean glIsEnabled_enc(void *self , GLenum cap)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsEnabled: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2740,9 +2781,11 @@ GLboolean glIsTexture_enc(void *self , GLuint texture)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsTexture: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -3345,7 +3388,7 @@ void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei heig
 	const unsigned int __size_pixels =  glesv1_enc::pixelDataSize(self, width, height, format, type, 1);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -3367,9 +3410,11 @@ void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei heig
 	stream->readback(pixels, __size_pixels);
 	if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glReadPixels: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4456,7 +4501,7 @@ void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
 	const unsigned int __size_formats =  (count * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_formats + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -4473,9 +4518,11 @@ void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
 	stream->readback(formats, __size_formats);
 	if (useChecksum) checksumCalculator->addBuffer(formats, __size_formats);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetCompressedTextureFormats: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4509,9 +4556,11 @@ int glFinishRoundTrip_enc(void *self )
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glFinishRoundTrip: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5158,7 +5207,7 @@ void glGetClipPlanexOES_enc(void *self , GLenum pname, GLfixed* eqn)
 	const unsigned int __size_eqn =  (4 * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_eqn + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5175,9 +5224,11 @@ void glGetClipPlanexOES_enc(void *self , GLenum pname, GLfixed* eqn)
 	stream->readback(eqn, __size_eqn);
 	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetClipPlanexOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5195,7 +5246,7 @@ void glGetClipPlanex_enc(void *self , GLenum pname, GLfixed* eqn)
 	const unsigned int __size_eqn =  (4 * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_eqn + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5212,9 +5263,11 @@ void glGetClipPlanex_enc(void *self , GLenum pname, GLfixed* eqn)
 	stream->readback(eqn, __size_eqn);
 	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetClipPlanex: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5232,7 +5285,7 @@ void glGetFixedvOES_enc(void *self , GLenum pname, GLfixed* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5249,9 +5302,11 @@ void glGetFixedvOES_enc(void *self , GLenum pname, GLfixed* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFixedvOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5269,7 +5324,7 @@ void glGetLightxvOES_enc(void *self , GLenum light, GLenum pname, GLfixed* param
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5287,9 +5342,11 @@ void glGetLightxvOES_enc(void *self , GLenum light, GLenum pname, GLfixed* param
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetLightxvOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5307,7 +5364,7 @@ void glGetMaterialxvOES_enc(void *self , GLenum face, GLenum pname, GLfixed* par
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5325,9 +5382,11 @@ void glGetMaterialxvOES_enc(void *self , GLenum face, GLenum pname, GLfixed* par
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetMaterialxvOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5345,7 +5404,7 @@ void glGetTexEnvxvOES_enc(void *self , GLenum env, GLenum pname, GLfixed* params
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5363,9 +5422,11 @@ void glGetTexEnvxvOES_enc(void *self , GLenum env, GLenum pname, GLfixed* params
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexEnvxvOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -5383,7 +5444,7 @@ void glGetTexParameterxvOES_enc(void *self , GLenum target, GLenum pname, GLfixe
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -5401,9 +5462,11 @@ void glGetTexParameterxvOES_enc(void *self , GLenum target, GLenum pname, GLfixe
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexParameterxvOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6094,9 +6157,11 @@ GLboolean glIsRenderbufferOES_enc(void *self , GLuint renderbuffer)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsRenderbufferOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6169,7 +6234,7 @@ void glGenRenderbuffersOES_enc(void *self , GLsizei n, GLuint* renderbuffers)
 	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_renderbuffers + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -6186,9 +6251,11 @@ void glGenRenderbuffersOES_enc(void *self , GLsizei n, GLuint* renderbuffers)
 	stream->readback(renderbuffers, __size_renderbuffers);
 	if (useChecksum) checksumCalculator->addBuffer(renderbuffers, __size_renderbuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenRenderbuffersOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6234,7 +6301,7 @@ void glGetRenderbufferParameterivOES_enc(void *self , GLenum target, GLenum pnam
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -6252,9 +6319,11 @@ void glGetRenderbufferParameterivOES_enc(void *self , GLenum target, GLenum pnam
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetRenderbufferParameterivOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6289,9 +6358,11 @@ GLboolean glIsFramebufferOES_enc(void *self , GLuint framebuffer)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsFramebufferOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6364,7 +6435,7 @@ void glGenFramebuffersOES_enc(void *self , GLsizei n, GLuint* framebuffers)
 	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_framebuffers + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -6381,9 +6452,11 @@ void glGenFramebuffersOES_enc(void *self , GLsizei n, GLuint* framebuffers)
 	stream->readback(framebuffers, __size_framebuffers);
 	if (useChecksum) checksumCalculator->addBuffer(framebuffers, __size_framebuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenFramebuffersOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6418,9 +6491,11 @@ GLenum glCheckFramebufferStatusOES_enc(void *self , GLenum target)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glCheckFramebufferStatusOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6496,7 +6571,7 @@ void glGetFramebufferAttachmentParameterivOES_enc(void *self , GLenum target, GL
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -6515,9 +6590,11 @@ void glGetFramebufferAttachmentParameterivOES_enc(void *self , GLenum target, GL
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFramebufferAttachmentParameterivOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6577,9 +6654,11 @@ GLboolean glUnmapBufferOES_enc(void *self , GLenum target)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glUnmapBufferOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6648,7 +6727,7 @@ GLbitfield glQueryMatrixxOES_enc(void *self , GLfixed* mantissa, GLint* exponent
 	const unsigned int __size_exponent =  (16 * sizeof(GLfixed));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_mantissa + __size_exponent + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -6671,9 +6750,11 @@ GLbitfield glQueryMatrixxOES_enc(void *self , GLfixed* mantissa, GLint* exponent
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glQueryMatrixxOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -6834,7 +6915,7 @@ void glGetClipPlanefOES_enc(void *self , GLenum pname, GLfloat* eqn)
 	const unsigned int __size_eqn =  (4 * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_eqn + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -6851,9 +6932,11 @@ void glGetClipPlanefOES_enc(void *self , GLenum pname, GLfloat* eqn)
 	stream->readback(eqn, __size_eqn);
 	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetClipPlanefOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7204,7 +7287,7 @@ void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
 	const unsigned int __size_arrays =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_arrays + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7221,9 +7304,11 @@ void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
 	stream->readback(arrays, __size_arrays);
 	if (useChecksum) checksumCalculator->addBuffer(arrays, __size_arrays);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenVertexArraysOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7258,9 +7343,11 @@ GLboolean glIsVertexArrayOES_enc(void *self , GLuint array)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsVertexArrayOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7440,9 +7527,11 @@ GLboolean glIsFenceNV_enc(void *self , GLuint fence)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsFenceNV: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7478,9 +7567,11 @@ GLboolean glTestFenceNV_enc(void *self , GLuint fence)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glTestFenceNV: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7499,7 +7590,7 @@ void glGetFenceivNV_enc(void *self , GLuint fence, GLenum pname, GLint* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7517,9 +7608,11 @@ void glGetFenceivNV_enc(void *self , GLuint fence, GLenum pname, GLint* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFenceivNV: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7589,7 +7682,7 @@ void glGetDriverControlsQCOM_enc(void *self , GLint* num, GLsizei size, GLuint*
 	const unsigned int __size_driverControls =  (size * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_num + 4 + __size_driverControls + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7609,9 +7702,11 @@ void glGetDriverControlsQCOM_enc(void *self , GLint* num, GLsizei size, GLuint*
 	stream->readback(driverControls, __size_driverControls);
 	if (useChecksum) checksumCalculator->addBuffer(driverControls, __size_driverControls);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetDriverControlsQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7630,7 +7725,7 @@ void glGetDriverControlStringQCOM_enc(void *self , GLuint driverControl, GLsizei
 	const unsigned int __size_driverControlString =  (1 * sizeof(GLchar));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_driverControlString + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7651,9 +7746,11 @@ void glGetDriverControlStringQCOM_enc(void *self , GLuint driverControl, GLsizei
 	stream->readback(driverControlString, __size_driverControlString);
 	if (useChecksum) checksumCalculator->addBuffer(driverControlString, __size_driverControlString);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetDriverControlStringQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7722,7 +7819,7 @@ void glExtGetTexturesQCOM_enc(void *self , GLuint* textures, GLint maxTextures,
 	const unsigned int __size_numTextures =  (1 * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_textures + 4 + __size_numTextures + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7742,9 +7839,11 @@ void glExtGetTexturesQCOM_enc(void *self , GLuint* textures, GLint maxTextures,
 	stream->readback(numTextures, __size_numTextures);
 	if (useChecksum) checksumCalculator->addBuffer(numTextures, __size_numTextures);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetTexturesQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7763,7 +7862,7 @@ void glExtGetBuffersQCOM_enc(void *self , GLuint* buffers, GLint maxBuffers, GLi
 	const unsigned int __size_numBuffers =  (1 * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_buffers + 4 + __size_numBuffers + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7783,9 +7882,11 @@ void glExtGetBuffersQCOM_enc(void *self , GLuint* buffers, GLint maxBuffers, GLi
 	stream->readback(numBuffers, __size_numBuffers);
 	if (useChecksum) checksumCalculator->addBuffer(numBuffers, __size_numBuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetBuffersQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7804,7 +7905,7 @@ void glExtGetRenderbuffersQCOM_enc(void *self , GLuint* renderbuffers, GLint max
 	const unsigned int __size_numRenderbuffers =  (1 * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_renderbuffers + 4 + __size_numRenderbuffers + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7824,9 +7925,11 @@ void glExtGetRenderbuffersQCOM_enc(void *self , GLuint* renderbuffers, GLint max
 	stream->readback(numRenderbuffers, __size_numRenderbuffers);
 	if (useChecksum) checksumCalculator->addBuffer(numRenderbuffers, __size_numRenderbuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetRenderbuffersQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7845,7 +7948,7 @@ void glExtGetFramebuffersQCOM_enc(void *self , GLuint* framebuffers, GLint maxFr
 	const unsigned int __size_numFramebuffers =  (1 * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_framebuffers + 4 + __size_numFramebuffers + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7865,9 +7968,11 @@ void glExtGetFramebuffersQCOM_enc(void *self , GLuint* framebuffers, GLint maxFr
 	stream->readback(numFramebuffers, __size_numFramebuffers);
 	if (useChecksum) checksumCalculator->addBuffer(numFramebuffers, __size_numFramebuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetFramebuffersQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7885,7 +7990,7 @@ void glExtGetTexLevelParameterivQCOM_enc(void *self , GLuint texture, GLenum fac
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7905,9 +8010,11 @@ void glExtGetTexLevelParameterivQCOM_enc(void *self , GLuint texture, GLenum fac
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetTexLevelParameterivQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7952,7 +8059,7 @@ void glExtGetTexSubImageQCOM_enc(void *self , GLenum target, GLint level, GLint
 	const unsigned int __size_texels =  (depth * glesv1_enc::pixelDataSize(self, width, height, format, type, 0));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_texels + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -7978,9 +8085,11 @@ void glExtGetTexSubImageQCOM_enc(void *self , GLenum target, GLint level, GLint
 	stream->readback(texels, __size_texels);
 	if (useChecksum) checksumCalculator->addBuffer(texels, __size_texels);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetTexSubImageQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -7999,7 +8108,7 @@ void glExtGetShadersQCOM_enc(void *self , GLuint* shaders, GLint maxShaders, GLi
 	const unsigned int __size_numShaders =  (1 * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_shaders + 4 + __size_numShaders + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -8019,9 +8128,11 @@ void glExtGetShadersQCOM_enc(void *self , GLuint* shaders, GLint maxShaders, GLi
 	stream->readback(numShaders, __size_numShaders);
 	if (useChecksum) checksumCalculator->addBuffer(numShaders, __size_numShaders);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetShadersQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -8040,7 +8151,7 @@ void glExtGetProgramsQCOM_enc(void *self , GLuint* programs, GLint maxPrograms,
 	const unsigned int __size_numPrograms =  (1 * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_programs + 4 + __size_numPrograms + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -8060,9 +8171,11 @@ void glExtGetProgramsQCOM_enc(void *self , GLuint* programs, GLint maxPrograms,
 	stream->readback(numPrograms, __size_numPrograms);
 	if (useChecksum) checksumCalculator->addBuffer(numPrograms, __size_numPrograms);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtGetProgramsQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -8097,9 +8210,11 @@ GLboolean glExtIsProgramBinaryQCOM_enc(void *self , GLuint program)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glExtIsProgramBinaryQCOM: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
diff --git a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.h b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.h
index 37de4c4..030bd66 100644
--- a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.h
+++ b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_enc.h
@@ -18,6 +18,7 @@ struct gl_encoder_context_t : public gl_client_context_t {
 	ChecksumCalculator *m_checksumCalculator;
 
 	gl_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator);
+	virtual uint64_t lockAndWriteDma(void* data, uint32_t sz) { return 0; }
 };
 
-#endif  // GUARD_gl_encoder_context_t
\ No newline at end of file
+#endif  // GUARD_gl_encoder_context_t
diff --git a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_entry.cpp b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_entry.cpp
index 2b7fa9f..0101e9d 100644
--- a/vendor/anbox/android/opengl/system/GLESv1_enc/gl_entry.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv1_enc/gl_entry.cpp
@@ -4,7 +4,6 @@
 #include <stdlib.h>
 #include "gl_client_context.h"
 
-#ifndef GL_TRUE
 extern "C" {
 	void glAlphaFunc(GLenum func, GLclampf ref);
 	void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
@@ -299,7 +298,6 @@ extern "C" {
 	void glEndTilingQCOM(GLbitfield preserveMask);
 };
 
-#endif
 #ifndef GET_CONTEXT
 static gl_client_context_t::CONTEXT_ACCESSOR_TYPE *getCurrentContext = NULL;
 void gl_client_context_t::setContextAccessor(CONTEXT_ACCESSOR_TYPE *f) { getCurrentContext = f; }
diff --git a/vendor/anbox/android/opengl/system/GLESv2/Android.mk b/vendor/anbox/android/opengl/system/GLESv2/Android.mk
index 5a23424..c12f369 100644
--- a/vendor/anbox/android/opengl/system/GLESv2/Android.mk
+++ b/vendor/anbox/android/opengl/system/GLESv2/Android.mk
@@ -7,6 +7,10 @@ $(call emugl-import,libOpenglSystemCommon libGLESv2_enc lib_renderControl_enc)
 LOCAL_CFLAGS += -DLOG_TAG=\"GLESv2_emulation\" -DGL_GLEXT_PROTOTYPES
 
 LOCAL_SRC_FILES := gl2.cpp
-LOCAL_MODULE_RELATIVE_PATH := egl
+ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 21 && echo PreLollipop),PreLollipop)
+    LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/egl
+else
+    LOCAL_MODULE_RELATIVE_PATH := egl
+endif
 
 $(call emugl-end-module)
diff --git a/vendor/anbox/android/opengl/system/GLESv2/gl2.cpp b/vendor/anbox/android/opengl/system/GLESv2/gl2.cpp
index 5aaac5f..b75f899 100644
--- a/vendor/anbox/android/opengl/system/GLESv2/gl2.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv2/gl2.cpp
@@ -57,6 +57,7 @@ void glEGLImageTargetTexture2DOES(void * self, GLenum target, GLeglImageOES img)
     DBG("glEGLImageTargetTexture2DOES v2 target=%#x img=%p\n", target, img);
 
     EGLImage_t *image = (EGLImage_t*)img;
+    GLeglImageOES hostImage = reinterpret_cast<GLeglImageOES>((intptr_t)image->host_egl_image);
 
     if (image->target == EGL_NATIVE_BUFFER_ANDROID) {
         //TODO: check error - we don't have a way to set gl error
@@ -74,15 +75,16 @@ void glEGLImageTargetTexture2DOES(void * self, GLenum target, GLeglImageOES img)
         DEFINE_AND_VALIDATE_HOST_CONNECTION();
 
         ctx->override2DTextureTarget(target);
+        ctx->associateEGLImage(target, hostImage);
         rcEnc->rcBindTexture(rcEnc, ((cb_handle_t *)(native_buffer->handle))->hostHandle);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     }
     else if (image->target == EGL_GL_TEXTURE_2D_KHR) {
         GET_CONTEXT;
         ctx->override2DTextureTarget(target);
-        GLeglImageOES hostImage = reinterpret_cast<GLeglImageOES>((intptr_t)image->host_egl_image);
+        ctx->associateEGLImage(target, hostImage);
         ctx->m_glEGLImageTargetTexture2DOES_enc(self, target, hostImage);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     }
 }
 
@@ -125,6 +127,11 @@ void finish()
     glFinish();
 }
 
+void getIntegerv(unsigned int pname, int* param)
+{
+    glGetIntegerv((GLenum)pname, (GLint*)param);
+}
+
 const GLubyte *my_glGetString (void *self, GLenum name)
 {
     (void)self;
@@ -157,7 +164,6 @@ void init()
     ctx->glEGLImageTargetRenderbufferStorageOES = &glEGLImageTargetRenderbufferStorageOES;
     ctx->glGetString = &my_glGetString;
 }
-
 extern "C" {
 EGLClient_glesInterface * init_emul_gles(EGLClient_eglInterface *eglIface)
 {
@@ -168,10 +174,9 @@ EGLClient_glesInterface * init_emul_gles(EGLClient_eglInterface *eglIface)
         s_gl->getProcAddress = getProcAddress;
         s_gl->finish = finish;
         s_gl->init = init;
+        s_gl->getIntegerv = getIntegerv;
     }
 
     return s_gl;
 }
 } //extern
-
-
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/Android.mk b/vendor/anbox/android/opengl/system/GLESv2_enc/Android.mk
index e76a175..c5081d3 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/Android.mk
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/Android.mk
@@ -6,9 +6,10 @@ $(call emugl-begin-shared-library,libGLESv2_enc)
 LOCAL_SRC_FILES := \
     GL2EncoderUtils.cpp \
     GL2Encoder.cpp \
+    GLESv2Validation.cpp \
     gl2_client_context.cpp \
     gl2_enc.cpp \
-    gl2_entry.cpp
+    gl2_entry.cpp \
 
 LOCAL_CFLAGS += -DLOG_TAG=\"emuglGLESv2_enc\"
 
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.cpp b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.cpp
old mode 100755
new mode 100644
index 268f76c..66b9e19
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.cpp
@@ -15,36 +15,63 @@
 */
 
 #include "GL2Encoder.h"
+#include "GLESv2Validation.h"
+
+#include <string>
+#include <map>
+
 #include <assert.h>
 #include <ctype.h>
-#include <cmath>
+
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#include <GLES2/gl2platform.h>
+
+#include <GLES3/gl3.h>
+#include <GLES3/gl31.h>
 
 #ifndef MIN
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
 
 static GLubyte *gVendorString= (GLubyte *) "Android";
-static GLubyte *gRendererString= (GLubyte *) "Android HW-GLES 2.0";
-static GLubyte *gVersionString= (GLubyte *) "OpenGL ES 2.0";
+static GLubyte *gRendererString= (GLubyte *) "Android HW-GLES 3.0";
+static GLubyte *gVersionString= (GLubyte *) "OpenGL ES 3.0";
 static GLubyte *gExtensionsString= (GLubyte *) "GL_OES_EGL_image_external ";
 
-#define SET_ERROR_IF(condition,err) if((condition)) {                            \
+#define SET_ERROR_IF(condition, err) if((condition)) { \
         ALOGE("%s:%s:%d GL error 0x%x\n", __FILE__, __FUNCTION__, __LINE__, err); \
-        ctx->setError(err);                                    \
-        return;                                                  \
+        ctx->setError(err); \
+        return; \
     }
 
+#define SET_ERROR_WITH_MESSAGE_IF(condition, err, generator, genargs) if ((condition)) { \
+        std::string msg = generator genargs; \
+        ALOGE("%s:%s:%d GL error 0x%x\n" \
+              "Info: %s\n", __FILE__, __FUNCTION__, __LINE__, err, msg.c_str()); \
+        ctx->setError(err); \
+        return; \
+    } \
 
-#define RET_AND_SET_ERROR_IF(condition,err,ret) if((condition)) {                \
+#define RET_AND_SET_ERROR_IF(condition, err, ret) if((condition)) { \
         ALOGE("%s:%s:%d GL error 0x%x\n", __FILE__, __FUNCTION__, __LINE__, err); \
-        ctx->setError(err);                                    \
-        return ret;                                              \
-    }
-
+        ctx->setError(err);  \
+        return ret; \
+    } \
+
+#define RET_AND_SET_ERROR_WITH_MESSAGE_IF(condition, err, ret, generator, genargs) if((condition)) { \
+        std::string msg = generator genargs; \
+        ALOGE("%s:%s:%d GL error 0x%x\n" \
+              "Info: %s\n", __FILE__, __FUNCTION__, __LINE__, err, msg.c_str()); \
+        ctx->setError(err);   \
+        return ret; \
+    } \
 
 GL2Encoder::GL2Encoder(IOStream *stream, ChecksumCalculator *protocol)
         : gl2_encoder_context_t(stream, protocol)
 {
+    m_currMajorVersion = 2;
+    m_currMinorVersion = 0;
     m_initialized = false;
     m_state = NULL;
     m_error = GL_NO_ERROR;
@@ -52,10 +79,25 @@ GL2Encoder::GL2Encoder(IOStream *stream, ChecksumCalculator *protocol)
     m_max_cubeMapTextureSize = 0;
     m_max_renderBufferSize = 0;
     m_max_textureSize = 0;
+    m_max_3d_textureSize = 0;
+    m_max_vertexAttribStride = 0;
     m_compressedTextureFormats = NULL;
 
-    //overrides
+    m_ssbo_offset_align = 0;
+    m_ubo_offset_align = 0;
+
+    m_drawCallFlushCount = 0;
+    m_primitiveRestartEnabled = false;
+    m_primitiveRestartIndex = 0;
+
+    // overrides
 #define OVERRIDE(name)  m_##name##_enc = this-> name ; this-> name = &s_##name
+#define OVERRIDE_CUSTOM(name)  this-> name = &s_##name
+#define OVERRIDEWITH(name, target)  do { \
+    m_##target##_enc = this-> target; \
+    this-> target = &s_##name; \
+} while(0)
+#define OVERRIDEOES(name) OVERRIDEWITH(name, name##OES)
 
     OVERRIDE(glFlush);
     OVERRIDE(glPixelStorei);
@@ -129,6 +171,179 @@ GL2Encoder::GL2Encoder(IOStream *stream, ChecksumCalculator *protocol)
     OVERRIDE(glTexParameteriv);
     OVERRIDE(glTexImage2D);
     OVERRIDE(glTexSubImage2D);
+    OVERRIDE(glCopyTexImage2D);
+
+    OVERRIDE(glGenRenderbuffers);
+    OVERRIDE(glDeleteRenderbuffers);
+    OVERRIDE(glBindRenderbuffer);
+    OVERRIDE(glRenderbufferStorage);
+    OVERRIDE(glFramebufferRenderbuffer);
+
+    OVERRIDE(glGenFramebuffers);
+    OVERRIDE(glDeleteFramebuffers);
+    OVERRIDE(glBindFramebuffer);
+    OVERRIDE(glFramebufferTexture2D);
+    OVERRIDE(glFramebufferTexture3DOES);
+    OVERRIDE(glGetFramebufferAttachmentParameteriv);
+
+    OVERRIDE(glCheckFramebufferStatus);
+
+    OVERRIDE(glGenVertexArrays);
+    OVERRIDE(glDeleteVertexArrays);
+    OVERRIDE(glBindVertexArray);
+    OVERRIDEOES(glGenVertexArrays);
+    OVERRIDEOES(glDeleteVertexArrays);
+    OVERRIDEOES(glBindVertexArray);
+
+    OVERRIDE_CUSTOM(glMapBufferRange);
+    OVERRIDE_CUSTOM(glUnmapBuffer);
+    OVERRIDE_CUSTOM(glFlushMappedBufferRange);
+
+    OVERRIDE(glCompressedTexImage2D);
+    OVERRIDE(glCompressedTexSubImage2D);
+
+    OVERRIDE(glBindBufferRange);
+    OVERRIDE(glBindBufferBase);
+
+    OVERRIDE(glCopyBufferSubData);
+
+    OVERRIDE(glGetBufferParameteriv);
+    OVERRIDE(glGetBufferParameteri64v);
+    OVERRIDE(glGetBufferPointerv);
+
+    OVERRIDE_CUSTOM(glGetUniformIndices);
+
+    OVERRIDE(glUniform1ui);
+    OVERRIDE(glUniform2ui);
+    OVERRIDE(glUniform3ui);
+    OVERRIDE(glUniform4ui);
+    OVERRIDE(glUniform1uiv);
+    OVERRIDE(glUniform2uiv);
+    OVERRIDE(glUniform3uiv);
+    OVERRIDE(glUniform4uiv);
+    OVERRIDE(glUniformMatrix2x3fv);
+    OVERRIDE(glUniformMatrix3x2fv);
+    OVERRIDE(glUniformMatrix2x4fv);
+    OVERRIDE(glUniformMatrix4x2fv);
+    OVERRIDE(glUniformMatrix3x4fv);
+    OVERRIDE(glUniformMatrix4x3fv);
+
+    OVERRIDE(glGetUniformuiv);
+    OVERRIDE(glGetActiveUniformBlockiv);
+
+    OVERRIDE(glGetVertexAttribIiv);
+    OVERRIDE(glGetVertexAttribIuiv);
+
+    OVERRIDE_CUSTOM(glVertexAttribIPointer);
+
+    OVERRIDE(glVertexAttribDivisor);
+
+    OVERRIDE(glRenderbufferStorageMultisample);
+    OVERRIDE(glDrawBuffers);
+    OVERRIDE(glReadBuffer);
+    OVERRIDE(glFramebufferTextureLayer);
+    OVERRIDE(glTexStorage2D);
+
+    OVERRIDE_CUSTOM(glTransformFeedbackVaryings);
+    OVERRIDE(glBeginTransformFeedback);
+    OVERRIDE(glEndTransformFeedback);
+    OVERRIDE(glPauseTransformFeedback);
+    OVERRIDE(glResumeTransformFeedback);
+
+    OVERRIDE(glTexImage3D);
+    OVERRIDE(glTexSubImage3D);
+    OVERRIDE(glTexStorage3D);
+    OVERRIDE(glCompressedTexImage3D);
+    OVERRIDE(glCompressedTexSubImage3D);
+
+    OVERRIDE(glDrawArraysInstanced);
+    OVERRIDE_CUSTOM(glDrawElementsInstanced);
+    OVERRIDE_CUSTOM(glDrawRangeElements);
+
+    OVERRIDE_CUSTOM(glGetStringi);
+    OVERRIDE(glGetProgramBinary);
+    OVERRIDE(glReadPixels);
+
+    OVERRIDE(glEnable);
+    OVERRIDE(glDisable);
+    OVERRIDE(glClearBufferiv);
+    OVERRIDE(glClearBufferuiv);
+    OVERRIDE(glClearBufferfv);
+    OVERRIDE(glBlitFramebuffer);
+    OVERRIDE_CUSTOM(glGetInternalformativ);
+
+    OVERRIDE(glGenerateMipmap);
+
+    OVERRIDE(glBindSampler);
+
+    OVERRIDE_CUSTOM(glFenceSync);
+    OVERRIDE_CUSTOM(glClientWaitSync);
+    OVERRIDE_CUSTOM(glWaitSync);
+    OVERRIDE_CUSTOM(glDeleteSync);
+    OVERRIDE_CUSTOM(glIsSync);
+    OVERRIDE_CUSTOM(glGetSynciv);
+
+    OVERRIDE(glGetIntegeri_v);
+    OVERRIDE(glGetInteger64i_v);
+
+    OVERRIDE(glGetShaderiv);
+
+    OVERRIDE(glActiveShaderProgram);
+    OVERRIDE_CUSTOM(glCreateShaderProgramv);
+    OVERRIDE(glProgramUniform1f);
+    OVERRIDE(glProgramUniform1fv);
+    OVERRIDE(glProgramUniform1i);
+    OVERRIDE(glProgramUniform1iv);
+    OVERRIDE(glProgramUniform1ui);
+    OVERRIDE(glProgramUniform1uiv);
+    OVERRIDE(glProgramUniform2f);
+    OVERRIDE(glProgramUniform2fv);
+    OVERRIDE(glProgramUniform2i);
+    OVERRIDE(glProgramUniform2iv);
+    OVERRIDE(glProgramUniform2ui);
+    OVERRIDE(glProgramUniform2uiv);
+    OVERRIDE(glProgramUniform3f);
+    OVERRIDE(glProgramUniform3fv);
+    OVERRIDE(glProgramUniform3i);
+    OVERRIDE(glProgramUniform3iv);
+    OVERRIDE(glProgramUniform3ui);
+    OVERRIDE(glProgramUniform3uiv);
+    OVERRIDE(glProgramUniform4f);
+    OVERRIDE(glProgramUniform4fv);
+    OVERRIDE(glProgramUniform4i);
+    OVERRIDE(glProgramUniform4iv);
+    OVERRIDE(glProgramUniform4ui);
+    OVERRIDE(glProgramUniform4uiv);
+    OVERRIDE(glProgramUniformMatrix2fv);
+    OVERRIDE(glProgramUniformMatrix2x3fv);
+    OVERRIDE(glProgramUniformMatrix2x4fv);
+    OVERRIDE(glProgramUniformMatrix3fv);
+    OVERRIDE(glProgramUniformMatrix3x2fv);
+    OVERRIDE(glProgramUniformMatrix3x4fv);
+    OVERRIDE(glProgramUniformMatrix4fv);
+    OVERRIDE(glProgramUniformMatrix4x2fv);
+    OVERRIDE(glProgramUniformMatrix4x3fv);
+
+    OVERRIDE(glProgramParameteri);
+    OVERRIDE(glUseProgramStages);
+    OVERRIDE(glBindProgramPipeline);
+
+    OVERRIDE(glGetProgramResourceiv);
+    OVERRIDE(glGetProgramResourceIndex);
+    OVERRIDE(glGetProgramResourceLocation);
+    OVERRIDE(glGetProgramResourceName);
+    OVERRIDE(glGetProgramPipelineInfoLog);
+
+    OVERRIDE(glVertexAttribFormat);
+    OVERRIDE(glVertexAttribIFormat);
+    OVERRIDE(glVertexBindingDivisor);
+    OVERRIDE(glVertexAttribBinding);
+    OVERRIDE(glBindVertexBuffer);
+
+    OVERRIDE_CUSTOM(glDrawArraysIndirect);
+    OVERRIDE_CUSTOM(glDrawElementsIndirect);
+
+    OVERRIDE(glTexStorage2DMultisample);
 }
 
 GL2Encoder::~GL2Encoder()
@@ -158,9 +373,16 @@ void GL2Encoder::s_glFlush(void *self)
 
 const GLubyte *GL2Encoder::s_glGetString(void *self, GLenum name)
 {
-    (void)self;
+    GL2Encoder *ctx = (GL2Encoder *)self;
 
     GLubyte *retval =  (GLubyte *) "";
+    RET_AND_SET_ERROR_IF(
+        name != GL_VENDOR &&
+        name != GL_RENDERER &&
+        name != GL_VERSION &&
+        name != GL_EXTENSIONS,
+        GL_INVALID_ENUM,
+        retval);
     switch(name) {
     case GL_VENDOR:
         retval = gVendorString;
@@ -181,17 +403,18 @@ const GLubyte *GL2Encoder::s_glGetString(void *self, GLenum name)
 void GL2Encoder::s_glPixelStorei(void *self, GLenum param, GLint value)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
+    SET_ERROR_IF(!GLESv2Validation::pixelStoreParam(ctx, param), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelStoreValue(param, value), GL_INVALID_VALUE);
     ctx->m_glPixelStorei_enc(ctx, param, value);
     assert(ctx->m_state != NULL);
     ctx->m_state->setPixelStore(param, value);
 }
-
-
 void GL2Encoder::s_glBindBuffer(void *self, GLenum target, GLuint id)
 {
     GL2Encoder *ctx = (GL2Encoder *) self;
     assert(ctx->m_state != NULL);
     ctx->m_state->bindBuffer(target, id);
+    ctx->m_state->addBuffer(id);
     // TODO set error state if needed;
     ctx->m_glBindBuffer_enc(self, target, id);
 }
@@ -199,21 +422,23 @@ void GL2Encoder::s_glBindBuffer(void *self, GLenum target, GLuint id)
 void GL2Encoder::s_glBufferData(void * self, GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage)
 {
     GL2Encoder *ctx = (GL2Encoder *) self;
-    SET_ERROR_IF(!(target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
     GLuint bufferId = ctx->m_state->getBuffer(target);
     SET_ERROR_IF(bufferId==0, GL_INVALID_OPERATION);
     SET_ERROR_IF(size<0, GL_INVALID_VALUE);
 
     ctx->m_shared->updateBufferData(bufferId, size, (void*)data);
+    ctx->m_shared->setBufferUsage(bufferId, usage);
     ctx->m_glBufferData_enc(self, target, size, data, usage);
 }
 
 void GL2Encoder::s_glBufferSubData(void * self, GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data)
 {
     GL2Encoder *ctx = (GL2Encoder *) self;
-    SET_ERROR_IF(!(target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
     GLuint bufferId = ctx->m_state->getBuffer(target);
     SET_ERROR_IF(bufferId==0, GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->isBufferTargetMapped(target), GL_INVALID_OPERATION);
 
     GLenum res = ctx->m_shared->subUpdateBufferData(bufferId, offset, size, (void*)data);
     SET_ERROR_IF(res, res);
@@ -221,22 +446,78 @@ void GL2Encoder::s_glBufferSubData(void * self, GLenum target, GLintptr offset,
     ctx->m_glBufferSubData_enc(self, target, offset, size, data);
 }
 
+void GL2Encoder::s_glGenBuffers(void* self, GLsizei n, GLuint* buffers) {
+    GL2Encoder *ctx = (GL2Encoder *) self;
+    SET_ERROR_IF(n<0, GL_INVALID_VALUE);
+    ctx->m_glGenBuffers_enc(self, n, buffers);
+    for (int i = 0; i < n; i++) {
+        ctx->m_state->addBuffer(buffers[i]);
+    }
+}
+
 void GL2Encoder::s_glDeleteBuffers(void * self, GLsizei n, const GLuint * buffers)
 {
     GL2Encoder *ctx = (GL2Encoder *) self;
     SET_ERROR_IF(n<0, GL_INVALID_VALUE);
     for (int i=0; i<n; i++) {
+        // Technically if the buffer is mapped, we should unmap it, but we won't
+        // use it anymore after this :)
         ctx->m_shared->deleteBufferData(buffers[i]);
         ctx->m_state->unBindBuffer(buffers[i]);
+        ctx->m_state->removeBuffer(buffers[i]);
         ctx->m_glDeleteBuffers_enc(self,1,&buffers[i]);
     }
 }
 
+static bool isValidVertexAttribIndex(void *self, GLuint indx)
+{
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLint maxIndex;
+    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
+    return indx < maxIndex;
+}
+
+#define VALIDATE_VERTEX_ATTRIB_INDEX(index) \
+    SET_ERROR_WITH_MESSAGE_IF( \
+            !isValidVertexAttribIndex(self, index), GL_INVALID_VALUE, \
+            GLESv2Validation::vertexAttribIndexRangeErrorMsg, (ctx, index)); \
+
 void GL2Encoder::s_glVertexAttribPointer(void *self, GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * ptr)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
     assert(ctx->m_state != NULL);
-    ctx->m_state->setState(indx, size, type, normalized, stride, ptr);
+    VALIDATE_VERTEX_ATTRIB_INDEX(indx);
+    SET_ERROR_IF((size < 1 || size > 4), GL_INVALID_VALUE);
+    SET_ERROR_IF(!GLESv2Validation::vertexAttribType(ctx, type), GL_INVALID_ENUM);
+    SET_ERROR_IF(stride < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF((type == GL_INT_2_10_10_10_REV ||
+                  type == GL_UNSIGNED_INT_2_10_10_10_REV) &&
+                 size != 4,
+                 GL_INVALID_OPERATION);
+    ctx->m_state->setVertexAttribBinding(indx, indx);
+    ctx->m_state->setVertexAttribFormat(indx, size, type, normalized, 0, false);
+
+    GLsizei effectiveStride = stride;
+    if (stride == 0) {
+        effectiveStride = glSizeof(type) * size; 
+        switch (type) {
+            case GL_INT_2_10_10_10_REV:
+            case GL_UNSIGNED_INT_2_10_10_10_REV:
+                effectiveStride /= 4;
+                break;
+            default:
+                break;
+        }
+    }
+
+    ctx->m_state->bindIndexedBuffer(0, indx, ctx->m_state->currentArrayVbo(), (uintptr_t)ptr, 0, stride, effectiveStride);
+
+    if (ctx->m_state->currentArrayVbo() != 0) {
+        ctx->glVertexAttribPointerOffset(ctx, indx, size, type, normalized, stride, (uintptr_t)ptr);
+    } else {
+        SET_ERROR_IF(ctx->m_state->currentVertexArrayObject() != 0 && ptr, GL_INVALID_OPERATION);
+        // wait for client-array handler
+    }
 }
 
 void GL2Encoder::s_glGetIntegerv(void *self, GLenum param, GLint *ptr)
@@ -246,6 +527,12 @@ void GL2Encoder::s_glGetIntegerv(void *self, GLenum param, GLint *ptr)
     GLClientState* state = ctx->m_state;
 
     switch (param) {
+    case GL_MAJOR_VERSION:
+        *ptr = ctx->m_deviceMajorVersion;
+        break;
+    case GL_MINOR_VERSION:
+        *ptr = ctx->m_deviceMinorVersion;
+        break;
     case GL_NUM_SHADER_BINARY_FORMATS:
         *ptr = 0;
         break;
@@ -277,6 +564,20 @@ void GL2Encoder::s_glGetIntegerv(void *self, GLenum param, GLint *ptr)
         *ptr = state->getBoundTexture(GL_TEXTURE_EXTERNAL_OES);
         break;
 
+    case GL_MAX_VERTEX_ATTRIBS:
+        if (!ctx->m_state->getClientStateParameter<GLint>(param, ptr)) {
+            ctx->m_glGetIntegerv_enc(self, param, ptr);
+            ctx->m_state->setMaxVertexAttribs(*ptr);
+        }
+        break;
+    case GL_MAX_VERTEX_ATTRIB_STRIDE:
+        if (ctx->m_max_vertexAttribStride != 0) {
+            *ptr = ctx->m_max_vertexAttribStride;
+        } else {
+            ctx->m_glGetIntegerv_enc(self, param, ptr);
+            ctx->m_max_vertexAttribStride = *ptr;
+        }
+        break;
     case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
         if (ctx->m_max_cubeMapTextureSize != 0) {
             *ptr = ctx->m_max_cubeMapTextureSize;
@@ -301,12 +602,38 @@ void GL2Encoder::s_glGetIntegerv(void *self, GLenum param, GLint *ptr)
             ctx->m_max_textureSize = *ptr;
         }
         break;
-    case GL_MAX_VERTEX_ATTRIBS:
-        if (!ctx->m_state->getClientStateParameter<GLint>(param, ptr)) {
+    case GL_MAX_3D_TEXTURE_SIZE:
+        if (ctx->m_max_3d_textureSize != 0) {
+            *ptr = ctx->m_max_3d_textureSize;
+        } else {
             ctx->m_glGetIntegerv_enc(self, param, ptr);
-            ctx->m_state->setMaxVertexAttribs(*ptr);
+            ctx->m_max_3d_textureSize = *ptr;
+        }
+        break;
+    case GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:
+        if (ctx->m_ssbo_offset_align != 0) {
+            *ptr = ctx->m_ssbo_offset_align;
+        } else {
+            ctx->m_glGetIntegerv_enc(self, param, ptr);
+            ctx->m_ssbo_offset_align = *ptr;
+        }
+        break;
+    case GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT:
+        if (ctx->m_ubo_offset_align != 0) {
+            *ptr = ctx->m_ubo_offset_align;
+        } else {
+            ctx->m_glGetIntegerv_enc(self, param, ptr);
+            ctx->m_ubo_offset_align = *ptr;
         }
         break;
+    // Desktop OpenGL can allow a mindboggling # samples per pixel (such as 64).
+    // Limit to 4 (spec minimum) to keep dEQP tests from timing out.
+    case GL_MAX_SAMPLES:
+    case GL_MAX_COLOR_TEXTURE_SAMPLES:
+    case GL_MAX_INTEGER_SAMPLES:
+    case GL_MAX_DEPTH_TEXTURE_SAMPLES:
+        *ptr = 4;
+        break;
     default:
         if (!ctx->m_state->getClientStateParameter<GLint>(param, ptr)) {
             ctx->m_glGetIntegerv_enc(self, param, ptr);
@@ -411,9 +738,8 @@ void GL2Encoder::s_glEnableVertexAttribArray(void *self, GLuint index)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
     assert(ctx->m_state);
-    GLint maxIndex;
-    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
-    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
+    VALIDATE_VERTEX_ATTRIB_INDEX(index);
+    ctx->m_glEnableVertexAttribArray_enc(ctx, index);
     ctx->m_state->enable(index, 1);
 }
 
@@ -421,9 +747,8 @@ void GL2Encoder::s_glDisableVertexAttribArray(void *self, GLuint index)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
     assert(ctx->m_state);
-    GLint maxIndex;
-    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
-    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
+    VALIDATE_VERTEX_ATTRIB_INDEX(index);
+    ctx->m_glDisableVertexAttribArray_enc(ctx, index);
     ctx->m_state->enable(index, 0);
 }
 
@@ -462,57 +787,250 @@ void GL2Encoder::s_glGetVertexAttribPointerv(void *self, GLuint index, GLenum pn
     ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
     SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
     SET_ERROR_IF(pname != GL_VERTEX_ATTRIB_ARRAY_POINTER, GL_INVALID_ENUM);
-
     (void)pname;
 
-    const GLClientState::VertexAttribState *va_state = ctx->m_state->getState(index);
-    if (va_state != NULL) {
-        *pointer = va_state->data;
+    *pointer = (GLvoid*)(ctx->m_state->getCurrAttributeBindingInfo(index).offset);
+}
+
+void GL2Encoder::calcIndexRange(const void* indices,
+                                GLenum type,
+                                GLsizei count,
+                                int* minIndex_out,
+                                int* maxIndex_out) {
+    switch(type) {
+    case GL_BYTE:
+    case GL_UNSIGNED_BYTE:
+        GLUtils::minmaxExcept(
+                (unsigned char *)indices, count,
+                minIndex_out, maxIndex_out,
+                m_primitiveRestartEnabled, GLUtils::primitiveRestartIndex<unsigned char>());
+        break;
+    case GL_SHORT:
+    case GL_UNSIGNED_SHORT:
+        GLUtils::minmaxExcept(
+                (unsigned short *)indices, count,
+                minIndex_out, maxIndex_out,
+                m_primitiveRestartEnabled, GLUtils::primitiveRestartIndex<unsigned short>());
+        break;
+    case GL_INT:
+    case GL_UNSIGNED_INT:
+        GLUtils::minmaxExcept(
+                (unsigned int *)indices, count,
+                minIndex_out, maxIndex_out,
+                m_primitiveRestartEnabled, GLUtils::primitiveRestartIndex<unsigned int>());
+        break;
+    default:
+        ALOGE("unsupported index buffer type %d\n", type);
+    }
+}
+
+void* GL2Encoder::recenterIndices(const void* src,
+                                  GLenum type,
+                                  GLsizei count,
+                                  int minIndex) {
+
+    void* adjustedIndices = (void*)src;
+
+    if (minIndex != 0) {
+        adjustedIndices = m_fixedBuffer.alloc(glSizeof(type) * count);
+        switch(type) {
+        case GL_BYTE:
+        case GL_UNSIGNED_BYTE:
+            GLUtils::shiftIndicesExcept(
+                    (unsigned char *)src,
+                    (unsigned char *)adjustedIndices,
+                    count, -minIndex,
+                    m_primitiveRestartEnabled,
+                    (unsigned char)m_primitiveRestartIndex);
+            break;
+        case GL_SHORT:
+        case GL_UNSIGNED_SHORT:
+            GLUtils::shiftIndicesExcept(
+                    (unsigned short *)src,
+                    (unsigned short *)adjustedIndices,
+                    count, -minIndex,
+                    m_primitiveRestartEnabled,
+                    (unsigned short)m_primitiveRestartIndex);
+            break;
+        case GL_INT:
+        case GL_UNSIGNED_INT:
+            GLUtils::shiftIndicesExcept(
+                    (unsigned int *)src,
+                    (unsigned int *)adjustedIndices,
+                    count, -minIndex,
+                    m_primitiveRestartEnabled,
+                    (unsigned int)m_primitiveRestartIndex);
+            break;
+        default:
+            ALOGE("unsupported index buffer type %d\n", type);
+        }
+    }
+
+    return adjustedIndices;
+}
+
+void GL2Encoder::getBufferIndexRange(BufferData* buf,
+                                     const void* dataWithOffset,
+                                     GLenum type,
+                                     size_t count,
+                                     size_t offset,
+                                     int* minIndex_out,
+                                     int* maxIndex_out) {
+
+    if (buf->m_indexRangeCache.findRange(
+                type, offset, count,
+                m_primitiveRestartEnabled,
+                minIndex_out,
+                maxIndex_out)) {
+        return;
     }
+
+    calcIndexRange(dataWithOffset, type, count, minIndex_out, maxIndex_out);
+
+    buf->m_indexRangeCache.addRange(
+            type, offset, count, m_primitiveRestartEnabled,
+            *minIndex_out, *maxIndex_out);
+
+    ALOGV("%s: got range [%u %u] pr? %d", __FUNCTION__, *minIndex_out, *maxIndex_out, m_primitiveRestartEnabled);
 }
 
+// For detecting legacy usage of glVertexAttribPointer
+void GL2Encoder::getVBOUsage(bool* hasClientArrays, bool* hasVBOs) const {
+    if (hasClientArrays) *hasClientArrays = false;
+    if (hasVBOs) *hasVBOs = false;
+
+    for (int i = 0; i < m_state->nLocations(); i++) {
+        const GLClientState::VertexAttribState& state = m_state->getState(i);
+        if (state.enabled) {
+            const GLClientState::BufferBinding& curr_binding = m_state->getCurrAttributeBindingInfo(i);
+            GLuint bufferObject = curr_binding.buffer;
+            if (bufferObject == 0 && curr_binding.offset && hasClientArrays) {
+                *hasClientArrays = true;
+            }
+            if (bufferObject != 0 && hasVBOs) {
+                *hasVBOs = true;
+            }
+        }
+    }
+}
 
-void GL2Encoder::sendVertexAttributes(GLint first, GLsizei count)
+void GL2Encoder::sendVertexAttributes(GLint first, GLsizei count, bool hasClientArrays, GLsizei primcount)
 {
     assert(m_state);
 
+    GLuint currentVao = m_state->currentVertexArrayObject();
+    GLuint lastBoundVbo = m_state->currentArrayVbo();
     for (int i = 0; i < m_state->nLocations(); i++) {
         bool enableDirty;
-        const GLClientState::VertexAttribState *state = m_state->getStateAndEnableDirty(i, &enableDirty);
+        const GLClientState::VertexAttribState& state = m_state->getStateAndEnableDirty(i, &enableDirty);
 
-        if (!state) {
+        if (!enableDirty && !state.enabled) {
             continue;
         }
 
-        if (!enableDirty && !state->enabled) {
-            continue;
-        }
-
-
-        if (state->enabled) {
-            m_glEnableVertexAttribArray_enc(this, i);
+        if (state.enabled) {
+            const GLClientState::BufferBinding& curr_binding = m_state->getCurrAttributeBindingInfo(i);
+            GLuint bufferObject = curr_binding.buffer;
+            if (hasClientArrays && lastBoundVbo != bufferObject) {
+                this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, bufferObject);
+                lastBoundVbo = bufferObject;
+            }
 
-            unsigned int datalen = state->elementSize * count;
-            int stride = state->stride == 0 ? state->elementSize : state->stride;
-            int firstIndex = stride * first;
+            int divisor = curr_binding.divisor;
+            int stride = curr_binding.stride;
+            int effectiveStride = curr_binding.effectiveStride;
+            uintptr_t offset = curr_binding.offset;
+
+            int firstIndex = effectiveStride * first;
+            if (firstIndex && divisor && !primcount) {
+                // If firstIndex != 0 according to effectiveStride * first,
+                // it needs to be adjusted if a divisor has been specified,
+                // even if we are not in glDraw***Instanced.
+                firstIndex = 0;
+            }
 
-            this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, state->bufferObject);
-            if (state->bufferObject == 0) {
-                this->glVertexAttribPointerData(this, i, state->size, state->type, state->normalized, state->stride,
-                                                (unsigned char *)state->data + firstIndex, datalen);
+            if (bufferObject == 0) {
+                unsigned int datalen = state.elementSize * count;
+                if (divisor && primcount) {
+                    ALOGV("%s: divisor for att %d: %d, w/ stride %d (effective stride %d) size %d type 0x%x) datalen %u",
+                            __FUNCTION__, i, divisor, state.stride, effectiveStride, state.elementSize, state.type, datalen);
+                    int actual_count = std::max(1, (int)((primcount + divisor - 1) / divisor));
+                    datalen = state.elementSize * actual_count;
+                    ALOGV("%s: actual datalen %u", __FUNCTION__, datalen);
+                }
+                if (state.elementSize == 0) {
+                    // The vertex attribute array is uninitialized. Abandon it.
+                    ALOGE("a vertex attribute array is uninitialized. Skipping corresponding vertex attribute.");
+                    this->m_glDisableVertexAttribArray_enc(this, i);
+                    continue;
+                }
+                m_glEnableVertexAttribArray_enc(this, i);
+
+                if (datalen && (!offset || !((unsigned char*)offset + firstIndex))) {
+                    ALOGD("%s: bad offset / len!!!!!", __FUNCTION__);
+                    continue;
+                }
+                if (state.isInt) {
+                    this->glVertexAttribIPointerDataAEMU(this, i, state.size, state.type, stride, (unsigned char *)offset + firstIndex, datalen);
+                } else {
+                    this->glVertexAttribPointerData(this, i, state.size, state.type, state.normalized, stride, (unsigned char *)offset + firstIndex, datalen);
+                }
             } else {
-                this->glVertexAttribPointerOffset(this, i, state->size, state->type, state->normalized, state->stride,
-                                                  (uintptr_t) state->data + firstIndex);
+                const BufferData* buf = m_shared->getBufferData(bufferObject);
+                // The following expression actually means bufLen = stride*count;
+                // But the last element doesn't have to fill up the whole stride.
+                // So it becomes the current form.
+                unsigned int bufLen = effectiveStride * (count ? (count - 1) : 0) + state.elementSize;
+                if (divisor && primcount) {
+                    int actual_count = std::max(1, (int)((primcount + divisor - 1) / divisor));
+                    bufLen = effectiveStride * (actual_count ? (actual_count - 1) : 0) + state.elementSize;
+                }
+                if (buf && firstIndex >= 0 && firstIndex + bufLen <= buf->m_size) {
+                    if (hasClientArrays) {
+                        m_glEnableVertexAttribArray_enc(this, i);
+                        if (state.isInt) {
+                            this->glVertexAttribIPointerOffsetAEMU(this, i, state.size, state.type, stride, offset + firstIndex);
+                        } else {
+                            this->glVertexAttribPointerOffset(this, i, state.size, state.type, state.normalized, stride, offset + firstIndex);
+                        }
+                    }
+                } else {
+                    ALOGE("a vertex attribute index out of boundary is detected. Skipping corresponding vertex attribute. buf=%p", buf);
+                    if (buf) {
+                        ALOGE("Out of bounds vertex attribute info: "
+                                "clientArray? %d attribute %d vbo %u allocedBufferSize %u bufferDataSpecified? %d wantedStart %u wantedEnd %u",
+                                hasClientArrays, i, bufferObject, buf->m_size, buf != NULL, firstIndex, firstIndex + bufLen);
+                    }
+                    m_glDisableVertexAttribArray_enc(this, i);
+                }
             }
-            this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, m_state->currentArrayVbo());
         } else {
-            this->m_glDisableVertexAttribArray_enc(this, i);
+            if (hasClientArrays) {
+                this->m_glDisableVertexAttribArray_enc(this, i);
+            }
         }
     }
+
+    if (hasClientArrays && lastBoundVbo != m_state->currentArrayVbo()) {
+        this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, m_state->currentArrayVbo());
+    }
+}
+
+void GL2Encoder::flushDrawCall() {
+    // This used to be every other draw call, but
+    // now that we are using real GPU buffers on host,
+    // set this to every 200 draw calls
+    // (tuned on z840 linux NVIDIA Quadro K2200)
+    if (m_drawCallFlushCount % 200 == 0) {
+        m_stream->flush();
+    }
+    m_drawCallFlushCount++;
 }
 
-static bool isValidDrawMode(GLenum mode) {
-    switch(mode) {
+static bool isValidDrawMode(GLenum mode)
+{
+    bool retval = false;
+    switch (mode) {
     case GL_POINTS:
     case GL_LINE_STRIP:
     case GL_LINE_LOOP:
@@ -520,133 +1038,111 @@ static bool isValidDrawMode(GLenum mode) {
     case GL_TRIANGLE_STRIP:
     case GL_TRIANGLE_FAN:
     case GL_TRIANGLES:
-        return true;
+        retval = true;
     }
-    return false;
-}
-
-static bool isValidDrawType(GLenum mode) {
-    return  mode == GL_UNSIGNED_BYTE ||
-            mode == GL_UNSIGNED_SHORT ||
-            mode == GL_UNSIGNED_INT;
+    return retval;
 }
 
 void GL2Encoder::s_glDrawArrays(void *self, GLenum mode, GLint first, GLsizei count)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
-
+    assert(ctx->m_state != NULL);
     SET_ERROR_IF(!isValidDrawMode(mode), GL_INVALID_ENUM);
-    SET_ERROR_IF(count<0, GL_INVALID_VALUE);
+    SET_ERROR_IF(count < 0, GL_INVALID_VALUE);
 
-    bool has_arrays = false;
-    int nLocations = ctx->m_state->nLocations();
-    for (int i = 0; i < nLocations; i++) {
-        const GLClientState::VertexAttribState *state = ctx->m_state->getState(i);
-        if (state->enabled) {
-            if (state->bufferObject || state->data)  {
-                has_arrays = true;
-            }
-            else {
-                ALOGE("glDrawArrays: a vertex attribute array is enabled with no data bound\n");
-                ctx->setError(GL_INVALID_OPERATION);
-                return;
-            }
-        }
-    }
-    if (!has_arrays) {
-        ALOGE("glDrawArrays: no data bound to the command - ignoring\n");
-        return;
+    bool has_client_vertex_arrays = false;
+    bool has_indirect_arrays = false;
+    ctx->getVBOUsage(&has_client_vertex_arrays,
+                     &has_indirect_arrays);
+
+    if (has_client_vertex_arrays ||
+        (!has_client_vertex_arrays &&
+         !has_indirect_arrays)) {
+        ctx->sendVertexAttributes(first, count, true);
+        ctx->m_glDrawArrays_enc(ctx, mode, 0, count);
+    } else {
+        ctx->sendVertexAttributes(0, count, false);
+        ctx->m_glDrawArrays_enc(ctx, mode, first, count);
     }
-
-    ctx->sendVertexAttributes(first, count);
-    ctx->m_glDrawArrays_enc(ctx, mode, 0, count);
 }
 
+
 void GL2Encoder::s_glDrawElements(void *self, GLenum mode, GLsizei count, GLenum type, const void *indices)
 {
 
     GL2Encoder *ctx = (GL2Encoder *)self;
     assert(ctx->m_state != NULL);
-    SET_ERROR_IF(!(isValidDrawMode(mode) && isValidDrawType(type)),GL_INVALID_ENUM);
-    SET_ERROR_IF(count<0, GL_INVALID_VALUE);
+    SET_ERROR_IF(!isValidDrawMode(mode), GL_INVALID_ENUM);
+    SET_ERROR_IF(count < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(!(type == GL_UNSIGNED_BYTE || type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT), GL_INVALID_ENUM);
+    SET_ERROR_IF(ctx->m_state->getTransformFeedbackActiveUnpaused(), GL_INVALID_OPERATION);
 
-    bool has_immediate_arrays = false;
+    bool has_client_vertex_arrays = false;
     bool has_indirect_arrays = false;
     int nLocations = ctx->m_state->nLocations();
+    GLintptr offset = 0;
 
-    for (int i = 0; i < nLocations; i++) {
-        const GLClientState::VertexAttribState *state = ctx->m_state->getState(i);
-        if (state->enabled) {
-            if (state->bufferObject != 0) {
-                has_indirect_arrays = true;
-            } else if (state->data) {
-                has_immediate_arrays = true;
-            } else {
-                ALOGW("glDrawElements: a vertex attribute array is enabled with no data bound\n");
-                ctx->setError(GL_INVALID_OPERATION);
-                return;
-            }
-        }
+    ctx->getVBOUsage(&has_client_vertex_arrays, &has_indirect_arrays);
+
+    if (!has_client_vertex_arrays && !has_indirect_arrays) {
+        // ALOGW("glDrawElements: no vertex arrays / buffers bound to the command\n");
+        GLenum status = ctx->m_glCheckFramebufferStatus_enc(self, GL_FRAMEBUFFER);
+        SET_ERROR_IF(status != GL_FRAMEBUFFER_COMPLETE, GL_INVALID_FRAMEBUFFER_OPERATION);
     }
 
-    if (!has_immediate_arrays && !has_indirect_arrays) {
-        ALOGE("glDrawElements: no data bound to the command - ignoring\n");
-        return;
+    BufferData* buf = NULL;
+    int minIndex = 0, maxIndex = 0;
+
+    // For validation/immediate index array purposes,
+    // we need the min/max vertex index of the index array.
+    // If the VBO != 0, this may not be the first time we have
+    // used this particular index buffer. getBufferIndexRange
+    // can more quickly get min/max vertex index by
+    // caching previous results.
+    if (ctx->m_state->currentIndexVbo() != 0) {
+        buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
+        offset = (GLintptr)indices;
+        indices = (void*)((GLintptr)buf->m_fixedBuffer.ptr() + (GLintptr)indices);
+        ctx->getBufferIndexRange(buf,
+                                 indices,
+                                 type,
+                                 (size_t)count,
+                                 (size_t)offset,
+                                 &minIndex, &maxIndex);
+    } else {
+        // In this case, the |indices| field holds a real
+        // array, so calculate the indices now. They will
+        // also be needed to know how much data to
+        // transfer to host.
+        ctx->calcIndexRange(indices,
+                            type,
+                            count,
+                            &minIndex,
+                            &maxIndex);
     }
 
     bool adjustIndices = true;
     if (ctx->m_state->currentIndexVbo() != 0) {
-        if (!has_immediate_arrays) {
-            ctx->sendVertexAttributes(0, count);
+        if (!has_client_vertex_arrays) {
+            ctx->sendVertexAttributes(0, maxIndex + 1, false);
             ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, ctx->m_state->currentIndexVbo());
-            ctx->glDrawElementsOffset(ctx, mode, count, type, (uintptr_t)indices);
+            ctx->glDrawElementsOffset(ctx, mode, count, type, offset);
+            ctx->flushDrawCall();
             adjustIndices = false;
         } else {
             BufferData * buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
             ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, 0);
-            indices = (void*)((GLintptr)buf->m_fixedBuffer.ptr() + (GLintptr)indices);
         }
     }
     if (adjustIndices) {
-        void *adjustedIndices = (void*)indices;
-        int minIndex = 0, maxIndex = 0;
+        void *adjustedIndices =
+            ctx->recenterIndices(indices,
+                                 type,
+                                 count,
+                                 minIndex);
 
-        switch(type) {
-        case GL_BYTE:
-        case GL_UNSIGNED_BYTE:
-            GLUtils::minmax<unsigned char>((unsigned char *)indices, count, &minIndex, &maxIndex);
-            if (minIndex != 0) {
-                adjustedIndices =  ctx->m_fixedBuffer.alloc(glSizeof(type) * count);
-                GLUtils::shiftIndices<unsigned char>((unsigned char *)indices,
-                                                 (unsigned char *)adjustedIndices,
-                                                 count, -minIndex);
-            }
-            break;
-        case GL_SHORT:
-        case GL_UNSIGNED_SHORT:
-            GLUtils::minmax<unsigned short>((unsigned short *)indices, count, &minIndex, &maxIndex);
-            if (minIndex != 0) {
-                adjustedIndices = ctx->m_fixedBuffer.alloc(glSizeof(type) * count);
-                GLUtils::shiftIndices<unsigned short>((unsigned short *)indices,
-                                                  (unsigned short *)adjustedIndices,
-                                                  count, -minIndex);
-            }
-            break;
-        case GL_INT:
-        case GL_UNSIGNED_INT:
-            GLUtils::minmax<unsigned int>((unsigned int *)indices, count, &minIndex, &maxIndex);
-            if (minIndex != 0) {
-                adjustedIndices = ctx->m_fixedBuffer.alloc(glSizeof(type) * count);
-                GLUtils::shiftIndices<unsigned int>((unsigned int *)indices,
-                                                 (unsigned int *)adjustedIndices,
-                                                 count, -minIndex);
-            }
-            break;
-        default:
-            ALOGE("unsupported index buffer type %d\n", type);
-        }
         if (has_indirect_arrays || 1) {
-            ctx->sendVertexAttributes(minIndex, maxIndex - minIndex + 1);
+            ctx->sendVertexAttributes(minIndex, maxIndex - minIndex + 1, true);
             ctx->glDrawElementsData(ctx, mode, count, type, adjustedIndices,
                                     count * glSizeof(type));
             // XXX - OPTIMIZATION (see the other else branch) should be implemented
@@ -774,10 +1270,17 @@ void GL2Encoder::s_glShaderSource(void *self, GLuint shader, GLsizei count, cons
 {
     GL2Encoder* ctx = (GL2Encoder*)self;
     ShaderData* shaderData = ctx->m_shared->getShaderData(shader);
-    SET_ERROR_IF(!ctx->m_shared->isObject(shader), GL_INVALID_VALUE);
+    SET_ERROR_IF(!ctx->m_shared->isShaderOrProgramObject(shader), GL_INVALID_VALUE);
     SET_ERROR_IF(!shaderData, GL_INVALID_OPERATION);
     SET_ERROR_IF((count<0), GL_INVALID_VALUE);
 
+    // Track original sources---they may be translated in the backend
+    std::vector<std::string> orig_sources;
+    for (int i = 0; i < count; i++) {
+        orig_sources.push_back(std::string((const char*)(string[i])));
+    }
+    shaderData->sources = orig_sources;
+
     int len = glUtilsCalcShaderSourceLen((char**)string, (GLint*)length, count);
     char *str = new char[len + 1];
     glUtilsPackStrings(str, (char**)string, (GLint*)length, count);
@@ -786,13 +1289,12 @@ void GL2Encoder::s_glShaderSource(void *self, GLuint shader, GLsizei count, cons
     // Perhaps we can borrow Mesa's pre-processor?
 
     if (!replaceSamplerExternalWith2D(str, shaderData)) {
-        delete str;
+        delete[] str;
         ctx->setError(GL_OUT_OF_MEMORY);
         return;
     }
-
     ctx->glShaderString(ctx, shader, str, len + 1);
-    delete str;
+    delete[] str;
 }
 
 void GL2Encoder::s_glFinish(void *self)
@@ -804,12 +1306,17 @@ void GL2Encoder::s_glFinish(void *self)
 void GL2Encoder::s_glLinkProgram(void * self, GLuint program)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
+    bool isProgram = ctx->m_shared->isProgram(program);
+    SET_ERROR_IF(!isProgram && !ctx->m_shared->isShader(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(!isProgram, GL_INVALID_OPERATION);
+
     ctx->m_glLinkProgram_enc(self, program);
 
     GLint linkStatus = 0;
     ctx->glGetProgramiv(self,program,GL_LINK_STATUS,&linkStatus);
-    if (!linkStatus)
+    if (!linkStatus) {
         return;
+    }
 
     //get number of active uniforms in the program
     GLint numUniforms=0;
@@ -847,7 +1354,7 @@ void GL2Encoder::s_glDeleteProgram(void *self, GLuint program)
 void GL2Encoder::s_glGetUniformiv(void *self, GLuint program, GLint location, GLint* params)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    SET_ERROR_IF(!ctx->m_shared->isObject(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(!ctx->m_shared->isShaderOrProgramObject(program), GL_INVALID_VALUE);
     SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
     SET_ERROR_IF(!ctx->m_shared->isProgramInitialized(program), GL_INVALID_OPERATION);
     GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
@@ -857,7 +1364,7 @@ void GL2Encoder::s_glGetUniformiv(void *self, GLuint program, GLint location, GL
 void GL2Encoder::s_glGetUniformfv(void *self, GLuint program, GLint location, GLfloat* params)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    SET_ERROR_IF(!ctx->m_shared->isObject(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(!ctx->m_shared->isShaderOrProgramObject(program), GL_INVALID_VALUE);
     SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
     SET_ERROR_IF(!ctx->m_shared->isProgramInitialized(program), GL_INVALID_OPERATION);
     GLint hostLoc = ctx->m_shared->locationWARAppToHost(program,location);
@@ -877,8 +1384,7 @@ GLuint GL2Encoder::s_glCreateProgram(void * self)
 GLuint GL2Encoder::s_glCreateShader(void *self, GLenum shaderType)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    RET_AND_SET_ERROR_IF(((shaderType != GL_VERTEX_SHADER) && (shaderType != GL_FRAGMENT_SHADER)),
-        GL_INVALID_ENUM, 0);
+    RET_AND_SET_ERROR_IF(!GLESv2Validation::shaderType(ctx, shaderType), GL_INVALID_ENUM, 0);
     GLuint shader = ctx->m_glCreateShader_enc(self, shaderType);
     if (shader != 0) {
         if (!ctx->m_shared->addShaderData(shader)) {
@@ -903,6 +1409,20 @@ void GL2Encoder::s_glGetShaderSource(void *self, GLuint shader, GLsizei bufsize,
     GL2Encoder *ctx = (GL2Encoder*)self;
     SET_ERROR_IF(bufsize < 0, GL_INVALID_VALUE);
     ctx->m_glGetShaderSource_enc(self, shader, bufsize, length, source);
+    ShaderData* shaderData = ctx->m_shared->getShaderData(shader);
+    if (shaderData) {
+        std::string returned;
+        int curr_len = 0;
+        for (int i = 0; i < shaderData->sources.size(); i++) {
+            if (curr_len + shaderData->sources[i].size() < bufsize - 1) {
+                returned += shaderData->sources[i];
+            } else {
+                returned += shaderData->sources[i].substr(0, bufsize - 1 - curr_len);
+                break;
+            }
+        }
+        memcpy(source, returned.substr(0, bufsize - 1).c_str(), bufsize);
+    }
 }
 
 void GL2Encoder::s_glGetShaderInfoLog(void *self, GLuint shader, GLsizei bufsize,
@@ -942,6 +1462,19 @@ void GL2Encoder::s_glDetachShader(void *self, GLuint program, GLuint shader)
     ctx->m_shared->detachShader(program, shader);
 }
 
+int sArrIndexOfUniformExpr(const char* name, int* err) {
+    *err = 0;
+    int arrIndex = 0;
+    int namelen = strlen(name);
+    if (name[namelen-1] == ']') {
+        const char *brace = strrchr(name,'[');
+        if (!brace || sscanf(brace+1,"%d",&arrIndex) != 1) {
+            *err = 1; return 0;
+        }
+    }
+    return arrIndex;
+}
+
 int GL2Encoder::s_glGetUniformLocation(void *self, GLuint program, const GLchar *name)
 {
     if (!name) return -1;
@@ -953,14 +1486,9 @@ int GL2Encoder::s_glGetUniformLocation(void *self, GLuint program, const GLchar
     int arrIndex = 0;
     bool needLocationWAR = ctx->m_shared->needUniformLocationWAR(program);
     if (needLocationWAR) {
-        int namelen = strlen(name);
-        if (name[namelen-1] == ']') {
-            char *brace = strrchr(name,'[');
-            if (!brace || sscanf(brace+1,"%d",&arrIndex) != 1) {
-                return -1;
-            }
-
-        }
+        int err;
+        arrIndex = sArrIndexOfUniformExpr(name, &err);
+        if (err) return -1;
     }
 
     int hostLoc = ctx->m_glGetUniformLocation_enc(self, program, name);
@@ -995,15 +1523,11 @@ bool GL2Encoder::updateHostTexture2DBinding(GLenum texUnit, GLenum newTarget)
     return false;
 }
 
-void GL2Encoder::s_glUseProgram(void *self, GLuint program)
-{
-    GL2Encoder *ctx = (GL2Encoder*)self;
+void GL2Encoder::updateHostTexture2DBindingsFromProgramData(GLuint program) {
+    GL2Encoder *ctx = this;
     GLClientState* state = ctx->m_state;
     GLSharedGroupPtr shared = ctx->m_shared;
 
-    ctx->m_glUseProgram_enc(self, program);
-    ctx->m_state->setCurrentProgram(program);
-
     GLenum origActiveTexture = state->getActiveTextureUnit();
     GLenum hostActiveTexture = origActiveTexture;
     GLint samplerIdx = -1;
@@ -1013,57 +1537,43 @@ void GL2Encoder::s_glUseProgram(void *self, GLuint program)
         if (samplerVal < 0 || samplerVal >= GLClientState::MAX_TEXTURE_UNITS)
             continue;
         if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + samplerVal,
-                samplerTarget))
+                    samplerTarget))
         {
             hostActiveTexture = GL_TEXTURE0 + samplerVal;
         }
     }
     state->setActiveTextureUnit(origActiveTexture);
     if (hostActiveTexture != origActiveTexture) {
-        ctx->m_glActiveTexture_enc(self, origActiveTexture);
+        ctx->m_glActiveTexture_enc(ctx, origActiveTexture);
     }
 }
 
-void GL2Encoder::checkValidUniformParam(void *self, GLsizei count, GLboolean transpose)
+void GL2Encoder::s_glUseProgram(void *self, GLuint program)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLuint program = ctx->m_state->currentProgram();
-    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
-    SET_ERROR_IF((count < 0 || transpose == GL_TRUE), GL_INVALID_VALUE);
-}
+    GLSharedGroupPtr shared = ctx->m_shared;
 
-void GL2Encoder::getHostLocation(void *self, GLint location, GLint *hostLoc)
-{
-    GL2Encoder *ctx = (GL2Encoder*)self;
-    GLuint program = ctx->m_state->currentProgram();
-    if (location == -1) {
-        *hostLoc = location;
-        return;
-    }
-    SET_ERROR_IF((location < 0), GL_INVALID_OPERATION);
-    GLint curHostLoc = ctx->m_shared->locationWARAppToHost(program,location);
-    SET_ERROR_IF((ctx->m_shared->getProgramUniformType(program,curHostLoc) == 0 &&
-            curHostLoc!=-1), GL_INVALID_OPERATION);
-    *hostLoc = curHostLoc;
+    SET_ERROR_IF(program && !shared->isShaderOrProgramObject(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(program && !shared->isProgram(program), GL_INVALID_OPERATION);
+
+    ctx->m_glUseProgram_enc(self, program);
+    ctx->m_state->setCurrentProgram(program);
+    ctx->m_state->setCurrentShaderProgram(program);
+
+    ctx->updateHostTexture2DBindingsFromProgramData(program);
 }
 
 void GL2Encoder::s_glUniform1f(void *self , GLint location, GLfloat x)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform1f_enc(self, hostLoc, x);
 }
 
 void GL2Encoder::s_glUniform1fv(void *self , GLint location, GLsizei count, const GLfloat* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform1fv_enc(self, hostLoc, count, v);
 }
 
@@ -1072,14 +1582,12 @@ void GL2Encoder::s_glUniform1i(void *self , GLint location, GLint x)
     GL2Encoder *ctx = (GL2Encoder*)self;
     GLClientState* state = ctx->m_state;
     GLSharedGroupPtr shared = ctx->m_shared;
-    GLint hostLoc;
 
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform1i_enc(self, hostLoc, x);
 
     GLenum target;
-    if (shared->setSamplerUniform(state->currentProgram(), location, x, &target)) {
+    if (shared->setSamplerUniform(state->currentShaderProgram(), location, x, &target)) {
         GLenum origActiveTexture = state->getActiveTextureUnit();
         if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + x, target)) {
             ctx->m_glActiveTexture_enc(self, origActiveTexture);
@@ -1091,160 +1599,112 @@ void GL2Encoder::s_glUniform1i(void *self , GLint location, GLint x)
 void GL2Encoder::s_glUniform1iv(void *self , GLint location, GLsizei count, const GLint* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform1iv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniform2f(void *self , GLint location, GLfloat x, GLfloat y)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform2f_enc(self, hostLoc, x, y);
 }
 
 void GL2Encoder::s_glUniform2fv(void *self , GLint location, GLsizei count, const GLfloat* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform2fv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniform2i(void *self , GLint location, GLint x, GLint y)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform2i_enc(self, hostLoc, x, y);
 }
 
 void GL2Encoder::s_glUniform2iv(void *self , GLint location, GLsizei count, const GLint* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform2iv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniform3f(void *self , GLint location, GLfloat x, GLfloat y, GLfloat z)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform3f_enc(self, hostLoc, x, y, z);
 }
 
 void GL2Encoder::s_glUniform3fv(void *self , GLint location, GLsizei count, const GLfloat* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform3fv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniform3i(void *self , GLint location, GLint x, GLint y, GLint z)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform3i_enc(self, hostLoc, x, y, z);
 }
 
 void GL2Encoder::s_glUniform3iv(void *self , GLint location, GLsizei count, const GLint* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform3iv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniform4f(void *self , GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform4f_enc(self, hostLoc, x, y, z, w);
 }
 
 void GL2Encoder::s_glUniform4fv(void *self , GLint location, GLsizei count, const GLfloat* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform4fv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniform4i(void *self , GLint location, GLint x, GLint y, GLint z, GLint w)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, 0, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform4i_enc(self, hostLoc, x, y, z, w);
 }
 
 void GL2Encoder::s_glUniform4iv(void *self , GLint location, GLsizei count, const GLint* v)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, GL_FALSE);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniform4iv_enc(self, hostLoc, count, v);
 }
 
 void GL2Encoder::s_glUniformMatrix2fv(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, transpose);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniformMatrix2fv_enc(self, hostLoc, count, transpose, value);
 }
 
 void GL2Encoder::s_glUniformMatrix3fv(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, transpose);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniformMatrix3fv_enc(self, hostLoc, count, transpose, value);
 }
 
 void GL2Encoder::s_glUniformMatrix4fv(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
 {
     GL2Encoder *ctx = (GL2Encoder*)self;
-    GLint hostLoc;
-
-    ctx->checkValidUniformParam(self, count, transpose);
-    ctx->getHostLocation(self, location, &hostLoc);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
     ctx->m_glUniformMatrix4fv_enc(self, hostLoc, count, transpose, value);
 }
 
@@ -1266,6 +1726,7 @@ void GL2Encoder::s_glBindTexture(void* self, GLenum target, GLuint texture)
     GLenum err;
     GLboolean firstUse;
 
+    SET_ERROR_IF(!GLESv2Validation::textureTarget(ctx, target), GL_INVALID_ENUM);
     SET_ERROR_IF((err = state->bindTexture(target, texture, &firstUse)) != GL_NO_ERROR, err);
 
     if (target != GL_TEXTURE_2D && target != GL_TEXTURE_EXTERNAL_OES) {
@@ -1313,7 +1774,7 @@ void GL2Encoder::s_glGetTexParameterfv(void* self,
     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
         ctx->m_glGetTexParameterfv_enc(ctx, GL_TEXTURE_2D, pname, params);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     } else {
         ctx->m_glGetTexParameterfv_enc(ctx, target, pname, params);
     }
@@ -1334,7 +1795,7 @@ void GL2Encoder::s_glGetTexParameteriv(void* self,
         if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
             ctx->override2DTextureTarget(target);
             ctx->m_glGetTexParameteriv_enc(ctx, GL_TEXTURE_2D, pname, params);
-            ctx->restore2DTextureTarget();
+            ctx->restore2DTextureTarget(target);
         } else {
             ctx->m_glGetTexParameteriv_enc(ctx, target, pname, params);
         }
@@ -1371,7 +1832,7 @@ void GL2Encoder::s_glTexParameterf(void* self,
     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
         ctx->m_glTexParameterf_enc(ctx, GL_TEXTURE_2D, pname, param);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     } else {
         ctx->m_glTexParameterf_enc(ctx, target, pname, param);
     }
@@ -1390,7 +1851,7 @@ void GL2Encoder::s_glTexParameterfv(void* self,
     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
         ctx->m_glTexParameterfv_enc(ctx, GL_TEXTURE_2D, pname, params);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     } else {
         ctx->m_glTexParameterfv_enc(ctx, target, pname, params);
     }
@@ -1409,25 +1870,95 @@ void GL2Encoder::s_glTexParameteri(void* self,
     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
         ctx->m_glTexParameteri_enc(ctx, GL_TEXTURE_2D, pname, param);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     } else {
         ctx->m_glTexParameteri_enc(ctx, target, pname, param);
     }
 }
 
+static int ilog2(uint32_t x) {
+    int p = 0;
+    while ((1 << p) < x)
+        p++;
+    return p;
+}
+
 void GL2Encoder::s_glTexImage2D(void* self, GLenum target, GLint level,
         GLint internalformat, GLsizei width, GLsizei height, GLint border,
         GLenum format, GLenum type, const GLvoid* pixels)
 {
     GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::textureTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelType(ctx, type), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelFormat(ctx, format), GL_INVALID_ENUM);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+
+    GLint max_texture_size;
+    GLint max_cube_map_texture_size;
+    ctx->glGetIntegerv(ctx, GL_MAX_TEXTURE_SIZE, &max_texture_size);
+    ctx->glGetIntegerv(ctx, GL_MAX_CUBE_MAP_TEXTURE_SIZE, &max_cube_map_texture_size);
+    SET_ERROR_IF(level < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF((target == GL_TEXTURE_CUBE_MAP) &&
+                 (level > ilog2(max_cube_map_texture_size)), GL_INVALID_VALUE);
+    SET_ERROR_IF(width < 0 || height < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(width > max_texture_size, GL_INVALID_VALUE);
+    SET_ERROR_IF(height > max_texture_size, GL_INVALID_VALUE);
+    SET_ERROR_IF(GLESv2Validation::isCubeMapTarget(target) && width > max_cube_map_texture_size, GL_INVALID_VALUE);
+    SET_ERROR_IF(GLESv2Validation::isCubeMapTarget(target) && height > max_cube_map_texture_size, GL_INVALID_VALUE);
+    SET_ERROR_IF(border != 0, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits and is evenly divisible by the type.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->m_state->pboNeededDataSize(width, height, 1, format, type, 0) >
+                  ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size %
+                  glSizeof(type)),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 ((uintptr_t)pixels % glSizeof(type)),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(state->isBoundTextureImmutableFormat(target), GL_INVALID_OPERATION);
+
+    GLenum stateTarget = target;
+    if (target == GL_TEXTURE_CUBE_MAP_POSITIVE_X ||
+        target == GL_TEXTURE_CUBE_MAP_POSITIVE_Y ||
+        target == GL_TEXTURE_CUBE_MAP_POSITIVE_Z ||
+        target == GL_TEXTURE_CUBE_MAP_NEGATIVE_X ||
+        target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Y ||
+        target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Z)
+        stateTarget = GL_TEXTURE_CUBE_MAP;
+
+    state->setBoundTextureInternalFormat(stateTarget, internalformat);
+    state->setBoundTextureFormat(stateTarget, format);
+    state->setBoundTextureType(stateTarget, type);
+    state->setBoundTextureDims(stateTarget, level, width, height, 1);
+
     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
-        ctx->m_glTexImage2D_enc(ctx, target, level, internalformat, width,
-                height, border, format, type, pixels);
-        ctx->restore2DTextureTarget();
+    }
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glTexImage2DOffsetAEMU(
+                ctx, target, level, internalformat,
+                width, height, border,
+                format, type, (uintptr_t)pixels);
     } else {
-        ctx->m_glTexImage2D_enc(ctx, target, level, internalformat, width,
-                height, border, format, type, pixels);
+        ctx->m_glTexImage2D_enc(
+                ctx, target, level, internalformat,
+                width, height, border,
+                format, type, pixels);
+    }
+
+    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
+        ctx->restore2DTextureTarget(target);
     }
 }
 
@@ -1436,20 +1967,97 @@ void GL2Encoder::s_glTexSubImage2D(void* self, GLenum target, GLint level,
         GLenum type, const GLvoid* pixels)
 {
     GL2Encoder* ctx = (GL2Encoder*)self;
-    GLint maxTextureSize;
-    ctx->glGetIntegerv(self, GL_MAX_TEXTURE_SIZE, &maxTextureSize);
+    GLClientState* state = ctx->m_state;
+ 
+    SET_ERROR_IF(!GLESv2Validation::textureTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelType(ctx, type), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelFormat(ctx, format), GL_INVALID_ENUM);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+
+    GLint max_texture_size;
+    GLint max_cube_map_texture_size;
+    ctx->glGetIntegerv(ctx, GL_MAX_TEXTURE_SIZE, &max_texture_size);
+    ctx->glGetIntegerv(ctx, GL_MAX_CUBE_MAP_TEXTURE_SIZE, &max_cube_map_texture_size);
+    SET_ERROR_IF(level < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(GLESv2Validation::isCubeMapTarget(target) &&
+                 level > ilog2(max_cube_map_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(width < 0 || height < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(xoffset < 0 || yoffset < 0, GL_INVALID_VALUE);
+
+    GLuint tex = state->getBoundTexture(target);
+    GLsizei neededWidth = xoffset + width;
+    GLsizei neededHeight = yoffset + height;
+    GLsizei neededDepth = 1;
+
+    if (tex && !state->queryTexEGLImageBacked(tex)) {
+        SET_ERROR_IF(
+                (neededWidth > state->queryTexWidth(level, tex) ||
+                 neededHeight > state->queryTexHeight(level, tex) ||
+                 neededDepth > state->queryTexDepth(level, tex)),
+                GL_INVALID_VALUE);
+    }
 
-    SET_ERROR_IF((level < 0 || level > log2(maxTextureSize)), GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits and is evenly divisible by the type.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (state->pboNeededDataSize(width, height, 1, format, type, 0) >
+                  ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size %
+                  glSizeof(type)),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(!ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) && !pixels, GL_INVALID_OPERATION);
 
-     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
+    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
+    }
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glTexSubImage2DOffsetAEMU(
+                ctx, target, level,
+                xoffset, yoffset, width, height,
+                format, type, (uintptr_t)pixels);
+    } else {
         ctx->m_glTexSubImage2D_enc(ctx, target, level, xoffset, yoffset, width,
                 height, format, type, pixels);
-        ctx->restore2DTextureTarget();
-     } else {
-         ctx->m_glTexSubImage2D_enc(ctx, target, level, xoffset, yoffset, width,
-                 height, format, type, pixels);
-     }
+    }
+
+    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
+        ctx->restore2DTextureTarget(target);
+    }
+}
+
+void GL2Encoder::s_glCopyTexImage2D(void* self, GLenum target, GLint level,
+        GLenum internalformat, GLint x, GLint y,
+        GLsizei width, GLsizei height, GLint border)
+{
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(ctx->glCheckFramebufferStatus(ctx, GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE,
+                 GL_INVALID_FRAMEBUFFER_OPERATION);
+    // This is needed to work around underlying OpenGL drivers
+    // (such as those feeding some some AMD GPUs) that expect
+    // positive components of cube maps to be defined _before_
+    // the negative components (otherwise a segfault occurs).
+    GLenum extraTarget =
+        state->copyTexImageLuminanceCubeMapAMDWorkaround
+            (target, level, internalformat);
+
+    if (extraTarget) {
+        ctx->m_glCopyTexImage2D_enc(ctx, extraTarget, level, internalformat,
+                                    x, y, width, height, border);
+    }
+
+    ctx->m_glCopyTexImage2D_enc(ctx, target, level, internalformat,
+                                x, y, width, height, border);
+
+    state->setBoundTextureInternalFormat(target, internalformat);
+    state->setBoundTextureDims(target, level, width, height, 1);
 }
 
 void GL2Encoder::s_glTexParameteriv(void* self,
@@ -1465,24 +2073,2715 @@ void GL2Encoder::s_glTexParameteriv(void* self,
     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
         ctx->override2DTextureTarget(target);
         ctx->m_glTexParameteriv_enc(ctx, GL_TEXTURE_2D, pname, params);
-        ctx->restore2DTextureTarget();
+        ctx->restore2DTextureTarget(target);
     } else {
         ctx->m_glTexParameteriv_enc(ctx, target, pname, params);
     }
 }
 
+bool GL2Encoder::texture2DNeedsOverride(GLenum target) const {
+    return (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) &&
+           target != m_state->getPriorityEnabledTarget(GL_TEXTURE_2D);
+}
+
 void GL2Encoder::override2DTextureTarget(GLenum target)
 {
-    if ((target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) &&
-        target != m_state->getPriorityEnabledTarget(GL_TEXTURE_2D)) {
-            m_glBindTexture_enc(this, GL_TEXTURE_2D,
-                    m_state->getBoundTexture(target));
+    if (texture2DNeedsOverride(target)) {
+        m_glBindTexture_enc(this, GL_TEXTURE_2D,
+                m_state->getBoundTexture(target));
     }
 }
 
-void GL2Encoder::restore2DTextureTarget()
+void GL2Encoder::restore2DTextureTarget(GLenum target)
 {
-    GLenum priorityTarget = m_state->getPriorityEnabledTarget(GL_TEXTURE_2D);
-    m_glBindTexture_enc(this, GL_TEXTURE_2D,
-            m_state->getBoundTexture(priorityTarget));
+    if (texture2DNeedsOverride(target)) {
+        m_glBindTexture_enc(this, GL_TEXTURE_2D,
+                m_state->getBoundTexture(
+                    m_state->getPriorityEnabledTarget(GL_TEXTURE_2D)));
+    }
+}
+
+void GL2Encoder::associateEGLImage(GLenum target, GLeglImageOES eglImage) {
+    m_state->setBoundEGLImage(target, eglImage);
+}
+
+
+GLuint GL2Encoder::boundBuffer(GLenum target) const {
+    return m_state->getBuffer(target);
+}
+
+BufferData* GL2Encoder::getBufferData(GLenum target) const {
+    GLuint bufferId = m_state->getBuffer(target);
+    if (!bufferId) return NULL;
+    return m_shared->getBufferData(bufferId);
+}
+
+BufferData* GL2Encoder::getBufferDataById(GLuint bufferId) const {
+    if (!bufferId) return NULL;
+    return m_shared->getBufferData(bufferId);
+}
+
+bool GL2Encoder::isBufferMapped(GLuint buffer) const {
+    return m_shared->getBufferData(buffer)->m_mapped;
+}
+
+bool GL2Encoder::isBufferTargetMapped(GLenum target) const {
+    BufferData* buf = getBufferData(target);
+    if (!buf) return false;
+    return buf->m_mapped;
 }
+
+void GL2Encoder::s_glGenRenderbuffers(void* self,
+        GLsizei n, GLuint* renderbuffers) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glGenFramebuffers_enc(self, n, renderbuffers);
+    state->addRenderbuffers(n, renderbuffers);
+}
+
+void GL2Encoder::s_glDeleteRenderbuffers(void* self,
+        GLsizei n, const GLuint* renderbuffers) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glDeleteRenderbuffers_enc(self, n, renderbuffers);
+
+    // Nope, lets just leak those for now.
+    // The spec has an *amazingly* convoluted set of conditions for when
+    // render buffers are actually deleted:
+    // glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array addressed by renderbuffers. Unused names in renderbuffers that have been marked as used for the purposes of glGenRenderbuffers are marked as unused again. The name zero is reserved by the GL and is silently ignored, should it occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound to the target GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer had been executed with a target of GL_RENDERBUFFER and a name of zero.
+    //
+    // If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if glFramebufferRenderbuffer had been called, with a renderbuffer of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. ***Note that the renderbuffer image is specifically not detached from any non-bound framebuffers***
+    //
+    // So, just detach this one from the bound FBO, and ignore the rest.
+    for (int i = 0; i < n; i++) {
+        state->detachRbo(renderbuffers[i]);
+    }
+    // state->removeRenderbuffers(n, renderbuffers);
+}
+
+void GL2Encoder::s_glBindRenderbuffer(void* self,
+        GLenum target, GLuint renderbuffer) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF((target != GL_RENDERBUFFER),
+                 GL_INVALID_ENUM);
+
+    ctx->m_glBindRenderbuffer_enc(self, target, renderbuffer);
+    state->bindRenderbuffer(target, renderbuffer);
+}
+
+void GL2Encoder::s_glRenderbufferStorage(void* self,
+        GLenum target, GLenum internalformat,
+        GLsizei width, GLsizei height) {
+    GL2Encoder* ctx = (GL2Encoder*) self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(target != GL_RENDERBUFFER, GL_INVALID_ENUM);
+    SET_ERROR_IF(
+        !GLESv2Validation::rboFormat(ctx, internalformat),
+        GL_INVALID_ENUM);
+
+    state->setBoundRenderbufferFormat(internalformat);
+    state->setBoundRenderbufferSamples(0);
+
+    ctx->m_glRenderbufferStorage_enc(self, target, internalformat,
+                                     width, height);
+}
+
+void GL2Encoder::s_glFramebufferRenderbuffer(void* self,
+        GLenum target, GLenum attachment,
+        GLenum renderbuffertarget, GLuint renderbuffer) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::framebufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::framebufferAttachment(ctx, attachment), GL_INVALID_ENUM);
+    state->attachRbo(target, attachment, renderbuffer);
+
+    ctx->m_glFramebufferRenderbuffer_enc(self, target, attachment, renderbuffertarget, renderbuffer);
+}
+
+void GL2Encoder::s_glGenFramebuffers(void* self,
+        GLsizei n, GLuint* framebuffers) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glGenFramebuffers_enc(self, n, framebuffers);
+    state->addFramebuffers(n, framebuffers);
+}
+
+void GL2Encoder::s_glDeleteFramebuffers(void* self,
+        GLsizei n, const GLuint* framebuffers) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glDeleteFramebuffers_enc(self, n, framebuffers);
+    state->removeFramebuffers(n, framebuffers);
+}
+
+void GL2Encoder::s_glBindFramebuffer(void* self,
+        GLenum target, GLuint framebuffer) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::framebufferTarget(ctx, target), GL_INVALID_ENUM);
+
+    state->bindFramebuffer(target, framebuffer);
+
+    ctx->m_glBindFramebuffer_enc(self, target, framebuffer);
+}
+
+void GL2Encoder::s_glFramebufferTexture2D(void* self,
+        GLenum target, GLenum attachment,
+        GLenum textarget, GLuint texture, GLint level) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::framebufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::framebufferAttachment(ctx, attachment), GL_INVALID_ENUM);
+    state->attachTextureObject(target, attachment, texture);
+
+    ctx->m_glFramebufferTexture2D_enc(self, target, attachment, textarget, texture, level);
+}
+
+void GL2Encoder::s_glFramebufferTexture3DOES(void* self,
+        GLenum target, GLenum attachment,
+        GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    state->attachTextureObject(target, attachment, texture);
+
+    ctx->m_glFramebufferTexture3DOES_enc(self, target, attachment, textarget, texture, level, zoffset);
+}
+
+void GL2Encoder::s_glGetFramebufferAttachmentParameteriv(void* self,
+        GLenum target, GLenum attachment, GLenum pname, GLint* params) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    const GLClientState* state = ctx->m_state;
+    SET_ERROR_IF(!GLESv2Validation::framebufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(pname != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME &&
+                 pname != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE &&
+                 !state->attachmentHasObject(target, attachment),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF((pname == GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL ||
+                  pname == GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE ||
+                  pname == GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER) &&
+                 (!state->attachmentHasObject(target, attachment) ||
+                  state->getBoundFramebufferAttachmentType(target, attachment) !=
+                  FBO_ATTACHMENT_TEXTURE),
+                 !state->attachmentHasObject(target, attachment) ?
+                 GL_INVALID_OPERATION : GL_INVALID_ENUM);
+    SET_ERROR_IF(attachment == GL_DEPTH_STENCIL_ATTACHMENT &&
+                 pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME &&
+                 (state->objectOfAttachment(target, GL_DEPTH_ATTACHMENT) !=
+                  state->objectOfAttachment(target, GL_STENCIL_ATTACHMENT)),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(state->boundFramebuffer(target) &&
+                 (attachment == GL_BACK ||
+                  attachment == GL_FRONT),
+                 GL_INVALID_OPERATION);
+    ctx->m_glGetFramebufferAttachmentParameteriv_enc(self, target, attachment, pname, params);
+}
+
+bool GL2Encoder::isCompleteFbo(GLenum target, const GLClientState* state,
+                               GLenum attachment) const {
+    FboFormatInfo fbo_format_info;
+    state->getBoundFramebufferFormat(target, attachment, &fbo_format_info);
+
+    bool res;
+    switch (fbo_format_info.type) {
+    case FBO_ATTACHMENT_RENDERBUFFER:
+        switch (fbo_format_info.rb_format) {
+        case GL_R16F:
+        case GL_RG16F:
+        case GL_RGBA16F:
+        case GL_R32F:
+        case GL_RG32F:
+        case GL_RGBA32F:
+        case GL_R11F_G11F_B10F:
+            res = majorVersion() >= 3 && hasExtension("GL_EXT_color_buffer_float");
+            break;
+        case GL_RGB16F:
+            res = majorVersion() >= 3 && hasExtension("GL_EXT_color_buffer_half_float");
+            break;
+        case GL_STENCIL_INDEX8:
+            if (attachment == GL_STENCIL_ATTACHMENT) {
+                res = true;
+            } else {
+                res = false;
+            }
+            break;
+        default:
+            res = true;
+        }
+        break;
+    case FBO_ATTACHMENT_TEXTURE:
+        switch (fbo_format_info.tex_internalformat) {
+        case GL_R16F:
+        case GL_RG16F:
+        case GL_RGBA16F:
+        case GL_R32F:
+        case GL_RG32F:
+        case GL_RGBA32F:
+        case GL_R11F_G11F_B10F:
+            res = majorVersion() >= 3 && hasExtension("GL_EXT_color_buffer_float");
+            break;
+        case GL_RGB16F:
+            res = majorVersion() >= 3 && hasExtension("GL_EXT_color_buffer_half_float");
+            break;
+        case GL_RED:
+        case GL_RG:
+        case GL_SRGB8:
+        case GL_RGB32UI:
+        case GL_RGB16UI:
+        case GL_RGB8UI:
+        case GL_RGB32I:
+        case GL_RGB16I:
+        case GL_RGB8I:
+        case GL_R8_SNORM:
+        case GL_RG8_SNORM:
+        case GL_RGB8_SNORM:
+        case GL_RGBA8_SNORM:
+            res = false;
+            break;
+        // No float/half-float formats allowed for RGB(A)
+        case GL_RGB:
+        case GL_RGBA:
+            switch (fbo_format_info.tex_type) {
+            case GL_FLOAT:
+            case GL_HALF_FLOAT_OES:
+            case GL_UNSIGNED_INT_10F_11F_11F_REV:
+            case GL_UNSIGNED_INT_2_10_10_10_REV:
+                res = false;
+                break;
+            default:
+                res = true;
+            }
+            break;
+        default:
+            res = true;
+        }
+        break;
+    case FBO_ATTACHMENT_NONE:
+        res = true;
+        break;
+    default:
+        res = true;
+    }
+    return res;
+}
+
+bool GL2Encoder::checkFramebufferCompleteness(GLenum target, const GLClientState* state) const {
+    bool res = true;
+
+    for (int i = 0; i < state->getMaxColorAttachments(); i++) {
+        res = res && isCompleteFbo(target, state, glUtilsColorAttachmentName(i));
+    }
+
+    res = res && isCompleteFbo(target, state, GL_DEPTH_ATTACHMENT);
+    res = res && isCompleteFbo(target, state, GL_STENCIL_ATTACHMENT);
+
+    return res;
+}
+
+GLenum GL2Encoder::s_glCheckFramebufferStatus(void* self, GLenum target) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    bool fboCompleteByCodec =
+        ctx->checkFramebufferCompleteness(target, state);
+
+    if (!fboCompleteByCodec) {
+        state->setCheckFramebufferStatus(target, GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT);
+        return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+    } else {
+        // double check with underlying opengl to avoid craziness.
+        GLenum host_checkstatus = ctx->m_glCheckFramebufferStatus_enc(self, target);
+        state->setCheckFramebufferStatus(target, host_checkstatus);
+        if (host_checkstatus == GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS) return GL_FRAMEBUFFER_COMPLETE;
+        return host_checkstatus;
+    }
+}
+
+void GL2Encoder::s_glGenVertexArrays(void* self, GLsizei n, GLuint* arrays) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glGenVertexArrays_enc(self, n, arrays);
+    for (int i = 0; i < n; i++) {
+        ALOGV("%s: gen vao %u", __FUNCTION__, arrays[i]);
+    }
+    state->addVertexArrayObjects(n, arrays);
+}
+
+void GL2Encoder::s_glDeleteVertexArrays(void* self, GLsizei n, const GLuint* arrays) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
+
+    ctx->m_glDeleteVertexArrays_enc(self, n, arrays);
+    for (int i = 0; i < n; i++) {
+        ALOGV("%s: delete vao %u", __FUNCTION__, arrays[i]);
+    }
+    state->removeVertexArrayObjects(n, arrays);
+}
+
+void GL2Encoder::s_glBindVertexArray(void* self, GLuint array) {
+    ALOGV("%s: call. array=%u\n", __FUNCTION__, array);
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    SET_ERROR_IF(!state->isVertexArrayObject(array), GL_INVALID_OPERATION);
+    ctx->m_glBindVertexArray_enc(self, array);
+    state->setVertexArrayObject(array);
+}
+
+void* GL2Encoder::s_glMapBufferRange(void* self, GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    // begin validation (lots)
+    
+    RET_AND_SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM, NULL);
+
+    GLuint boundBuffer = ctx->m_state->getBuffer(target);
+
+    RET_AND_SET_ERROR_IF(boundBuffer == 0, GL_INVALID_OPERATION, NULL);
+
+    BufferData* buf = ctx->m_shared->getBufferData(boundBuffer);
+    RET_AND_SET_ERROR_IF(!buf, GL_INVALID_VALUE, NULL);
+
+    GLsizeiptr bufferDataSize = buf->m_size;
+
+    RET_AND_SET_ERROR_IF(offset < 0, GL_INVALID_VALUE, NULL);
+    RET_AND_SET_ERROR_IF(length < 0, GL_INVALID_VALUE, NULL);
+    RET_AND_SET_ERROR_IF(offset + length > bufferDataSize, GL_INVALID_VALUE, NULL);
+    RET_AND_SET_ERROR_IF(access & ~GLESv2Validation::allBufferMapAccessFlags, GL_INVALID_VALUE, NULL);
+
+    RET_AND_SET_ERROR_IF(buf->m_mapped, GL_INVALID_OPERATION, NULL);
+    RET_AND_SET_ERROR_IF(!(access & (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT)), GL_INVALID_OPERATION, NULL);
+    RET_AND_SET_ERROR_IF(
+        (access & GL_MAP_READ_BIT) &&
+             ((access & GL_MAP_INVALIDATE_RANGE_BIT) ||
+              (access & GL_MAP_INVALIDATE_BUFFER_BIT) ||
+              (access & GL_MAP_UNSYNCHRONIZED_BIT) ||
+              (access & GL_MAP_FLUSH_EXPLICIT_BIT)), GL_INVALID_OPERATION, NULL);
+
+    // end validation; actually do stuff now
+   
+    buf->m_mapped = true;
+    buf->m_mappedAccess = access;
+    buf->m_mappedOffset = offset;
+    buf->m_mappedLength = length;
+
+    char* todo = (char*)buf->m_fixedBuffer.ptr() + offset;
+    ctx->glMapBufferRangeAEMU(
+            ctx, target,
+            offset, length,
+            access,
+            todo);
+
+    return todo;
+}
+
+GLboolean GL2Encoder::s_glUnmapBuffer(void* self, GLenum target) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    RET_AND_SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM, GL_FALSE);
+
+    GLuint boundBuffer = ctx->m_state->getBuffer(target);
+
+    RET_AND_SET_ERROR_IF(boundBuffer == 0, GL_INVALID_OPERATION, GL_FALSE);
+
+    BufferData* buf = ctx->m_shared->getBufferData(boundBuffer);
+    RET_AND_SET_ERROR_IF(!buf, GL_INVALID_VALUE, GL_FALSE);
+    RET_AND_SET_ERROR_IF(!buf->m_mapped, GL_INVALID_OPERATION, GL_FALSE);
+
+    if (buf->m_mappedAccess & GL_MAP_WRITE_BIT) {
+        // invalide index range cache here
+        if (buf->m_mappedAccess & GL_MAP_INVALIDATE_BUFFER_BIT) {
+            buf->m_indexRangeCache.invalidateRange(0, buf->m_size);
+        } else {
+            buf->m_indexRangeCache.invalidateRange(buf->m_mappedOffset, buf->m_mappedLength);
+        }
+    }
+
+    GLboolean host_res = GL_TRUE;
+
+    ctx->glUnmapBufferAEMU(
+            ctx, target,
+            buf->m_mappedOffset,
+            buf->m_mappedLength,
+            buf->m_mappedAccess,
+            (void*)((char*)buf->m_fixedBuffer.ptr() + buf->m_mappedOffset),
+            &host_res);
+
+    buf->m_mapped = false;
+    buf->m_mappedAccess = 0;
+    buf->m_mappedOffset = 0;
+    buf->m_mappedLength = 0;
+
+    return host_res;
+}
+
+void GL2Encoder::s_glFlushMappedBufferRange(void* self, GLenum target, GLintptr offset, GLsizeiptr length) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
+
+    GLuint boundBuffer = ctx->m_state->getBuffer(target);
+    SET_ERROR_IF(!boundBuffer, GL_INVALID_OPERATION);
+
+    BufferData* buf = ctx->m_shared->getBufferData(boundBuffer);
+    SET_ERROR_IF(!buf, GL_INVALID_VALUE);
+    SET_ERROR_IF(!buf->m_mapped, GL_INVALID_OPERATION);
+    SET_ERROR_IF(!(buf->m_mappedAccess & GL_MAP_FLUSH_EXPLICIT_BIT), GL_INVALID_OPERATION);
+
+    SET_ERROR_IF(offset < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(length < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(offset + length > buf->m_mappedLength, GL_INVALID_VALUE);
+
+    GLintptr totalOffset = buf->m_mappedOffset + offset;
+
+    buf->m_indexRangeCache.invalidateRange(totalOffset, length);
+
+    ctx->glFlushMappedBufferRangeAEMU(
+            ctx, target,
+            totalOffset,
+            length,
+            buf->m_mappedAccess,
+            (void*)((char*)buf->m_fixedBuffer.ptr() + totalOffset));
+}
+
+void GL2Encoder::s_glCompressedTexImage2D(void* self, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::textureTarget(ctx, target), GL_INVALID_ENUM);
+    // Filter compressed formats support.
+    SET_ERROR_IF(!GLESv2Validation::supportedCompressedFormat(ctx, internalformat), GL_INVALID_ENUM);
+    // Verify level <= log2(GL_MAX_TEXTURE_SIZE).
+    GLint max_texture_size;
+    GLint max_cube_map_texture_size;
+    ctx->glGetIntegerv(ctx, GL_MAX_TEXTURE_SIZE, &max_texture_size);
+    ctx->glGetIntegerv(ctx, GL_MAX_CUBE_MAP_TEXTURE_SIZE, &max_cube_map_texture_size);
+    SET_ERROR_IF(level < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_cube_map_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(width > max_texture_size, GL_INVALID_VALUE);
+    SET_ERROR_IF(height > max_texture_size, GL_INVALID_VALUE);
+    SET_ERROR_IF(border, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+    SET_ERROR_IF(width < 0 || height < 0, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (imageSize > ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    // TODO: Fix:
+    // If |imageSize| is inconsistent with compressed dimensions.
+    // SET_ERROR_IF(GLESv2Validation::compressedTexImageSize(internalformat, width, height, 1) != imageSize, GL_INVALID_VALUE);
+
+    GLenum stateTarget = target;
+    if (target == GL_TEXTURE_CUBE_MAP_POSITIVE_X ||
+        target == GL_TEXTURE_CUBE_MAP_POSITIVE_Y ||
+        target == GL_TEXTURE_CUBE_MAP_POSITIVE_Z ||
+        target == GL_TEXTURE_CUBE_MAP_NEGATIVE_X ||
+        target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Y ||
+        target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Z)
+        stateTarget = GL_TEXTURE_CUBE_MAP;
+    state->setBoundTextureInternalFormat(stateTarget, (GLint)internalformat);
+    state->setBoundTextureDims(stateTarget, level, width, height, 1);
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glCompressedTexImage2DOffsetAEMU(
+                ctx, target, level, internalformat,
+                width, height, border,
+                imageSize, (uintptr_t)data);
+    } else {
+        ctx->m_glCompressedTexImage2D_enc(
+                ctx, target, level, internalformat,
+                width, height, border,
+                imageSize, data);
+    }
+}
+
+void GL2Encoder::s_glCompressedTexSubImage2D(void* self, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::textureTarget(ctx, target), GL_INVALID_ENUM);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+    GLint max_texture_size;
+    GLint max_cube_map_texture_size;
+    ctx->glGetIntegerv(ctx, GL_MAX_TEXTURE_SIZE, &max_texture_size);
+    ctx->glGetIntegerv(ctx, GL_MAX_CUBE_MAP_TEXTURE_SIZE, &max_cube_map_texture_size);
+    SET_ERROR_IF(level < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_cube_map_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(width < 0 || height < 0, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (imageSize > ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(xoffset < 0 || yoffset < 0, GL_INVALID_VALUE);
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glCompressedTexSubImage2DOffsetAEMU(
+                ctx, target, level,
+                xoffset, yoffset,
+                width, height, format,
+                imageSize, (uintptr_t)data);
+    } else {
+        ctx->m_glCompressedTexSubImage2D_enc(
+                ctx, target, level,
+                xoffset, yoffset,
+                width, height, format,
+                imageSize, data);
+    }
+}
+
+void GL2Encoder::s_glBindBufferRange(void* self, GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
+
+    // Only works with certain targets
+    SET_ERROR_IF(
+        !(target == GL_ATOMIC_COUNTER_BUFFER ||
+          target == GL_SHADER_STORAGE_BUFFER ||
+          target == GL_TRANSFORM_FEEDBACK_BUFFER ||
+          target == GL_UNIFORM_BUFFER),
+        GL_INVALID_ENUM);
+
+    // Can't exceed range
+    SET_ERROR_IF(index < 0 ||
+                 index >= state->getMaxIndexedBufferBindings(target),
+                 GL_INVALID_VALUE);
+    SET_ERROR_IF(buffer && size <= 0, GL_INVALID_VALUE);
+    SET_ERROR_IF((target == GL_ATOMIC_COUNTER_BUFFER ||
+                  target == GL_TRANSFORM_FEEDBACK_BUFFER) &&
+                 (size % 4 || offset % 4),
+                 GL_INVALID_VALUE);
+
+    GLint ssbo_offset_align, ubo_offset_align;
+    ctx->s_glGetIntegerv(ctx, GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT, &ssbo_offset_align);
+    ctx->s_glGetIntegerv(ctx, GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &ubo_offset_align);
+    SET_ERROR_IF(target == GL_SHADER_STORAGE_BUFFER &&
+                 offset % ssbo_offset_align,
+                 GL_INVALID_VALUE);
+    SET_ERROR_IF(target == GL_UNIFORM_BUFFER &&
+                 offset % ubo_offset_align,
+                 GL_INVALID_VALUE);
+
+    state->bindBuffer(target, buffer);
+    ctx->m_state->addBuffer(buffer);
+    state->bindIndexedBuffer(target, index, buffer, offset, size, 0, 0);
+    ctx->m_glBindBufferRange_enc(self, target, index, buffer, offset, size);
+}
+
+void GL2Encoder::s_glBindBufferBase(void* self, GLenum target, GLuint index, GLuint buffer) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
+
+    // Only works with certain targets
+    SET_ERROR_IF(
+        !(target == GL_ATOMIC_COUNTER_BUFFER ||
+          target == GL_SHADER_STORAGE_BUFFER ||
+          target == GL_TRANSFORM_FEEDBACK_BUFFER ||
+          target == GL_UNIFORM_BUFFER),
+        GL_INVALID_ENUM);
+    // Can't exceed range
+    SET_ERROR_IF(index < 0 ||
+                 index >= state->getMaxIndexedBufferBindings(target),
+                 GL_INVALID_VALUE);
+
+    state->bindBuffer(target, buffer);
+    ctx->m_state->addBuffer(buffer);
+    BufferData* buf = ctx->getBufferDataById(buffer);
+    state->bindIndexedBuffer(target, index, buffer, 0, buf ? buf->m_size : 0, 0, 0);
+    ctx->m_glBindBufferBase_enc(self, target, index, buffer);
+}
+
+void GL2Encoder::s_glCopyBufferSubData(void *self , GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, readtarget), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, writetarget), GL_INVALID_ENUM);
+    SET_ERROR_IF((readtarget == GL_ATOMIC_COUNTER_BUFFER ||
+                  readtarget == GL_DISPATCH_INDIRECT_BUFFER ||
+                  readtarget == GL_DRAW_INDIRECT_BUFFER ||
+                  readtarget == GL_SHADER_STORAGE_BUFFER), GL_INVALID_ENUM);
+    SET_ERROR_IF((writetarget == GL_ATOMIC_COUNTER_BUFFER ||
+                  writetarget == GL_DISPATCH_INDIRECT_BUFFER ||
+                  writetarget == GL_DRAW_INDIRECT_BUFFER ||
+                  writetarget == GL_SHADER_STORAGE_BUFFER), GL_INVALID_ENUM);
+    SET_ERROR_IF(!ctx->boundBuffer(readtarget), GL_INVALID_OPERATION);
+    SET_ERROR_IF(!ctx->boundBuffer(writetarget), GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->isBufferTargetMapped(readtarget), GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->isBufferTargetMapped(writetarget), GL_INVALID_OPERATION);
+    SET_ERROR_IF(readoffset < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(writeoffset < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(size < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(
+        ctx->getBufferData(readtarget) &&
+        (readoffset + size > ctx->getBufferData(readtarget)->m_size),
+        GL_INVALID_VALUE);
+    SET_ERROR_IF(
+        ctx->getBufferData(writetarget) &&
+        (writeoffset + size > ctx->getBufferData(writetarget)->m_size),
+        GL_INVALID_VALUE);
+    SET_ERROR_IF(readtarget == writetarget &&
+                 !((writeoffset >= readoffset + size) ||
+                   (readoffset >= writeoffset + size)),
+                 GL_INVALID_VALUE);
+
+    ctx->m_glCopyBufferSubData_enc(self, readtarget, writetarget, readoffset, writeoffset, size);
+}
+
+void GL2Encoder::s_glGetBufferParameteriv(void* self, GLenum target, GLenum pname, GLint* params) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(
+        target != GL_ARRAY_BUFFER &&
+        target != GL_ELEMENT_ARRAY_BUFFER &&
+        target != GL_COPY_READ_BUFFER &&
+        target != GL_COPY_WRITE_BUFFER &&
+        target != GL_PIXEL_PACK_BUFFER &&
+        target != GL_PIXEL_UNPACK_BUFFER &&
+        target != GL_TRANSFORM_FEEDBACK_BUFFER &&
+        target != GL_UNIFORM_BUFFER,
+        GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::bufferParam(ctx, pname), GL_INVALID_ENUM);
+    SET_ERROR_IF(!ctx->boundBuffer(target), GL_INVALID_OPERATION);
+    SET_ERROR_IF(pname != GL_BUFFER_ACCESS_FLAGS &&
+                 pname != GL_BUFFER_MAPPED &&
+                 pname != GL_BUFFER_SIZE &&
+                 pname != GL_BUFFER_USAGE &&
+                 pname != GL_BUFFER_MAP_LENGTH &&
+                 pname != GL_BUFFER_MAP_OFFSET,
+                 GL_INVALID_ENUM);
+
+    if (!params) return;
+
+    BufferData* buf = ctx->getBufferData(target);
+
+    switch (pname) {
+        case GL_BUFFER_ACCESS_FLAGS:
+            *params = buf ? buf->m_mappedAccess : 0;
+            break;
+        case GL_BUFFER_MAPPED:
+            *params = buf ? (buf->m_mapped ? GL_TRUE : GL_FALSE) : GL_FALSE;
+            break;
+        case GL_BUFFER_SIZE:
+            *params = buf ? buf->m_size : 0;
+            break;
+        case GL_BUFFER_USAGE:
+            *params = buf ? buf->m_usage : GL_STATIC_DRAW;
+            break;
+        case GL_BUFFER_MAP_LENGTH:
+            *params = buf ? buf->m_mappedLength : 0;
+            break;
+        case GL_BUFFER_MAP_OFFSET:
+            *params = buf ? buf->m_mappedOffset : 0;
+            break;
+        default:
+            break;
+    }
+}
+
+void GL2Encoder::s_glGetBufferParameteri64v(void* self, GLenum target, GLenum pname, GLint64* params) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(
+        target != GL_ARRAY_BUFFER &&
+        target != GL_ELEMENT_ARRAY_BUFFER &&
+        target != GL_COPY_READ_BUFFER &&
+        target != GL_COPY_WRITE_BUFFER &&
+        target != GL_PIXEL_PACK_BUFFER &&
+        target != GL_PIXEL_UNPACK_BUFFER &&
+        target != GL_TRANSFORM_FEEDBACK_BUFFER &&
+        target != GL_UNIFORM_BUFFER,
+        GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::bufferParam(ctx, pname), GL_INVALID_ENUM);
+    SET_ERROR_IF(!ctx->boundBuffer(target), GL_INVALID_OPERATION);
+    SET_ERROR_IF(pname != GL_BUFFER_ACCESS_FLAGS &&
+                 pname != GL_BUFFER_MAPPED &&
+                 pname != GL_BUFFER_SIZE &&
+                 pname != GL_BUFFER_USAGE &&
+                 pname != GL_BUFFER_MAP_LENGTH &&
+                 pname != GL_BUFFER_MAP_OFFSET,
+                 GL_INVALID_ENUM);
+
+    if (!params) return;
+
+    BufferData* buf = ctx->getBufferData(target);
+
+    switch (pname) {
+        case GL_BUFFER_ACCESS_FLAGS:
+            *params = buf ? buf->m_mappedAccess : 0;
+            break;
+        case GL_BUFFER_MAPPED:
+            *params = buf ? (buf->m_mapped ? GL_TRUE : GL_FALSE) : GL_FALSE;
+            break;
+        case GL_BUFFER_SIZE:
+            *params = buf ? buf->m_size : 0;
+            break;
+        case GL_BUFFER_USAGE:
+            *params = buf ? buf->m_usage : GL_STATIC_DRAW;
+            break;
+        case GL_BUFFER_MAP_LENGTH:
+            *params = buf ? buf->m_mappedLength : 0;
+            break;
+        case GL_BUFFER_MAP_OFFSET:
+            *params = buf ? buf->m_mappedOffset : 0;
+            break;
+        default:
+            break;
+    }
+}
+
+void GL2Encoder::s_glGetBufferPointerv(void* self, GLenum target, GLenum pname, GLvoid** params) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    SET_ERROR_IF(!GLESv2Validation::bufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(
+        target == GL_ATOMIC_COUNTER_BUFFER ||
+        target == GL_DISPATCH_INDIRECT_BUFFER ||
+        target == GL_DRAW_INDIRECT_BUFFER ||
+        target == GL_SHADER_STORAGE_BUFFER,
+        GL_INVALID_ENUM);
+    SET_ERROR_IF(pname != GL_BUFFER_MAP_POINTER, GL_INVALID_ENUM);
+    SET_ERROR_IF(!ctx->boundBuffer(target), GL_INVALID_OPERATION);
+    if (!params) return;
+
+    BufferData* buf = ctx->getBufferData(target);
+
+    if (!buf || !buf->m_mapped) { *params = NULL; return; }
+
+    *params = (GLvoid*)((char*)buf->m_fixedBuffer.ptr() + buf->m_mappedOffset);
+}
+
+static const char* const kNameDelimiter = ";";
+
+static std::string packVarNames(GLsizei count, const char** names, GLint* err_out) {
+
+#define VALIDATE(cond, err) if (cond) { *err_out = err; return packed; } \
+
+    std::string packed;
+    // validate the array of char[]'s
+    const char* currName;
+    for (GLsizei i = 0; i < count; i++) {
+        currName = names[i];
+        VALIDATE(!currName, GL_INVALID_OPERATION);
+        // check if has reasonable size
+        size_t len = strlen(currName);
+        VALIDATE(!len, GL_INVALID_OPERATION);
+        // check for our delimiter, which if present
+        // in the name, means an invalid name anyway.
+        VALIDATE(strstr(currName, kNameDelimiter),
+                 GL_INVALID_OPERATION);
+        packed += currName;
+        packed += ";";
+    }
+
+    *err_out = GL_NO_ERROR;
+    return packed;
+}
+
+void GL2Encoder::s_glGetUniformIndices(void* self, GLuint program, GLsizei uniformCount, const GLchar ** uniformNames, GLuint* uniformIndices) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+
+    if (!uniformCount) return;
+
+    GLint err = GL_NO_ERROR;
+    std::string packed = packVarNames(uniformCount, (const char**)uniformNames, &err);
+    SET_ERROR_IF(err != GL_NO_ERROR, GL_INVALID_OPERATION);
+
+    bool needLocationWAR = ctx->m_shared->needUniformLocationWAR(program);
+    std::vector<int> arrIndices;
+    for (size_t i = 0; i < uniformCount; i++) {
+        int err;
+        arrIndices.push_back(sArrIndexOfUniformExpr(uniformNames[i], &err));
+        if (err) {
+            ALOGE("%s: invalid uniform name %s!", __FUNCTION__, uniformNames[i]);
+            return;
+        }
+    }
+
+    ctx->glGetUniformIndicesAEMU(ctx, program, uniformCount, (const GLchar*)&packed[0], packed.size() + 1, uniformIndices);
+
+    for (int i = 0; i < uniformCount; i++) {
+        if (uniformIndices[i] >= 0 && needLocationWAR) {
+            uniformIndices[i] =
+                ctx->m_shared->locationWARHostToApp(program, uniformIndices[i], arrIndices[i]);
+        }
+    }
+}
+
+void GL2Encoder::s_glUniform1ui(void* self, GLint location, GLuint v0) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    GLSharedGroupPtr shared = ctx->m_shared;
+
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform1ui_enc(self, hostLoc, v0);
+
+    GLenum target;
+    if (shared->setSamplerUniform(state->currentShaderProgram(), location, v0, &target)) {
+        GLenum origActiveTexture = state->getActiveTextureUnit();
+        if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + v0, target)) {
+            ctx->m_glActiveTexture_enc(self, origActiveTexture);
+        }
+        state->setActiveTextureUnit(origActiveTexture);
+    }
+}
+
+void GL2Encoder::s_glUniform2ui(void* self, GLint location, GLuint v0, GLuint v1) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform2ui_enc(self, hostLoc, v0, v1);
+}
+
+void GL2Encoder::s_glUniform3ui(void* self, GLint location, GLuint v0, GLuint v1, GLuint v2) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform3ui_enc(self, hostLoc, v0, v1, v2);
+}
+
+void GL2Encoder::s_glUniform4ui(void* self, GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform4ui_enc(self, hostLoc, v0, v1, v2, v3);
+}
+
+void GL2Encoder::s_glUniform1uiv(void* self, GLint location, GLsizei count, const GLuint *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform1uiv_enc(self, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glUniform2uiv(void* self, GLint location, GLsizei count, const GLuint *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform2uiv_enc(self, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glUniform3uiv(void* self, GLint location, GLsizei count, const GLuint *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform3uiv_enc(self, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glUniform4uiv(void* self, GLint location, GLsizei count, const GLuint *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniform4uiv_enc(self, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glUniformMatrix2x3fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniformMatrix2x3fv_enc(self, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glUniformMatrix3x2fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniformMatrix3x2fv_enc(self, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glUniformMatrix2x4fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniformMatrix2x4fv_enc(self, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glUniformMatrix4x2fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniformMatrix4x2fv_enc(self, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glUniformMatrix3x4fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniformMatrix3x4fv_enc(self, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glUniformMatrix4x3fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(ctx->m_state->currentShaderProgram(),location);
+    ctx->m_glUniformMatrix4x3fv_enc(self, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glGetUniformuiv(void* self, GLuint program, GLint location, GLuint* params) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    SET_ERROR_IF(!ctx->m_shared->isShaderOrProgramObject(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
+    SET_ERROR_IF(!ctx->m_shared->isProgramInitialized(program), GL_INVALID_OPERATION);
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    SET_ERROR_IF(ctx->m_shared->getProgramUniformType(program,hostLoc)==0, GL_INVALID_OPERATION);
+    ctx->m_glGetUniformuiv_enc(self, program, hostLoc, params);
+}
+
+void GL2Encoder::s_glGetActiveUniformBlockiv(void* self, GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    // refresh client state's # active uniforms in this block
+    if (pname == GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES) {
+        // TODO if worth it: cache uniform count and other params,
+        // invalidate on program relinking.
+        GLint numActiveUniforms;
+        ctx->m_glGetActiveUniformBlockiv_enc(ctx,
+                program, uniformBlockIndex,
+                GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS,
+                &numActiveUniforms);
+        ctx->m_state->setNumActiveUniformsInUniformBlock(
+                program, uniformBlockIndex, numActiveUniforms);
+    }
+
+    ctx->m_glGetActiveUniformBlockiv_enc(ctx,
+            program, uniformBlockIndex,
+            pname, params);
+}
+
+void GL2Encoder::s_glGetVertexAttribIiv(void* self, GLuint index, GLenum pname, GLint* params) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state);
+    GLint maxIndex;
+    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
+    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
+
+    if (!ctx->m_state->getVertexAttribParameter<GLint>(index, pname, params)) {
+        ctx->m_glGetVertexAttribIiv_enc(self, index, pname, params);
+    }
+}
+
+void GL2Encoder::s_glGetVertexAttribIuiv(void* self, GLuint index, GLenum pname, GLuint* params) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state);
+    GLint maxIndex;
+    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
+    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
+
+    if (!ctx->m_state->getVertexAttribParameter<GLuint>(index, pname, params)) {
+        ctx->m_glGetVertexAttribIuiv_enc(self, index, pname, params);
+    }
+}
+
+void GL2Encoder::s_glVertexAttribIPointer(void* self, GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state != NULL);
+    VALIDATE_VERTEX_ATTRIB_INDEX(index);
+    SET_ERROR_IF((size < 1 || size > 4), GL_INVALID_VALUE);
+    SET_ERROR_IF(
+        !(type == GL_BYTE ||
+          type == GL_UNSIGNED_BYTE ||
+          type == GL_SHORT ||
+          type == GL_UNSIGNED_SHORT ||
+          type == GL_INT ||
+          type == GL_UNSIGNED_INT),
+        GL_INVALID_ENUM);
+    SET_ERROR_IF(stride < 0, GL_INVALID_VALUE);
+
+    ctx->m_state->setVertexAttribBinding(index, index);
+    ctx->m_state->setVertexAttribFormat(index, size, type, false, 0, true);
+    GLsizei effectiveStride = stride;
+    if (stride == 0) {
+        effectiveStride = glSizeof(type) * size; 
+    }
+    ctx->m_state->bindIndexedBuffer(0, index, ctx->m_state->currentArrayVbo(), (uintptr_t)pointer, 0, stride, effectiveStride);
+
+    if (ctx->m_state->currentArrayVbo() != 0) {
+        ctx->glVertexAttribIPointerOffsetAEMU(ctx, index, size, type, stride, (uintptr_t)pointer);
+    } else {
+        SET_ERROR_IF(ctx->m_state->currentVertexArrayObject() != 0 && pointer, GL_INVALID_OPERATION);
+        // wait for client-array handler
+    }
+}
+
+void GL2Encoder::s_glVertexAttribDivisor(void* self, GLuint index, GLuint divisor) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state != NULL);
+    VALIDATE_VERTEX_ATTRIB_INDEX(index);
+    ctx->m_state->setVertexAttribBinding(index, index);
+    ctx->m_state->setVertexBindingDivisor(index, divisor);
+    ctx->m_glVertexAttribDivisor_enc(ctx, index, divisor);
+}
+
+void GL2Encoder::s_glRenderbufferStorageMultisample(void* self,
+        GLenum target, GLsizei samples, GLenum internalformat,
+        GLsizei width, GLsizei height) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(target != GL_RENDERBUFFER, GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::rboFormat(ctx, internalformat), GL_INVALID_ENUM);
+
+    GLint max_samples;
+    ctx->s_glGetInternalformativ(ctx, target, internalformat, GL_SAMPLES, 1, &max_samples);
+    SET_ERROR_IF(samples > max_samples, GL_INVALID_OPERATION);
+
+    state->setBoundRenderbufferFormat(internalformat);
+    state->setBoundRenderbufferSamples(samples);
+    ctx->m_glRenderbufferStorageMultisample_enc(
+            self, target, samples, internalformat, width, height);
+}
+
+void GL2Encoder::s_glDrawBuffers(void* self, GLsizei n, const GLenum* bufs) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    SET_ERROR_IF(!ctx->m_state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) && n > 1, GL_INVALID_OPERATION);
+    SET_ERROR_IF(n < 0 || n > ctx->m_state->getMaxDrawBuffers(), GL_INVALID_VALUE);
+    for (int i = 0; i < n; i++) {
+        SET_ERROR_IF(
+            bufs[i] != GL_NONE &&
+            bufs[i] != GL_BACK &&
+            glUtilsColorAttachmentIndex(bufs[i]) == -1,
+            GL_INVALID_ENUM);
+        SET_ERROR_IF(
+            !ctx->m_state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) &&
+            glUtilsColorAttachmentIndex(bufs[i]) != -1,
+            GL_INVALID_OPERATION);
+        SET_ERROR_IF(
+            ctx->m_state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) &&
+            ((glUtilsColorAttachmentIndex(bufs[i]) != -1 &&
+              glUtilsColorAttachmentIndex(bufs[i]) != i) ||
+             (glUtilsColorAttachmentIndex(bufs[i]) == -1 &&
+              bufs[i] != GL_NONE)),
+            GL_INVALID_OPERATION);
+    }
+
+    ctx->m_glDrawBuffers_enc(ctx, n, bufs);
+}
+
+void GL2Encoder::s_glReadBuffer(void* self, GLenum src) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+
+    SET_ERROR_IF(
+        glUtilsColorAttachmentIndex(src) != -1 &&
+         (glUtilsColorAttachmentIndex(src) >=
+         ctx->m_state->getMaxColorAttachments()),
+        GL_INVALID_OPERATION);
+    SET_ERROR_IF(
+        src != GL_NONE &&
+        src != GL_BACK &&
+        src > GL_COLOR_ATTACHMENT0 &&
+        src < GL_DEPTH_ATTACHMENT &&
+        (src - GL_COLOR_ATTACHMENT0) >
+        ctx->m_state->getMaxColorAttachments(),
+        GL_INVALID_OPERATION);
+    SET_ERROR_IF(
+        src != GL_NONE &&
+        src != GL_BACK &&
+        glUtilsColorAttachmentIndex(src) == -1,
+        GL_INVALID_ENUM);
+    SET_ERROR_IF(
+        !ctx->m_state->boundFramebuffer(GL_READ_FRAMEBUFFER) &&
+        src != GL_NONE &&
+        src != GL_BACK,
+        GL_INVALID_OPERATION);
+    SET_ERROR_IF(
+        ctx->m_state->boundFramebuffer(GL_READ_FRAMEBUFFER) &&
+        src != GL_NONE &&
+        glUtilsColorAttachmentIndex(src) == -1,
+        GL_INVALID_OPERATION);
+
+    ctx->m_glReadBuffer_enc(ctx, src);
+}
+
+void GL2Encoder::s_glFramebufferTextureLayer(void* self, GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::framebufferTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::framebufferAttachment(ctx, attachment), GL_INVALID_ENUM);
+    GLenum lastBoundTarget = state->queryTexLastBoundTarget(texture);
+    SET_ERROR_IF(lastBoundTarget != GL_TEXTURE_2D_ARRAY &&
+                 lastBoundTarget != GL_TEXTURE_3D,
+                 GL_INVALID_OPERATION);
+    state->attachTextureObject(target, attachment, texture);
+
+    GLint max3DTextureSize;
+    ctx->glGetIntegerv(ctx, GL_MAX_3D_TEXTURE_SIZE, &max3DTextureSize);
+    SET_ERROR_IF(
+            layer >= max3DTextureSize,
+            GL_INVALID_VALUE);
+
+    ctx->m_glFramebufferTextureLayer_enc(self, target, attachment, texture, level, layer);
+}
+
+void GL2Encoder::s_glTexStorage2D(void* self, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(
+        target != GL_TEXTURE_2D &&
+        target != GL_TEXTURE_CUBE_MAP,
+        GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelInternalFormat(internalformat), GL_INVALID_ENUM);
+    SET_ERROR_IF(!state->getBoundTexture(target), GL_INVALID_OPERATION);
+    SET_ERROR_IF(levels < 1 || width < 1 || height < 1, GL_INVALID_VALUE);
+    SET_ERROR_IF(levels > ilog2((uint32_t)std::max(width, height)) + 1,
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(state->isBoundTextureImmutableFormat(target), GL_INVALID_OPERATION);
+
+    state->setBoundTextureInternalFormat(target, internalformat);
+    state->setBoundTextureDims(target, -1, width, height, 1);
+    state->setBoundTextureImmutableFormat(target);
+    ctx->m_glTexStorage2D_enc(ctx, target, levels, internalformat, width, height);
+}
+
+void GL2Encoder::s_glTransformFeedbackVaryings(void* self, GLuint program, GLsizei count, const char** varyings, GLenum bufferMode) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+
+    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_VALUE);
+
+    GLint maxCount = 0;
+    ctx->glGetIntegerv(ctx, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, &maxCount);
+
+    SET_ERROR_IF(
+        bufferMode == GL_SEPARATE_ATTRIBS &&
+        maxCount < count,
+        GL_INVALID_VALUE);
+    SET_ERROR_IF(
+        bufferMode != GL_INTERLEAVED_ATTRIBS &&
+        bufferMode != GL_SEPARATE_ATTRIBS,
+        GL_INVALID_ENUM);
+
+    if (!count) return;
+
+    GLint err = GL_NO_ERROR;
+    std::string packed = packVarNames(count, varyings, &err);
+    SET_ERROR_IF(err != GL_NO_ERROR, GL_INVALID_OPERATION);
+
+    ctx->glTransformFeedbackVaryingsAEMU(ctx, program, count, (const char*)&packed[0], packed.size() + 1, bufferMode);
+}
+
+void GL2Encoder::s_glBeginTransformFeedback(void* self, GLenum primitiveMode) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    ctx->m_glBeginTransformFeedback_enc(ctx, primitiveMode);
+    state->setTransformFeedbackActiveUnpaused(true);
+}
+
+void GL2Encoder::s_glEndTransformFeedback(void* self) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    ctx->m_glEndTransformFeedback_enc(ctx);
+    state->setTransformFeedbackActiveUnpaused(false);
+}
+
+void GL2Encoder::s_glPauseTransformFeedback(void* self) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    ctx->m_glPauseTransformFeedback_enc(ctx);
+    state->setTransformFeedbackActiveUnpaused(false);
+}
+
+void GL2Encoder::s_glResumeTransformFeedback(void* self) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    ctx->m_glResumeTransformFeedback_enc(ctx);
+    state->setTransformFeedbackActiveUnpaused(true);
+}
+
+void GL2Encoder::s_glTexImage3D(void* self, GLenum target, GLint level, GLint internalFormat,
+                               GLsizei width, GLsizei height, GLsizei depth,
+                               GLint border, GLenum format, GLenum type, const GLvoid* data) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(target != GL_TEXTURE_3D &&
+                 target != GL_TEXTURE_2D_ARRAY,
+                 GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelType(ctx, type), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelFormat(ctx, format), GL_INVALID_ENUM);
+
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+
+    GLint max_texture_size;
+    GLint max_3d_texture_size;
+    ctx->glGetIntegerv(ctx, GL_MAX_TEXTURE_SIZE, &max_texture_size);
+    ctx->glGetIntegerv(ctx, GL_MAX_3D_TEXTURE_SIZE, &max_3d_texture_size);
+    SET_ERROR_IF(level < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_3d_texture_size), GL_INVALID_VALUE);
+
+    SET_ERROR_IF(width < 0 || height < 0 || depth < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(width > GL_MAX_TEXTURE_SIZE, GL_INVALID_VALUE);
+    SET_ERROR_IF(height > GL_MAX_TEXTURE_SIZE, GL_INVALID_VALUE);
+    SET_ERROR_IF(depth > GL_MAX_TEXTURE_SIZE, GL_INVALID_VALUE);
+    SET_ERROR_IF(width > GL_MAX_3D_TEXTURE_SIZE, GL_INVALID_VALUE);
+    SET_ERROR_IF(height > GL_MAX_3D_TEXTURE_SIZE, GL_INVALID_VALUE);
+    SET_ERROR_IF(depth > GL_MAX_3D_TEXTURE_SIZE, GL_INVALID_VALUE);
+    SET_ERROR_IF(border != 0, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits and is evenly divisible by the type.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->m_state->pboNeededDataSize(width, height, depth, format, type, 0) >
+                  ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size %
+                  glSizeof(type)),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(state->isBoundTextureImmutableFormat(target), GL_INVALID_OPERATION);
+
+    state->setBoundTextureInternalFormat(target, internalFormat);
+    state->setBoundTextureFormat(target, format);
+    state->setBoundTextureType(target, type);
+    state->setBoundTextureDims(target, level, width, height, depth);
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glTexImage3DOffsetAEMU(
+                ctx, target, level, internalFormat,
+                width, height, depth,
+                border, format, type, (uintptr_t)data);
+    } else {
+        ctx->m_glTexImage3D_enc(ctx,
+                target, level, internalFormat,
+                width, height, depth,
+                border, format, type, data);
+    }
+}
+
+void GL2Encoder::s_glTexSubImage3D(void* self, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(target != GL_TEXTURE_3D &&
+                 target != GL_TEXTURE_2D_ARRAY,
+                 GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelType(ctx, type), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelFormat(ctx, format), GL_INVALID_ENUM);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+    GLint max_texture_size;
+    GLint max_3d_texture_size;
+    ctx->glGetIntegerv(ctx, GL_MAX_TEXTURE_SIZE, &max_texture_size);
+    ctx->glGetIntegerv(ctx, GL_MAX_3D_TEXTURE_SIZE, &max_3d_texture_size);
+    SET_ERROR_IF(level < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(level > ilog2(max_3d_texture_size), GL_INVALID_VALUE);
+    SET_ERROR_IF(width < 0 || height < 0 || depth < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(xoffset < 0 || yoffset < 0 || zoffset < 0, GL_INVALID_VALUE);
+    GLuint tex = state->getBoundTexture(target);
+    GLsizei neededWidth = xoffset + width;
+    GLsizei neededHeight = yoffset + height;
+    GLsizei neededDepth = zoffset + depth;
+
+    SET_ERROR_IF(tex &&
+                 (neededWidth > state->queryTexWidth(level, tex) ||
+                  neededHeight > state->queryTexHeight(level, tex) ||
+                  neededDepth > state->queryTexDepth(level, tex)),
+                 GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits and is evenly divisible by the type.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->m_state->pboNeededDataSize(width, height, depth, format, type, 0) >
+                  ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size %
+                  glSizeof(type)),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(!ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) && !data, GL_INVALID_OPERATION);
+    SET_ERROR_IF(xoffset < 0 || yoffset < 0 || zoffset < 0, GL_INVALID_VALUE);
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glTexSubImage3DOffsetAEMU(ctx,
+                target, level,
+                xoffset, yoffset, zoffset,
+                width, height, depth,
+                format, type, (uintptr_t)data);
+    } else {
+        ctx->m_glTexSubImage3D_enc(ctx,
+                target, level,
+                xoffset, yoffset, zoffset,
+                width, height, depth,
+                format, type, data);
+    }
+}
+
+void GL2Encoder::s_glCompressedTexImage3D(void* self, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    // Filter compressed formats support.
+    SET_ERROR_IF(!GLESv2Validation::supportedCompressedFormat(ctx, internalformat), GL_INVALID_ENUM);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+    SET_ERROR_IF(width < 0 || height < 0 || depth < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(border, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (imageSize > ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    // TODO: Fix:
+    // If |imageSize| is too small for compressed dimensions.
+    // SET_ERROR_IF(GLESv2Validation::compressedTexImageSize(internalformat, width, height, depth) > imageSize, GL_INVALID_VALUE);
+    state->setBoundTextureInternalFormat(target, (GLint)internalformat);
+    state->setBoundTextureDims(target, level, width, height, depth);
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glCompressedTexImage3DOffsetAEMU(
+                ctx, target, level, internalformat,
+                width, height, depth, border,
+                imageSize, (uintptr_t)data);
+    } else {
+        ctx->m_glCompressedTexImage3D_enc(
+                ctx, target, level, internalformat,
+                width, height, depth, border,
+                imageSize, data);
+    }
+}
+
+void GL2Encoder::s_glCompressedTexSubImage3D(void* self, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!GLESv2Validation::textureTarget(ctx, target), GL_INVALID_ENUM);
+    // If unpack buffer is nonzero, verify unmapped state.
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_UNPACK_BUFFER), GL_INVALID_OPERATION);
+    SET_ERROR_IF(width < 0 || height < 0 || depth < 0, GL_INVALID_VALUE);
+    // If unpack buffer is nonzero, verify buffer data fits.
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER) &&
+                 (imageSize > ctx->getBufferData(GL_PIXEL_UNPACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(xoffset < 0 || yoffset < 0 || zoffset < 0, GL_INVALID_VALUE);
+
+    if (ctx->boundBuffer(GL_PIXEL_UNPACK_BUFFER)) {
+        ctx->glCompressedTexSubImage3DOffsetAEMU(
+                ctx, target, level,
+                xoffset, yoffset, zoffset,
+                width, height, depth,
+                format, imageSize, (uintptr_t)data);
+    } else {
+        ctx->m_glCompressedTexSubImage3D_enc(
+                ctx, target, level,
+                xoffset, yoffset, zoffset,
+                width, height, depth,
+                format, imageSize, data);
+
+    }
+}
+
+void GL2Encoder::s_glTexStorage3D(void* self, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    SET_ERROR_IF(target != GL_TEXTURE_3D &&
+                 target != GL_TEXTURE_2D_ARRAY,
+                 GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelInternalFormat(internalformat), GL_INVALID_ENUM);
+    SET_ERROR_IF(!state->getBoundTexture(target), GL_INVALID_OPERATION);
+    SET_ERROR_IF(levels < 1 || width < 1 || height < 1, GL_INVALID_VALUE);
+    SET_ERROR_IF(target == GL_TEXTURE_3D && (levels > ilog2((uint32_t)std::max(width, std::max(height, depth))) + 1),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(target == GL_TEXTURE_2D_ARRAY && (levels > ilog2((uint32_t)std::max(width, height)) + 1),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(state->isBoundTextureImmutableFormat(target), GL_INVALID_OPERATION);
+
+    state->setBoundTextureInternalFormat(target, internalformat);
+    state->setBoundTextureDims(target, -1, width, height, depth);
+    state->setBoundTextureImmutableFormat(target);
+    ctx->m_glTexStorage3D_enc(ctx, target, levels, internalformat, width, height, depth);
+    state->setBoundTextureImmutableFormat(target);
+}
+
+void GL2Encoder::s_glDrawArraysInstanced(void* self, GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state != NULL);
+    SET_ERROR_IF(!isValidDrawMode(mode), GL_INVALID_ENUM);
+    SET_ERROR_IF(count < 0, GL_INVALID_VALUE);
+
+    bool has_client_vertex_arrays = false;
+    bool has_indirect_arrays = false;
+    ctx->getVBOUsage(&has_client_vertex_arrays,
+                     &has_indirect_arrays);
+
+    if (has_client_vertex_arrays ||
+        (!has_client_vertex_arrays &&
+         !has_indirect_arrays)) {
+        ctx->sendVertexAttributes(first, count, true, primcount);
+        ctx->m_glDrawArraysInstanced_enc(ctx, mode, 0, count, primcount);
+    } else {
+        ctx->sendVertexAttributes(0, count, false, primcount);
+        ctx->m_glDrawArraysInstanced_enc(ctx, mode, first, count, primcount);
+    }
+    ctx->m_stream->flush();
+}
+
+void GL2Encoder::s_glDrawElementsInstanced(void* self, GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount)
+{
+
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state != NULL);
+    SET_ERROR_IF(!isValidDrawMode(mode), GL_INVALID_ENUM);
+    SET_ERROR_IF(count < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(!(type == GL_UNSIGNED_BYTE || type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT), GL_INVALID_ENUM);
+    SET_ERROR_IF(ctx->m_state->getTransformFeedbackActiveUnpaused(), GL_INVALID_OPERATION);
+
+    bool has_client_vertex_arrays = false;
+    bool has_indirect_arrays = false;
+    int nLocations = ctx->m_state->nLocations();
+    GLintptr offset = 0;
+
+    ctx->getVBOUsage(&has_client_vertex_arrays, &has_indirect_arrays);
+
+    if (!has_client_vertex_arrays && !has_indirect_arrays) {
+        // ALOGW("glDrawElements: no vertex arrays / buffers bound to the command\n");
+        GLenum status = ctx->m_glCheckFramebufferStatus_enc(self, GL_FRAMEBUFFER);
+        SET_ERROR_IF(status != GL_FRAMEBUFFER_COMPLETE, GL_INVALID_FRAMEBUFFER_OPERATION);
+    }
+
+    BufferData* buf = NULL;
+    int minIndex = 0, maxIndex = 0;
+
+    // For validation/immediate index array purposes,
+    // we need the min/max vertex index of the index array.
+    // If the VBO != 0, this may not be the first time we have
+    // used this particular index buffer. getBufferIndexRange
+    // can more quickly get min/max vertex index by
+    // caching previous results.
+    if (ctx->m_state->currentIndexVbo() != 0) {
+        buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
+        offset = (GLintptr)indices;
+        indices = (void*)((GLintptr)buf->m_fixedBuffer.ptr() + (GLintptr)indices);
+        ctx->getBufferIndexRange(buf,
+                                 indices,
+                                 type,
+                                 (size_t)count,
+                                 (size_t)offset,
+                                 &minIndex, &maxIndex);
+    } else {
+        // In this case, the |indices| field holds a real
+        // array, so calculate the indices now. They will
+        // also be needed to know how much data to
+        // transfer to host.
+        ctx->calcIndexRange(indices,
+                            type,
+                            count,
+                            &minIndex,
+                            &maxIndex);
+    }
+
+    bool adjustIndices = true;
+    if (ctx->m_state->currentIndexVbo() != 0) {
+        if (!has_client_vertex_arrays) {
+            ctx->sendVertexAttributes(0, maxIndex + 1, false, primcount);
+            ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, ctx->m_state->currentIndexVbo());
+            ctx->glDrawElementsInstancedOffsetAEMU(ctx, mode, count, type, offset, primcount);
+            ctx->flushDrawCall();
+            adjustIndices = false;
+        } else {
+            BufferData * buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
+            ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, 0);
+        }
+    }
+    if (adjustIndices) {
+        void *adjustedIndices =
+            ctx->recenterIndices(indices,
+                                 type,
+                                 count,
+                                 minIndex);
+
+        if (has_indirect_arrays || 1) {
+            ctx->sendVertexAttributes(minIndex, maxIndex - minIndex + 1, true, primcount);
+            ctx->glDrawElementsInstancedDataAEMU(ctx, mode, count, type, adjustedIndices, primcount, count * glSizeof(type));
+            ctx->m_stream->flush();
+            // XXX - OPTIMIZATION (see the other else branch) should be implemented
+            if(!has_indirect_arrays) {
+                //ALOGD("unoptimized drawelements !!!\n");
+            }
+        } else {
+            // we are all direct arrays and immidate mode index array -
+            // rebuild the arrays and the index array;
+            ALOGE("glDrawElements: direct index & direct buffer data - will be implemented in later versions;\n");
+        }
+    }
+}
+
+void GL2Encoder::s_glDrawRangeElements(void* self, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices)
+{
+
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert(ctx->m_state != NULL);
+    SET_ERROR_IF(!isValidDrawMode(mode), GL_INVALID_ENUM);
+    SET_ERROR_IF(end < start, GL_INVALID_VALUE);
+    SET_ERROR_IF(count < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(!(type == GL_UNSIGNED_BYTE || type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT), GL_INVALID_ENUM);
+    SET_ERROR_IF(ctx->m_state->getTransformFeedbackActiveUnpaused(), GL_INVALID_OPERATION);
+
+    bool has_client_vertex_arrays = false;
+    bool has_indirect_arrays = false;
+    int nLocations = ctx->m_state->nLocations();
+    GLintptr offset = 0;
+
+    ctx->getVBOUsage(&has_client_vertex_arrays, &has_indirect_arrays);
+
+    if (!has_client_vertex_arrays && !has_indirect_arrays) {
+        // ALOGW("glDrawElements: no vertex arrays / buffers bound to the command\n");
+        GLenum status = ctx->m_glCheckFramebufferStatus_enc(self, GL_FRAMEBUFFER);
+        SET_ERROR_IF(status != GL_FRAMEBUFFER_COMPLETE, GL_INVALID_FRAMEBUFFER_OPERATION);
+    }
+
+    BufferData* buf = NULL;
+    int minIndex = 0, maxIndex = 0;
+
+    // For validation/immediate index array purposes,
+    // we need the min/max vertex index of the index array.
+    // If the VBO != 0, this may not be the first time we have
+    // used this particular index buffer. getBufferIndexRange
+    // can more quickly get min/max vertex index by
+    // caching previous results.
+    if (ctx->m_state->currentIndexVbo() != 0) {
+        buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
+        offset = (GLintptr)indices;
+        indices = (void*)((GLintptr)buf->m_fixedBuffer.ptr() + (GLintptr)indices);
+        ctx->getBufferIndexRange(buf,
+                                 indices,
+                                 type,
+                                 (size_t)count,
+                                 (size_t)offset,
+                                 &minIndex, &maxIndex);
+    } else {
+        // In this case, the |indices| field holds a real
+        // array, so calculate the indices now. They will
+        // also be needed to know how much data to
+        // transfer to host.
+        ctx->calcIndexRange(indices,
+                            type,
+                            count,
+                            &minIndex,
+                            &maxIndex);
+    }
+
+    bool adjustIndices = true;
+    if (ctx->m_state->currentIndexVbo() != 0) {
+        if (!has_client_vertex_arrays) {
+            ctx->sendVertexAttributes(0, maxIndex + 1, false);
+            ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, ctx->m_state->currentIndexVbo());
+            ctx->glDrawElementsOffset(ctx, mode, count, type, offset);
+            ctx->flushDrawCall();
+            adjustIndices = false;
+        } else {
+            BufferData * buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
+            ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, 0);
+        }
+    }
+    if (adjustIndices) {
+        void *adjustedIndices =
+            ctx->recenterIndices(indices,
+                                 type,
+                                 count,
+                                 minIndex);
+
+        if (has_indirect_arrays || 1) {
+            ctx->sendVertexAttributes(minIndex, maxIndex - minIndex + 1, true);
+            ctx->glDrawElementsData(ctx, mode, count, type, adjustedIndices, count * glSizeof(type));
+            ctx->m_stream->flush();
+            // XXX - OPTIMIZATION (see the other else branch) should be implemented
+            if(!has_indirect_arrays) {
+                //ALOGD("unoptimized drawelements !!!\n");
+            }
+        } else {
+            // we are all direct arrays and immidate mode index array -
+            // rebuild the arrays and the index array;
+            ALOGE("glDrawElements: direct index & direct buffer data - will be implemented in later versions;\n");
+        }
+    }
+}
+
+// struct GLStringKey {
+//     GLenum name;
+//     GLuint index;
+// };
+// 
+// struct GLStringKeyCompare {
+//     bool operator() (const GLStringKey& a,
+//                      const GLStringKey& b) const {
+//         if (a.name != b.name) return a.name < b.name;
+//         if (a.index != b.index) return a.index < b.index;
+//         return false;
+//     }
+// };
+// 
+// typedef std::map<GLStringKey, std::string, GLStringKeyCompare> GLStringStore;
+// 
+// static GLStringStore sGLStringStore;
+// bool sGLStringStoreInitialized = false;
+
+const GLubyte* GL2Encoder::s_glGetStringi(void* self, GLenum name, GLuint index) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLubyte *retval =  (GLubyte *) "";
+
+    RET_AND_SET_ERROR_IF(
+        name != GL_VENDOR &&
+        name != GL_RENDERER &&
+        name != GL_VERSION &&
+        name != GL_EXTENSIONS,
+        GL_INVALID_ENUM,
+        retval);
+
+    RET_AND_SET_ERROR_IF(
+        name == GL_VENDOR ||
+        name == GL_RENDERER ||
+        name == GL_VERSION ||
+        name == GL_EXTENSIONS &&
+        index != 0,
+        GL_INVALID_VALUE,
+        retval);
+
+    switch (name) {
+    case GL_VENDOR:
+        retval = gVendorString;
+        break;
+    case GL_RENDERER:
+        retval = gRendererString;
+        break;
+    case GL_VERSION:
+        retval = gVersionString;
+        break;
+    case GL_EXTENSIONS:
+        retval = gExtensionsString;
+        break;
+    }
+
+    return retval;
+}
+
+void GL2Encoder::s_glGetProgramBinary(void* self, GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
+
+    GLint linkStatus = 0;
+    ctx->glGetProgramiv(self, program, GL_LINK_STATUS, &linkStatus);
+    GLint properLength = 0;
+    ctx->glGetProgramiv(self, program, GL_PROGRAM_BINARY_LENGTH, &properLength);
+
+    SET_ERROR_IF(!linkStatus, GL_INVALID_OPERATION);
+    SET_ERROR_IF(bufSize < properLength, GL_INVALID_OPERATION);
+
+    ctx->m_glGetProgramBinary_enc(ctx, program, bufSize, length, binaryFormat, binary);
+}
+
+void GL2Encoder::s_glReadPixels(void* self, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(!GLESv2Validation::readPixelsFormat(format), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::readPixelsType(type), GL_INVALID_ENUM);
+    SET_ERROR_IF(width < 0 || height < 0, GL_INVALID_VALUE);
+    SET_ERROR_IF(ctx->isBufferTargetMapped(GL_PIXEL_PACK_BUFFER), GL_INVALID_OPERATION);
+    SET_ERROR_IF(ctx->boundBuffer(GL_PIXEL_PACK_BUFFER) &&
+                 ctx->getBufferData(GL_PIXEL_PACK_BUFFER) &&
+                 (ctx->m_state->pboNeededDataSize(width, height, 1, format, type, 1) >
+                  ctx->getBufferData(GL_PIXEL_PACK_BUFFER)->m_size),
+                 GL_INVALID_OPERATION);
+    /*
+GL_INVALID_OPERATION is generated if the readbuffer of the currently bound framebuffer is a fixed point normalized surface and format and type are neither GL_RGBA and GL_UNSIGNED_BYTE, respectively, nor the format/type pair returned by querying GL_IMPLEMENTATION_COLOR_READ_FORMAT and GL_IMPLEMENTATION_COLOR_READ_TYPE.
+
+GL_INVALID_OPERATION is generated if the readbuffer of the currently bound framebuffer is a floating point surface and format and type are neither GL_RGBA and GL_FLOAT, respectively, nor the format/type pair returned by querying GL_IMPLEMENTATION_COLOR_READ_FORMAT and GL_IMPLEMENTATION_COLOR_READ_TYPE.
+
+GL_INVALID_OPERATION is generated if the readbuffer of the currently bound framebuffer is a signed integer surface and format and type are neither GL_RGBA_INTEGER and GL_INT, respectively, nor the format/type pair returned by querying GL_IMPLEMENTATION_COLOR_READ_FORMAT and GL_IMPLEMENTATION_COLOR_READ_TYPE.
+
+GL_INVALID_OPERATION is generated if the readbuffer of the currently bound framebuffer is an unsigned integer surface and format and type are neither GL_RGBA_INTEGER and GL_UNSIGNED_INT, respectively, nor the format/type pair returned by querying GL_IMPLEMENTATION_COLOR_READ_FORMAT and GL_IMPLEMENTATION_COLOR_READ_TYPE.
+*/
+
+    FboFormatInfo fbo_format_info;
+    ctx->m_state->getBoundFramebufferFormat(
+            GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, &fbo_format_info);
+    SET_ERROR_IF(
+        fbo_format_info.type == FBO_ATTACHMENT_TEXTURE &&
+        !GLESv2Validation::readPixelsFboFormatMatch(
+            format, type, fbo_format_info.tex_type),
+        GL_INVALID_OPERATION);
+
+    if (ctx->boundBuffer(GL_PIXEL_PACK_BUFFER)) {
+        ctx->glReadPixelsOffsetAEMU(
+                ctx, x, y, width, height,
+                format, type, (uintptr_t)pixels);
+    } else {
+        ctx->m_glReadPixels_enc(
+                ctx, x, y, width, height,
+                format, type, pixels);
+    }
+}
+
+// Track enabled state for some things like:
+// - Primitive restart
+void GL2Encoder::s_glEnable(void* self, GLenum what) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    switch (what) {
+    case GL_PRIMITIVE_RESTART_FIXED_INDEX:
+        ctx->m_primitiveRestartEnabled = true;
+        break;
+    }
+
+    ctx->m_glEnable_enc(ctx, what);
+}
+
+void GL2Encoder::s_glDisable(void* self, GLenum what) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    switch (what) {
+    case GL_PRIMITIVE_RESTART_FIXED_INDEX:
+        ctx->m_primitiveRestartEnabled = false;
+        break;
+    }
+
+    ctx->m_glDisable_enc(ctx, what);
+}
+
+void GL2Encoder::s_glClearBufferiv(void* self, GLenum buffer, GLint drawBuffer, const GLint * value) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(buffer == GL_DEPTH || buffer == GL_DEPTH_STENCIL, GL_INVALID_ENUM);
+
+    ctx->m_glClearBufferiv_enc(ctx, buffer, drawBuffer, value);
+}
+
+void GL2Encoder::s_glClearBufferuiv(void* self, GLenum buffer, GLint drawBuffer, const GLuint * value) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(buffer == GL_DEPTH || buffer == GL_STENCIL || buffer == GL_DEPTH_STENCIL, GL_INVALID_ENUM);
+
+    ctx->m_glClearBufferuiv_enc(ctx, buffer, drawBuffer, value);
+}
+
+void GL2Encoder::s_glClearBufferfv(void* self, GLenum buffer, GLint drawBuffer, const GLfloat * value) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(buffer == GL_STENCIL || buffer == GL_DEPTH_STENCIL, GL_INVALID_ENUM);
+
+    ctx->m_glClearBufferfv_enc(ctx, buffer, drawBuffer, value);
+}
+
+void GL2Encoder::s_glBlitFramebuffer(void* self, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLClientState* state = ctx->m_state;
+
+    bool validateColor = mask | GL_COLOR_BUFFER_BIT;
+    bool validateDepth = mask | GL_DEPTH_BUFFER_BIT;
+    bool validateStencil = mask | GL_STENCIL_BUFFER_BIT;
+
+    FboFormatInfo read_fbo_format_info;
+    FboFormatInfo draw_fbo_format_info;
+    if (validateColor) {
+        state->getBoundFramebufferFormat(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, &read_fbo_format_info);
+        state->getBoundFramebufferFormat(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, &draw_fbo_format_info);
+
+        if (read_fbo_format_info.type == FBO_ATTACHMENT_TEXTURE &&
+            draw_fbo_format_info.type == FBO_ATTACHMENT_TEXTURE) {
+            SET_ERROR_IF(
+                    state->boundFramebuffer(GL_READ_FRAMEBUFFER) &&
+                    state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) &&
+                    !GLESv2Validation::blitFramebufferFormat(
+                        read_fbo_format_info.tex_type,
+                        draw_fbo_format_info.tex_type),
+                    GL_INVALID_OPERATION);
+        }
+    }
+
+    if (validateDepth) {
+        state->getBoundFramebufferFormat(GL_READ_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, &read_fbo_format_info);
+        state->getBoundFramebufferFormat(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, &draw_fbo_format_info);
+
+        if (read_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            draw_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER) {
+            SET_ERROR_IF(
+                    state->boundFramebuffer(GL_READ_FRAMEBUFFER) &&
+                    state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) &&
+                    !GLESv2Validation::blitFramebufferFormat(
+                        read_fbo_format_info.rb_format,
+                        draw_fbo_format_info.rb_format),
+                    GL_INVALID_OPERATION);
+        }
+    }
+
+    if (validateStencil) {
+        state->getBoundFramebufferFormat(GL_READ_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, &read_fbo_format_info);
+        state->getBoundFramebufferFormat(GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, &draw_fbo_format_info);
+
+        if (read_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            draw_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER) {
+            SET_ERROR_IF(
+                    state->boundFramebuffer(GL_READ_FRAMEBUFFER) &&
+                    state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) &&
+                    !GLESv2Validation::blitFramebufferFormat(
+                        read_fbo_format_info.rb_format,
+                        draw_fbo_format_info.rb_format),
+                    GL_INVALID_OPERATION);
+        }
+    }
+
+    state->getBoundFramebufferFormat(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, &draw_fbo_format_info);
+    SET_ERROR_IF(
+            draw_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            draw_fbo_format_info.rb_multisamples > 0,
+            GL_INVALID_OPERATION);
+    SET_ERROR_IF(
+            draw_fbo_format_info.type == FBO_ATTACHMENT_TEXTURE &&
+            draw_fbo_format_info.tex_multisamples > 0,
+            GL_INVALID_OPERATION);
+
+    state->getBoundFramebufferFormat(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, &read_fbo_format_info);
+    SET_ERROR_IF(
+            read_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            read_fbo_format_info.rb_multisamples > 0 &&
+            draw_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            state->boundFramebuffer(GL_READ_FRAMEBUFFER) &&
+            state->boundFramebuffer(GL_DRAW_FRAMEBUFFER) &&
+            (read_fbo_format_info.rb_format !=
+             draw_fbo_format_info.rb_format),
+            GL_INVALID_OPERATION);
+    SET_ERROR_IF(
+            read_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            read_fbo_format_info.rb_multisamples > 0 &&
+            draw_fbo_format_info.type == FBO_ATTACHMENT_RENDERBUFFER &&
+            (srcX0 != dstX0 || srcY0 != dstY0 ||
+             srcX1 != dstX1 || srcY1 != dstY1),
+            GL_INVALID_OPERATION);
+
+	ctx->m_glBlitFramebuffer_enc(ctx,
+            srcX0, srcY0, srcX1, srcY1,
+            dstX0, dstY0, dstX1, dstY1,
+            mask, filter);
+}
+
+void GL2Encoder::s_glGetInternalformativ(void* self, GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(pname != GL_NUM_SAMPLE_COUNTS &&
+                 pname != GL_SAMPLES,
+                 GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::internalFormatTarget(ctx, target), GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::unsizedFormat(internalformat) &&
+                 !GLESv2Validation::colorRenderableFormat(ctx, internalformat) &&
+                 !GLESv2Validation::depthRenderableFormat(ctx, internalformat) &&
+                 !GLESv2Validation::stencilRenderableFormat(ctx, internalformat),
+                 GL_INVALID_ENUM);
+    SET_ERROR_IF(bufSize < 0, GL_INVALID_VALUE);
+
+    if (bufSize < 1) return;
+
+    // Desktop OpenGL can allow a mindboggling # samples per pixel (such as 64).
+    // Limit to 4 (spec minimum) to keep dEQP tests from timing out.
+    switch (pname) {
+        case GL_NUM_SAMPLE_COUNTS:
+            *params = 3;
+            break;
+        case GL_SAMPLES:
+            params[0] = 4;
+            if (bufSize > 1) params[1] = 2;
+            if (bufSize > 2) params[2] = 1;
+            break;
+        default:
+            break;
+    }
+}
+
+void GL2Encoder::s_glGenerateMipmap(void* self, GLenum target) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(target != GL_TEXTURE_2D &&
+                 target != GL_TEXTURE_3D &&
+                 target != GL_TEXTURE_CUBE_MAP,
+                 GL_INVALID_ENUM);
+
+    GLuint tex = state->getBoundTexture(target);
+    GLenum internalformat = state->queryTexInternalFormat(tex);
+    GLenum format = state->queryTexFormat(tex);
+
+    SET_ERROR_IF(tex && GLESv2Validation::isCompressedFormat(internalformat),
+                 GL_INVALID_OPERATION);
+    SET_ERROR_IF(tex &&
+                 !GLESv2Validation::unsizedFormat(internalformat) &&
+                 !(GLESv2Validation::colorRenderableFormat(ctx, internalformat) &&
+                   GLESv2Validation::filterableTexFormat(ctx, internalformat)),
+                 GL_INVALID_OPERATION);
+
+    ctx->m_glGenerateMipmap_enc(ctx, target);
+}
+
+void GL2Encoder::s_glBindSampler(void* self, GLuint unit, GLuint sampler) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLint maxCombinedUnits;
+    ctx->glGetIntegerv(ctx, GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &maxCombinedUnits);
+    SET_ERROR_IF(unit >= maxCombinedUnits, GL_INVALID_VALUE);
+
+    ctx->m_glBindSampler_enc(ctx, unit, sampler);
+}
+
+GLsync GL2Encoder::s_glFenceSync(void* self, GLenum condition, GLbitfield flags) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    uint64_t syncHandle = ctx->glFenceSyncAEMU(ctx, condition, flags);
+    return (GLsync)(uintptr_t)syncHandle;
+}
+
+GLenum GL2Encoder::s_glClientWaitSync(void* self, GLsync wait_on, GLbitfield flags, GLuint64 timeout) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    return ctx->glClientWaitSyncAEMU(ctx, (uint64_t)(uintptr_t)wait_on, flags, timeout);
+}
+
+void GL2Encoder::s_glWaitSync(void* self, GLsync wait_on, GLbitfield flags, GLuint64 timeout) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    ctx->glWaitSyncAEMU(ctx, (uint64_t)(uintptr_t)wait_on, flags, timeout);
+}
+
+void GL2Encoder::s_glDeleteSync(void* self, GLsync sync) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    if (!sync) return;
+
+    ctx->glDeleteSyncAEMU(ctx, (uint64_t)(uintptr_t)sync);
+}
+
+GLboolean GL2Encoder::s_glIsSync(void* self, GLsync sync) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    return ctx->glIsSyncAEMU(ctx, (uint64_t)(uintptr_t)sync);
+}
+
+void GL2Encoder::s_glGetSynciv(void* self, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+
+    SET_ERROR_IF(bufSize < 0, GL_INVALID_VALUE);
+
+    return ctx->glGetSyncivAEMU(ctx, (uint64_t)(uintptr_t)sync, pname, bufSize, length, values);
+}
+
+#define LIMIT_CASE(target, lim) \
+    case target: \
+        ctx->glGetIntegerv(ctx, lim, &limit); \
+        SET_ERROR_IF(index < 0 || index >= limit, GL_INVALID_VALUE); \
+        break; \
+
+void GL2Encoder::s_glGetIntegeri_v(void* self, GLenum target, GLuint index, GLint* params) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLClientState* state = ctx->m_state;
+
+    GLint limit;
+
+    switch (target) {
+    LIMIT_CASE(GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS)
+    LIMIT_CASE(GL_UNIFORM_BUFFER_BINDING, GL_MAX_UNIFORM_BUFFER_BINDINGS)
+    LIMIT_CASE(GL_ATOMIC_COUNTER_BUFFER_BINDING, GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS)
+    LIMIT_CASE(GL_SHADER_STORAGE_BUFFER_BINDING, GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS)
+    default:
+        break;
+    }
+
+    const GLClientState::VertexAttribBindingVector& currBindings =
+        state->currentVertexBufferBindings();
+
+    switch (target) {
+    case GL_VERTEX_BINDING_DIVISOR:
+    case GL_VERTEX_BINDING_OFFSET:
+    case GL_VERTEX_BINDING_STRIDE:
+    case GL_VERTEX_BINDING_BUFFER:
+        SET_ERROR_IF(index < 0 || index > currBindings.size(), GL_INVALID_VALUE);
+        break;
+    default:
+        break;
+    }
+
+    switch (target) {
+    case GL_VERTEX_BINDING_DIVISOR:
+        *params = currBindings[index].divisor;
+        return;
+    case GL_VERTEX_BINDING_OFFSET:
+        *params = currBindings[index].offset;
+        return;
+    case GL_VERTEX_BINDING_STRIDE:
+        *params = currBindings[index].effectiveStride;
+        return;
+    case GL_VERTEX_BINDING_BUFFER:
+        *params = currBindings[index].buffer;
+        return;
+    default:
+        break;
+    }
+
+    ctx->m_glGetIntegeri_v_enc(self, target, index, params);
+}
+
+void GL2Encoder::s_glGetInteger64i_v(void* self, GLenum target, GLuint index, GLint64* params) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    GLClientState* state = ctx->m_state;
+
+    GLint limit;
+
+    switch (target) {
+    LIMIT_CASE(GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS)
+    LIMIT_CASE(GL_UNIFORM_BUFFER_BINDING, GL_MAX_UNIFORM_BUFFER_BINDINGS)
+    LIMIT_CASE(GL_ATOMIC_COUNTER_BUFFER_BINDING, GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS)
+    LIMIT_CASE(GL_SHADER_STORAGE_BUFFER_BINDING, GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS)
+    default:
+        break;
+    }
+
+    const GLClientState::VertexAttribBindingVector& currBindings =
+        state->currentVertexBufferBindings();
+
+    switch (target) {
+    case GL_VERTEX_BINDING_DIVISOR:
+    case GL_VERTEX_BINDING_OFFSET:
+    case GL_VERTEX_BINDING_STRIDE:
+    case GL_VERTEX_BINDING_BUFFER:
+        SET_ERROR_IF(index < 0 || index > currBindings.size(), GL_INVALID_VALUE);
+        break;
+    default:
+        break;
+    }
+
+    switch (target) {
+    case GL_VERTEX_BINDING_DIVISOR:
+        *params = currBindings[index].divisor;
+        return;
+    case GL_VERTEX_BINDING_OFFSET:
+        *params = currBindings[index].offset;
+        return;
+    case GL_VERTEX_BINDING_STRIDE:
+        *params = currBindings[index].effectiveStride;
+        return;
+    case GL_VERTEX_BINDING_BUFFER:
+        *params = currBindings[index].buffer;
+        return;
+    default:
+        break;
+    }
+
+    ctx->m_glGetInteger64i_v_enc(self, target, index, params);
+}
+
+void GL2Encoder::s_glGetShaderiv(void* self, GLuint shader, GLenum pname, GLint* params) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    ctx->m_glGetShaderiv_enc(self, shader, pname, params);
+    if (pname == GL_SHADER_SOURCE_LENGTH) {
+        ShaderData* shaderData = ctx->m_shared->getShaderData(shader);
+        if (shaderData) {
+            int totalLen = 0;
+            for (int i = 0; i < shaderData->sources.size(); i++) {
+                totalLen += shaderData->sources[i].size();
+            }
+            if (totalLen != 0) {
+                *params = totalLen + 1; // account for null terminator
+            }
+        }
+    }
+}
+
+void GL2Encoder::s_glActiveShaderProgram(void* self, GLuint pipeline, GLuint program) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    GLSharedGroupPtr shared = ctx->m_shared;
+
+    SET_ERROR_IF(!pipeline, GL_INVALID_OPERATION);
+    SET_ERROR_IF(program && !shared->isShaderOrProgramObject(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(program && !shared->isProgram(program), GL_INVALID_OPERATION);
+
+    ctx->m_glActiveShaderProgram_enc(ctx, pipeline, program);
+    if (!state->currentProgram()) {
+        state->setCurrentShaderProgram(program);
+    }
+}
+
+GLuint GL2Encoder::s_glCreateShaderProgramv(void* self, GLenum type, GLsizei count, const char** strings) {
+
+    GLint* length = NULL;
+    GL2Encoder* ctx = (GL2Encoder*)self;
+
+    int len = glUtilsCalcShaderSourceLen((char**)strings, length, count);
+    char *str = new char[len + 1];
+    glUtilsPackStrings(str, (char**)strings, (GLint*)length, count);
+   
+    // Do GLSharedGroup and location WorkARound-specific initialization 
+    // Phase 1: create a ShaderData and initialize with replaceSamplerExternalWith2D()
+    uint32_t spDataId = ctx->m_shared->addNewShaderProgramData();
+    ShaderProgramData* spData = ctx->m_shared->getShaderProgramDataById(spDataId);
+    ShaderData* sData = spData->shaderData;
+
+    if (!replaceSamplerExternalWith2D(str, sData)) {
+        delete [] str;
+        ctx->setError(GL_OUT_OF_MEMORY);
+        ctx->m_shared->deleteShaderProgramDataById(spDataId);
+        return -1;
+    }
+
+    GLuint res = ctx->glCreateShaderProgramvAEMU(ctx, type, count, str, len + 1);
+    delete [] str;
+
+    // Phase 2: do glLinkProgram-related initialization for locationWorkARound
+    GLint linkStatus = 0;
+    ctx->glGetProgramiv(self, res, GL_LINK_STATUS ,&linkStatus);
+    if (!linkStatus) {
+        ctx->m_shared->deleteShaderProgramDataById(spDataId);
+        return -1;
+    }
+
+    ctx->m_shared->associateGLShaderProgram(res, spDataId);
+
+    GLint numUniforms = 0;
+    ctx->glGetProgramiv(ctx, res, GL_ACTIVE_UNIFORMS, &numUniforms);
+    ctx->m_shared->initShaderProgramData(res, numUniforms);
+
+    GLint maxLength=0;
+    ctx->glGetProgramiv(self, res, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxLength);
+
+    GLint size; GLenum uniformType; GLchar* name = new GLchar[maxLength + 1];
+
+    for (GLint i = 0; i < numUniforms; ++i) {
+        ctx->glGetActiveUniform(self, res, i, maxLength, NULL, &size, &uniformType, name);
+        GLint location = ctx->m_glGetUniformLocation_enc(self, res, name);
+        ctx->m_shared->setShaderProgramIndexInfo(res, i, location, size, uniformType, name);
+    }
+
+    ctx->m_shared->setupShaderProgramLocationShiftWAR(res);
+
+    delete [] name;
+
+    return res;
+}
+
+void GL2Encoder::s_glProgramUniform1f(void* self, GLuint program, GLint location, GLfloat v0)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform1f_enc(self, program, hostLoc, v0);
+}
+
+void GL2Encoder::s_glProgramUniform1fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform1fv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform1i(void* self, GLuint program, GLint location, GLint v0)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform1i_enc(self, program, hostLoc, v0);
+
+    GLClientState* state = ctx->m_state;
+    GLSharedGroupPtr shared = ctx->m_shared;
+    GLenum target;
+
+    if (shared->setSamplerUniform(program, location, v0, &target)) {
+        GLenum origActiveTexture = state->getActiveTextureUnit();
+        if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + v0, target)) {
+            ctx->m_glActiveTexture_enc(self, origActiveTexture);
+        }
+        state->setActiveTextureUnit(origActiveTexture);
+    }
+}
+
+void GL2Encoder::s_glProgramUniform1iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform1iv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform1ui(void* self, GLuint program, GLint location, GLuint v0)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform1ui_enc(self, program, hostLoc, v0);
+
+    GLClientState* state = ctx->m_state;
+    GLSharedGroupPtr shared = ctx->m_shared;
+    GLenum target;
+
+    if (shared->setSamplerUniform(program, location, v0, &target)) {
+        GLenum origActiveTexture = state->getActiveTextureUnit();
+        if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + v0, target)) {
+            ctx->m_glActiveTexture_enc(self, origActiveTexture);
+        }
+        state->setActiveTextureUnit(origActiveTexture);
+    }
+}
+
+void GL2Encoder::s_glProgramUniform1uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform1uiv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform2f(void* self, GLuint program, GLint location, GLfloat v0, GLfloat v1)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform2f_enc(self, program, hostLoc, v0, v1);
+}
+
+void GL2Encoder::s_glProgramUniform2fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform2fv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform2i(void* self, GLuint program, GLint location, GLint v0, GLint v1)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform2i_enc(self, program, hostLoc, v0, v1);
+}
+
+void GL2Encoder::s_glProgramUniform2iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform2iv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform2ui(void* self, GLuint program, GLint location, GLint v0, GLuint v1)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform2ui_enc(self, program, hostLoc, v0, v1);
+}
+
+void GL2Encoder::s_glProgramUniform2uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform2uiv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform3f(void* self, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform3f_enc(self, program, hostLoc, v0, v1, v2);
+}
+
+void GL2Encoder::s_glProgramUniform3fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform3fv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform3i(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform3i_enc(self, program, hostLoc, v0, v1, v2);
+}
+
+void GL2Encoder::s_glProgramUniform3iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform3iv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform3ui(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLuint v2)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform3ui_enc(self, program, hostLoc, v0, v1, v2);
+}
+
+void GL2Encoder::s_glProgramUniform3uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform3uiv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform4f(void* self, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform4f_enc(self, program, hostLoc, v0, v1, v2, v3);
+}
+
+void GL2Encoder::s_glProgramUniform4fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform4fv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform4i(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform4i_enc(self, program, hostLoc, v0, v1, v2, v3);
+}
+
+void GL2Encoder::s_glProgramUniform4iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform4iv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniform4ui(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform4ui_enc(self, program, hostLoc, v0, v1, v2, v3);
+}
+
+void GL2Encoder::s_glProgramUniform4uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniform4uiv_enc(self, program, hostLoc, count, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix2fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix2fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix2x3fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix2x3fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix2x4fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix2x4fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix3fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix3fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix3x2fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix3x2fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix3x4fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix3x4fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix4fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix4fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix4x2fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix4x2fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramUniformMatrix4x3fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
+    ctx->m_glProgramUniformMatrix4x3fv_enc(self, program, hostLoc, count, transpose, value);
+}
+
+void GL2Encoder::s_glProgramParameteri(void* self, GLuint program, GLenum pname, GLint value) {
+    GL2Encoder* ctx = (GL2Encoder*)self;
+    ctx->m_glProgramParameteri_enc(self, program, pname, value);
+}
+
+void GL2Encoder::s_glUseProgramStages(void *self, GLuint pipeline, GLbitfield stages, GLuint program)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    GLSharedGroupPtr shared = ctx->m_shared;
+
+    SET_ERROR_IF(!pipeline, GL_INVALID_OPERATION);
+    SET_ERROR_IF(program && !shared->isShaderOrProgramObject(program), GL_INVALID_VALUE);
+    SET_ERROR_IF(program && !shared->isProgram(program), GL_INVALID_OPERATION);
+
+    ctx->m_glUseProgramStages_enc(self, pipeline, stages, program);
+    state->associateProgramWithPipeline(program, pipeline);
+
+    // There is an active non-separable shader program in effect; no need to update external/2D bindings.
+    if (state->currentProgram()) {
+        return;
+    }
+
+    // Otherwise, update host texture 2D bindings.
+    ctx->updateHostTexture2DBindingsFromProgramData(program);
+}
+
+void GL2Encoder::s_glBindProgramPipeline(void* self, GLuint pipeline)
+{
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    ctx->m_glBindProgramPipeline_enc(self, pipeline);
+
+    // There is an active non-separable shader program in effect; no need to update external/2D bindings.
+    if (!pipeline || state->currentProgram()) {
+        return;
+    }
+
+    GLClientState::ProgramPipelineIterator it = state->programPipelineBegin();
+    for (; it != state->programPipelineEnd(); ++it) {
+        if (it->second == pipeline) {
+            ctx->updateHostTexture2DBindingsFromProgramData(it->first);
+        }
+    }
+}
+
+void GL2Encoder::s_glGetProgramResourceiv(void* self, GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    SET_ERROR_IF(bufSize < 0, GL_INVALID_VALUE);
+    if (bufSize == 0) {
+        if (length) *length = 0;
+        return;
+    }
+
+    // Avoid modifying |name| if |*length| < bufSize.
+    GLint* intermediate = new GLint[bufSize];
+    GLsizei* myLength = length ? length : new GLsizei;
+    bool needFreeLength = length == NULL;
+
+    ctx->m_glGetProgramResourceiv_enc(self, program, programInterface, index, propCount, props, bufSize, myLength, intermediate);
+    GLsizei writtenInts = *myLength;
+    memcpy(params, intermediate, writtenInts * sizeof(GLint));
+
+    delete [] intermediate;
+    if (needFreeLength)
+        delete myLength;
+}
+
+GLuint GL2Encoder::s_glGetProgramResourceIndex(void* self, GLuint program, GLenum programInterface, const char* name) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    return ctx->m_glGetProgramResourceIndex_enc(self, program, programInterface, name);
+}
+
+GLint GL2Encoder::s_glGetProgramResourceLocation(void* self, GLuint program, GLenum programInterface, const char* name) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    return ctx->m_glGetProgramResourceLocation_enc(self, program, programInterface, name);
+}
+
+void GL2Encoder::s_glGetProgramResourceName(void* self, GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    SET_ERROR_IF(bufSize < 0, GL_INVALID_VALUE);
+    if (bufSize == 0) {
+        if (length) *length = 0;
+        return;
+    }
+
+    // Avoid modifying |name| if |*length| < bufSize.
+    char* intermediate = new char[bufSize];
+    GLsizei* myLength = length ? length : new GLsizei;
+    bool needFreeLength = length == NULL;
+
+    ctx->m_glGetProgramResourceName_enc(self, program, programInterface, index, bufSize, myLength, intermediate);
+    GLsizei writtenStrLen = *myLength;
+    memcpy(name, intermediate, writtenStrLen + 1);
+
+    delete [] intermediate;
+    if (needFreeLength)
+        delete myLength;
+}
+
+void GL2Encoder::s_glGetProgramPipelineInfoLog(void* self, GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    SET_ERROR_IF(bufSize < 0, GL_INVALID_VALUE);
+    if (bufSize == 0) {
+        if (length) *length = 0;
+        return;
+    }
+
+    // Avoid modifying |infoLog| if |*length| < bufSize.
+    GLchar* intermediate = new GLchar[bufSize];
+    GLsizei* myLength = length ? length : new GLsizei;
+    bool needFreeLength = length == NULL;
+
+    ctx->m_glGetProgramPipelineInfoLog_enc(self, pipeline, bufSize, myLength, intermediate);
+    GLsizei writtenStrLen = *myLength;
+    memcpy(infoLog, intermediate, writtenStrLen + 1);
+
+    delete [] intermediate;
+    if (needFreeLength)
+        delete myLength;
+}
+
+void GL2Encoder::s_glVertexAttribFormat(void* self, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    VALIDATE_VERTEX_ATTRIB_INDEX(attribindex);
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+
+    state->setVertexAttribFormat(attribindex, size, type, normalized, relativeoffset, false);
+    ctx->m_glVertexAttribFormat_enc(ctx, attribindex, size, type, normalized, relativeoffset);
+}
+
+void GL2Encoder::s_glVertexAttribIFormat(void* self, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    VALIDATE_VERTEX_ATTRIB_INDEX(attribindex);
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+
+    state->setVertexAttribFormat(attribindex, size, type, GL_FALSE, relativeoffset, true);
+    ctx->m_glVertexAttribIFormat_enc(ctx, attribindex, size, type, relativeoffset);
+}
+
+void GL2Encoder::s_glVertexBindingDivisor(void* self, GLuint bindingindex, GLuint divisor) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+
+    state->setVertexBindingDivisor(bindingindex, divisor);
+    ctx->m_glVertexBindingDivisor_enc(ctx, bindingindex, divisor);
+}
+
+void GL2Encoder::s_glVertexAttribBinding(void* self, GLuint attribindex, GLuint bindingindex) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+    VALIDATE_VERTEX_ATTRIB_INDEX(attribindex);
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+
+    state->setVertexAttribBinding(attribindex, bindingindex);
+    ctx->m_glVertexAttribBinding_enc(ctx, attribindex, bindingindex);
+}
+
+void GL2Encoder::s_glBindVertexBuffer(void* self, GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(offset < 0, GL_INVALID_VALUE);
+
+    GLint maxStride;
+    ctx->glGetIntegerv(ctx, GL_MAX_VERTEX_ATTRIB_STRIDE, &maxStride);
+    SET_ERROR_IF(stride < 0 || stride > maxStride, GL_INVALID_VALUE);
+
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+
+    state->bindIndexedBuffer(0, bindingindex, buffer, offset, 0, stride, stride);
+    ctx->m_glBindVertexBuffer_enc(ctx, bindingindex, buffer, offset, stride);
+}
+
+void GL2Encoder::s_glDrawArraysIndirect(void* self, GLenum mode, const void* indirect) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    bool hasClientArrays = false;
+    ctx->getVBOUsage(&hasClientArrays, NULL);
+
+    SET_ERROR_IF(hasClientArrays, GL_INVALID_OPERATION);
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+    SET_ERROR_IF(!ctx->boundBuffer(GL_DRAW_INDIRECT_BUFFER), GL_INVALID_OPERATION);
+
+    GLuint indirectStructSize = glUtilsIndirectStructSize(INDIRECT_COMMAND_DRAWARRAYS);
+    if (ctx->boundBuffer(GL_DRAW_INDIRECT_BUFFER)) {
+        // BufferData* buf = ctx->getBufferData(target);
+        // if (buf) {
+        //     SET_ERROR_IF((GLuint)(uintptr_t)indirect + indirectStructSize > buf->m_size, GL_INVALID_VALUE);
+        // }
+        ctx->glDrawArraysIndirectOffsetAEMU(ctx, mode, (uintptr_t)indirect);
+    } else {
+        // Client command structs are technically allowed in desktop OpenGL, but not in ES.
+        // This is purely for debug/dev purposes.
+        ctx->glDrawArraysIndirectDataAEMU(ctx, mode, indirect, indirectStructSize);
+    }
+}
+
+void GL2Encoder::s_glDrawElementsIndirect(void* self, GLenum mode, GLenum type, const void* indirect) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+
+    GLClientState* state = ctx->m_state;
+
+    bool hasClientArrays = false;
+    ctx->getVBOUsage(&hasClientArrays, NULL);
+
+    SET_ERROR_IF(hasClientArrays, GL_INVALID_OPERATION);
+    SET_ERROR_IF(!state->currentVertexArrayObject(), GL_INVALID_OPERATION);
+    SET_ERROR_IF(!ctx->boundBuffer(GL_DRAW_INDIRECT_BUFFER), GL_INVALID_OPERATION);
+
+    SET_ERROR_IF(ctx->m_state->getTransformFeedbackActiveUnpaused(), GL_INVALID_OPERATION);
+
+    GLuint indirectStructSize = glUtilsIndirectStructSize(INDIRECT_COMMAND_DRAWELEMENTS);
+    if (ctx->boundBuffer(GL_DRAW_INDIRECT_BUFFER)) {
+        // BufferData* buf = ctx->getBufferData(target);
+        // if (buf) {
+        //     SET_ERROR_IF((GLuint)(uintptr_t)indirect + indirectStructSize > buf->m_size, GL_INVALID_VALUE);
+        // }
+        ctx->glDrawElementsIndirectOffsetAEMU(ctx, mode, type, (uintptr_t)indirect);
+    } else {
+        // Client command structs are technically allowed in desktop OpenGL, but not in ES.
+        // This is purely for debug/dev purposes.
+        ctx->glDrawElementsIndirectDataAEMU(ctx, mode, type, indirect, indirectStructSize);
+    }
+
+}
+
+void GL2Encoder::s_glTexStorage2DMultisample(void* self, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
+    GL2Encoder *ctx = (GL2Encoder*)self;
+    GLClientState* state = ctx->m_state;
+
+    SET_ERROR_IF(target != GL_TEXTURE_2D_MULTISAMPLE, GL_INVALID_ENUM);
+    SET_ERROR_IF(!GLESv2Validation::pixelInternalFormat(internalformat), GL_INVALID_ENUM);
+    SET_ERROR_IF(!state->getBoundTexture(target), GL_INVALID_OPERATION);
+    SET_ERROR_IF(width < 1 || height < 1, GL_INVALID_VALUE);
+    SET_ERROR_IF(state->isBoundTextureImmutableFormat(target), GL_INVALID_OPERATION);
+    GLint max_samples;
+    ctx->s_glGetInternalformativ(ctx, target, internalformat, GL_SAMPLES, 1, &max_samples);
+    SET_ERROR_IF(samples > max_samples, GL_INVALID_OPERATION);
+
+    state->setBoundTextureInternalFormat(target, internalformat);
+    state->setBoundTextureDims(target, 0, width, height, 1);
+    state->setBoundTextureImmutableFormat(target);
+    state->setBoundTextureSamples(target, samples);
+
+    ctx->m_glTexStorage2DMultisample_enc(ctx, target, samples, internalformat, width, height, fixedsamplelocations);
+}
+
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.h b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.h
index e3d343a..11162ee 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2Encoder.h
@@ -21,6 +21,8 @@
 #include "GLSharedGroup.h"
 #include "FixedBuffer.h"
 
+#include <string>
+
 class GL2Encoder : public gl2_encoder_context_t {
 public:
     GL2Encoder(IOStream *stream, ChecksumCalculator* protocol);
@@ -28,7 +30,31 @@ public:
     void setClientState(GLClientState *state) {
         m_state = state;
     }
-    void setSharedGroup(GLSharedGroupPtr shared){ m_shared = shared; }
+    void setClientStateMakeCurrent(GLClientState *state,
+                                   int majorVersion,
+                                   int minorVersion,
+                                   int deviceMajorVersion,
+                                   int deviceMinorVersion) {
+        m_state = state;
+        m_state->fromMakeCurrent();
+        m_currMajorVersion = majorVersion;
+        m_currMinorVersion = minorVersion;
+        m_deviceMajorVersion = deviceMajorVersion;
+        m_deviceMinorVersion = deviceMinorVersion;
+    }
+    void setSharedGroup(GLSharedGroupPtr shared) {
+        m_shared = shared;
+        if (m_state && m_shared.Ptr())
+            m_state->setTextureData(m_shared->getTextureData());
+    }
+    int majorVersion() const { return m_currMajorVersion; }
+    int minorVersion() const { return m_currMinorVersion; }
+    void setExtensions(const char* exts) {
+        m_currExtensions = std::string(exts);
+    }
+    bool hasExtension(const char* ext) const {
+        return m_currExtensions.find(ext) != std::string::npos;
+    }
     const GLClientState *state() { return m_state; }
     const GLSharedGroupPtr shared() { return m_shared; }
     void flush() { m_stream->flush(); }
@@ -40,10 +66,24 @@ public:
     virtual GLenum getError() { return m_error; };
 
     void override2DTextureTarget(GLenum target);
-    void restore2DTextureTarget();
+    void restore2DTextureTarget(GLenum target);
+    void associateEGLImage(GLenum target, GLeglImageOES eglImage);
+
+    // Convenience functions for buffers
+    GLuint boundBuffer(GLenum target) const;
+    BufferData* getBufferData(GLenum target) const;
+    BufferData* getBufferDataById(GLuint buffer) const;
+    bool isBufferMapped(GLuint buffer) const;
+    bool isBufferTargetMapped(GLenum target) const;
 
 private:
 
+    int m_currMajorVersion;
+    int m_currMinorVersion;
+    int m_deviceMajorVersion;
+    int m_deviceMinorVersion;
+    std::string m_currExtensions;
+
     bool    m_initialized;
     GLClientState *m_state;
     GLSharedGroupPtr m_shared;
@@ -56,13 +96,37 @@ private:
     GLint m_max_cubeMapTextureSize;
     GLint m_max_renderBufferSize;
     GLint m_max_textureSize;
+    GLint m_max_3d_textureSize;
+    GLint m_max_vertexAttribStride;
+
+    GLuint m_ssbo_offset_align;
+    GLuint m_ubo_offset_align;
+
     FixedBuffer m_fixedBuffer;
 
-    void sendVertexAttributes(GLint first, GLsizei count);
-    bool updateHostTexture2DBinding(GLenum texUnit, GLenum newTarget);
-    void checkValidUniformParam(void * self, GLsizei count, GLboolean transpose);
-    void getHostLocation(void *self, GLint location, GLint *hostLoc);
+    int m_drawCallFlushCount;
 
+    bool m_primitiveRestartEnabled;
+    GLuint m_primitiveRestartIndex;
+
+    void calcIndexRange(const void* indices,
+                        GLenum type, GLsizei count,
+                        int* minIndex, int* maxIndex);
+    void* recenterIndices(const void* src,
+                          GLenum type, GLsizei count,
+                          int minIndex);
+    void getBufferIndexRange(BufferData* buf, const void* dataWithOffset,
+                             GLenum type, size_t count, size_t offset,
+                             int* minIndex_out, int* maxIndex_out);
+    void getVBOUsage(bool* hasClientArrays, bool* hasVBOs) const;
+    void sendVertexAttributes(GLint first, GLsizei count, bool hasClientArrays, GLsizei primcount = 0);
+    void flushDrawCall();
+
+    bool updateHostTexture2DBinding(GLenum texUnit, GLenum newTarget);
+    void updateHostTexture2DBindingsFromProgramData(GLuint program);
+    bool texture2DNeedsOverride(GLenum target) const;
+    bool isCompleteFbo(GLenum target, const GLClientState* state, GLenum attachment) const;
+    bool checkFramebufferCompleteness(GLenum target, const GLClientState* state) const;
 
     glGetError_client_proc_t    m_glGetError_enc;
     static GLenum s_glGetError(void * self);
@@ -84,6 +148,10 @@ private:
     static void s_glBufferData(void *self, GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);
     glBufferSubData_client_proc_t m_glBufferSubData_enc;
     static void s_glBufferSubData(void *self, GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data);
+
+    glGenBuffers_client_proc_t m_glGenBuffers_enc;
+    static void s_glGenBuffers(void *self, GLsizei n, GLuint * buffers);
+
     glDeleteBuffers_client_proc_t m_glDeleteBuffers_enc;
     static void s_glDeleteBuffers(void *self, GLsizei n, const GLuint * buffers);
 
@@ -227,6 +295,7 @@ private:
     glTexParameteriv_client_proc_t m_glTexParameteriv_enc;
     glTexImage2D_client_proc_t m_glTexImage2D_enc;
     glTexSubImage2D_client_proc_t m_glTexSubImage2D_enc;
+    glCopyTexImage2D_client_proc_t m_glCopyTexImage2D_enc;
 
     static void s_glActiveTexture(void* self, GLenum texture);
     static void s_glBindTexture(void* self, GLenum target, GLuint texture);
@@ -243,6 +312,358 @@ private:
     static void s_glTexSubImage2D(void* self, GLenum target, GLint level, GLint xoffset,
             GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type,
             const GLvoid* pixels);
+    static void s_glCopyTexImage2D(void* self, GLenum target, GLint level, GLenum internalformat,
+            GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+
+    glGenRenderbuffers_client_proc_t m_glGenRenderbuffers_enc;
+    static void s_glGenRenderbuffers(void* self, GLsizei n, GLuint* renderbuffers);
+    glDeleteRenderbuffers_client_proc_t m_glDeleteRenderbuffers_enc;
+    static void s_glDeleteRenderbuffers(void* self, GLsizei n, const GLuint* renderbuffers);
+
+    glBindRenderbuffer_client_proc_t m_glBindRenderbuffer_enc;
+    static void s_glBindRenderbuffer(void* self, GLenum target, GLuint renderbuffer);
+
+    glRenderbufferStorage_client_proc_t m_glRenderbufferStorage_enc;
+    static void s_glRenderbufferStorage(void* self, GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+
+    glFramebufferRenderbuffer_client_proc_t m_glFramebufferRenderbuffer_enc;
+    static void s_glFramebufferRenderbuffer(void* self, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+
+    glGenFramebuffers_client_proc_t m_glGenFramebuffers_enc;
+    static void s_glGenFramebuffers(void* self, GLsizei n, GLuint* framebuffers);
+    glDeleteFramebuffers_client_proc_t m_glDeleteFramebuffers_enc;
+    static void s_glDeleteFramebuffers(void* self, GLsizei n, const GLuint* framebuffers);
+
+    glBindFramebuffer_client_proc_t m_glBindFramebuffer_enc;
+    static void s_glBindFramebuffer(void* self, GLenum target, GLuint framebuffer);
+
+    glFramebufferTexture2D_client_proc_t m_glFramebufferTexture2D_enc;
+    static void s_glFramebufferTexture2D(void* self, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+
+    glFramebufferTexture3DOES_client_proc_t m_glFramebufferTexture3DOES_enc;
+    static void s_glFramebufferTexture3DOES(void*self, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
+
+    glGetFramebufferAttachmentParameteriv_client_proc_t m_glGetFramebufferAttachmentParameteriv_enc;
+    static void s_glGetFramebufferAttachmentParameteriv(void* self, GLenum target, GLenum attachment, GLenum pname, GLint* params);
+
+    glCheckFramebufferStatus_client_proc_t m_glCheckFramebufferStatus_enc;
+    static GLenum s_glCheckFramebufferStatus(void* self,
+            GLenum target);
+
+    // GLES 3.0-specific custom encoders
+
+    // VAO (+ ES 2 extension)
+    glGenVertexArrays_client_proc_t m_glGenVertexArrays_enc;
+    glDeleteVertexArrays_client_proc_t m_glDeleteVertexArrays_enc;
+    glBindVertexArray_client_proc_t m_glBindVertexArray_enc;
+    glGenVertexArraysOES_client_proc_t m_glGenVertexArraysOES_enc;
+    glDeleteVertexArraysOES_client_proc_t m_glDeleteVertexArraysOES_enc;
+    glBindVertexArrayOES_client_proc_t m_glBindVertexArrayOES_enc;
+    static void s_glGenVertexArrays(void *self, GLsizei n, GLuint* arrays);
+    static void s_glDeleteVertexArrays(void *self , GLsizei n, const GLuint* arrays);
+    static void s_glBindVertexArray(void *self , GLuint array);
+
+    // Mapped buffers
+    static void* s_glMapBufferRange(void* self, GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
+    static GLboolean s_glUnmapBuffer(void* self, GLenum target);
+    static void s_glFlushMappedBufferRange(void* self, GLenum target, GLintptr offset, GLsizeiptr length);
+
+    // Custom encodes for 2D compressed textures b/c we need to account for
+    // nonzero GL_PIXEL_UNPACK_BUFFER
+    glCompressedTexImage2D_client_proc_t m_glCompressedTexImage2D_enc;
+    static void s_glCompressedTexImage2D(void* self, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data);
+    glCompressedTexSubImage2D_client_proc_t m_glCompressedTexSubImage2D_enc;
+    static void s_glCompressedTexSubImage2D(void* self, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data);
+
+    // Indexed, range bind
+    glBindBufferRange_client_proc_t m_glBindBufferRange_enc;
+    static void s_glBindBufferRange(void *self , GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+
+    glBindBufferBase_client_proc_t m_glBindBufferBase_enc;
+    static void s_glBindBufferBase(void *self , GLenum target, GLuint index, GLuint buffer);
+
+    glCopyBufferSubData_client_proc_t m_glCopyBufferSubData_enc;
+    static void s_glCopyBufferSubData(void *self , GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
+
+    glGetBufferParameteriv_client_proc_t m_glGetBufferParameteriv_enc;
+    static void s_glGetBufferParameteriv(void* self, GLenum target, GLenum pname, GLint* params);
+
+    glGetBufferParameteri64v_client_proc_t m_glGetBufferParameteri64v_enc;
+    static void s_glGetBufferParameteri64v(void* self, GLenum target, GLenum pname, GLint64* params);
+
+    glGetBufferPointerv_client_proc_t m_glGetBufferPointerv_enc;
+    static void s_glGetBufferPointerv(void* self, GLenum target, GLenum pname, GLvoid** params);
+
+    glGetUniformIndices_client_proc_t m_glGetUniformIndices_enc;
+    static void s_glGetUniformIndices(void* self, GLuint program, GLsizei uniformCount, const GLchar ** uniformNames, GLuint* uniformIndices);
+
+    glUniform1ui_client_proc_t m_glUniform1ui_enc;
+    glUniform1uiv_client_proc_t m_glUniform1uiv_enc;
+    glUniform2ui_client_proc_t m_glUniform2ui_enc;
+    glUniform2uiv_client_proc_t m_glUniform2uiv_enc;
+    glUniform3ui_client_proc_t m_glUniform3ui_enc;
+    glUniform3uiv_client_proc_t m_glUniform3uiv_enc;
+    glUniform4ui_client_proc_t m_glUniform4ui_enc;
+    glUniform4uiv_client_proc_t m_glUniform4uiv_enc;
+    glUniformMatrix2x3fv_client_proc_t m_glUniformMatrix2x3fv_enc;
+    glUniformMatrix2x4fv_client_proc_t m_glUniformMatrix2x4fv_enc;
+    glUniformMatrix3x2fv_client_proc_t m_glUniformMatrix3x2fv_enc;
+    glUniformMatrix3x4fv_client_proc_t m_glUniformMatrix3x4fv_enc;
+    glUniformMatrix4x2fv_client_proc_t m_glUniformMatrix4x2fv_enc;
+    glUniformMatrix4x3fv_client_proc_t m_glUniformMatrix4x3fv_enc;
+
+    static void s_glUniform1ui(void* self, GLint location, GLuint v0);
+    static void s_glUniform2ui(void* self, GLint location, GLuint v0, GLuint v1);
+    static void s_glUniform3ui(void* self, GLint location, GLuint v0, GLuint v1, GLuint v2);
+    static void s_glUniform4ui(void* self, GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3);
+    static void s_glUniform1uiv(void* self, GLint location, GLsizei count, const GLuint *value);
+    static void s_glUniform2uiv(void* self, GLint location, GLsizei count, const GLuint *value);
+    static void s_glUniform3uiv(void* self, GLint location, GLsizei count, const GLuint *value);
+    static void s_glUniform4uiv(void* self, GLint location, GLsizei count, const GLuint *value);
+    static void s_glUniformMatrix2x3fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glUniformMatrix3x2fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glUniformMatrix2x4fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glUniformMatrix4x2fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glUniformMatrix3x4fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glUniformMatrix4x3fv(void* self, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+
+    glGetUniformuiv_client_proc_t m_glGetUniformuiv_enc;
+    static void s_glGetUniformuiv(void *self, GLuint program, GLint location, GLuint* params);
+
+    glGetActiveUniformBlockiv_client_proc_t m_glGetActiveUniformBlockiv_enc;
+    static void s_glGetActiveUniformBlockiv(void* self, GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
+
+    glGetVertexAttribIiv_client_proc_t m_glGetVertexAttribIiv_enc;
+    static void s_glGetVertexAttribIiv(void* self, GLuint index, GLenum pname, GLint* params);
+
+    glGetVertexAttribIuiv_client_proc_t m_glGetVertexAttribIuiv_enc;
+    static void s_glGetVertexAttribIuiv(void* self, GLuint index, GLenum pname, GLuint* params);
+
+    static void s_glVertexAttribIPointer(void* self, GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
+
+    glVertexAttribDivisor_client_proc_t m_glVertexAttribDivisor_enc;
+    static void s_glVertexAttribDivisor(void* self, GLuint index, GLuint divisor);
+
+    glRenderbufferStorageMultisample_client_proc_t m_glRenderbufferStorageMultisample_enc;
+    static void s_glRenderbufferStorageMultisample(void* self, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+
+    glDrawBuffers_client_proc_t m_glDrawBuffers_enc;
+    static void s_glDrawBuffers(void* self, GLsizei n, const GLenum* bufs);
+
+    glReadBuffer_client_proc_t m_glReadBuffer_enc;
+    static void s_glReadBuffer(void* self, GLenum src);
+
+    glFramebufferTextureLayer_client_proc_t m_glFramebufferTextureLayer_enc;
+    static void s_glFramebufferTextureLayer(void* self, GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
+
+    glTexStorage2D_client_proc_t m_glTexStorage2D_enc;
+    static void s_glTexStorage2D(void* self, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
+
+    static void s_glTransformFeedbackVaryings(void* self, GLuint program, GLsizei count, const char** varyings, GLenum bufferMode);
+
+    glBeginTransformFeedback_client_proc_t m_glBeginTransformFeedback_enc;
+    static void s_glBeginTransformFeedback(void* self, GLenum primitiveMode);
+
+    glEndTransformFeedback_client_proc_t m_glEndTransformFeedback_enc;
+    static void s_glEndTransformFeedback(void* self);
+
+    glPauseTransformFeedback_client_proc_t m_glPauseTransformFeedback_enc;
+    static void s_glPauseTransformFeedback(void* self);
+
+    glResumeTransformFeedback_client_proc_t m_glResumeTransformFeedback_enc;
+    static void s_glResumeTransformFeedback(void* self);
+
+    glTexImage3D_client_proc_t m_glTexImage3D_enc;
+    static void s_glTexImage3D(void* self, GLenum target, GLint level, GLint internalFormat,
+                               GLsizei width, GLsizei height, GLsizei depth,
+                               GLint border, GLenum format, GLenum type, const GLvoid* data);
+
+    glTexSubImage3D_client_proc_t m_glTexSubImage3D_enc;
+    static void s_glTexSubImage3D(void* self, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data);
+
+    glCompressedTexImage3D_client_proc_t m_glCompressedTexImage3D_enc;
+    static void s_glCompressedTexImage3D(void* self, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
+    glCompressedTexSubImage3D_client_proc_t m_glCompressedTexSubImage3D_enc;
+    static void s_glCompressedTexSubImage3D(void* self, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
+
+
+    glTexStorage3D_client_proc_t m_glTexStorage3D_enc;
+    static void s_glTexStorage3D(void* self, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
+
+    glDrawArraysInstanced_client_proc_t m_glDrawArraysInstanced_enc;
+    static void s_glDrawArraysInstanced(void* self, GLenum mode, GLint first, GLsizei count, GLsizei primcount);
+
+    static void s_glDrawElementsInstanced(void* self, GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
+
+    glDrawRangeElements_client_proc_t m_glDrawRangeElements_enc;
+    static void s_glDrawRangeElements(void* self, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices);
+
+    static const GLubyte* s_glGetStringi(void* self, GLenum name, GLuint index);
+
+    glGetProgramBinary_client_proc_t m_glGetProgramBinary_enc;
+    static void s_glGetProgramBinary(void* self, GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
+
+    glReadPixels_client_proc_t m_glReadPixels_enc;
+    static void s_glReadPixels(void* self, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
+
+    glEnable_client_proc_t m_glEnable_enc;
+    static void s_glEnable(void* self, GLenum what);
+    glDisable_client_proc_t m_glDisable_enc;
+    static void s_glDisable(void* self, GLenum what);
+
+    glClearBufferiv_client_proc_t m_glClearBufferiv_enc;
+    static void s_glClearBufferiv(void* self, GLenum buffer, GLint drawBuffer, const GLint* value);
+
+    glClearBufferuiv_client_proc_t m_glClearBufferuiv_enc;
+    static void s_glClearBufferuiv(void* self, GLenum buffer, GLint drawBuffer, const GLuint* value);
+
+    glClearBufferfv_client_proc_t m_glClearBufferfv_enc;
+    static void s_glClearBufferfv(void* self, GLenum buffer, GLint drawBuffer, const GLfloat* value);
+
+    glBlitFramebuffer_client_proc_t m_glBlitFramebuffer_enc;
+    static void s_glBlitFramebuffer(void* self, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+
+    static void s_glGetInternalformativ(void* self, GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
+
+    glGenerateMipmap_client_proc_t m_glGenerateMipmap_enc;
+    static void s_glGenerateMipmap(void* self, GLenum target);
+
+    glBindSampler_client_proc_t m_glBindSampler_enc;
+    static void s_glBindSampler(void* self, GLuint unit, GLuint sampler);
+
+    static GLsync s_glFenceSync(void* self, GLenum condition, GLbitfield flags);
+    static GLenum s_glClientWaitSync(void* self, GLsync wait_on, GLbitfield flags, GLuint64 timeout);
+    static void s_glWaitSync(void* self, GLsync wait_on, GLbitfield flags, GLuint64 timeout);
+    static void s_glDeleteSync(void* self, GLsync to_delete);
+    static GLboolean s_glIsSync(void* self, GLsync sync);
+    static void s_glGetSynciv(void* self, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
+
+    glGetIntegeri_v_client_proc_t m_glGetIntegeri_v_enc;
+    static void s_glGetIntegeri_v(void* self, GLenum target, GLuint index, GLint* params);
+
+    glGetInteger64i_v_client_proc_t m_glGetInteger64i_v_enc;
+    static void s_glGetInteger64i_v(void* self, GLenum target, GLuint index, GLint64* params);
+
+    glGetShaderiv_client_proc_t m_glGetShaderiv_enc;
+    static void s_glGetShaderiv(void* self, GLuint shader, GLenum pname, GLint* params);
+
+    // 3.1
+    glActiveShaderProgram_client_proc_t m_glActiveShaderProgram_enc;
+    static void s_glActiveShaderProgram(void* self, GLuint pipeline, GLuint program);
+    static GLuint s_glCreateShaderProgramv(void* self, GLenum type, GLsizei count, const char** strings);
+
+    glProgramUniform1f_client_proc_t m_glProgramUniform1f_enc;
+    glProgramUniform1fv_client_proc_t m_glProgramUniform1fv_enc;
+    glProgramUniform1i_client_proc_t m_glProgramUniform1i_enc;
+    glProgramUniform1iv_client_proc_t m_glProgramUniform1iv_enc;
+    glProgramUniform1ui_client_proc_t m_glProgramUniform1ui_enc;
+    glProgramUniform1uiv_client_proc_t m_glProgramUniform1uiv_enc;
+    glProgramUniform2f_client_proc_t m_glProgramUniform2f_enc;
+    glProgramUniform2fv_client_proc_t m_glProgramUniform2fv_enc;
+    glProgramUniform2i_client_proc_t m_glProgramUniform2i_enc;
+    glProgramUniform2iv_client_proc_t m_glProgramUniform2iv_enc;
+    glProgramUniform2ui_client_proc_t m_glProgramUniform2ui_enc;
+    glProgramUniform2uiv_client_proc_t m_glProgramUniform2uiv_enc;
+    glProgramUniform3f_client_proc_t m_glProgramUniform3f_enc;
+    glProgramUniform3fv_client_proc_t m_glProgramUniform3fv_enc;
+    glProgramUniform3i_client_proc_t m_glProgramUniform3i_enc;
+    glProgramUniform3iv_client_proc_t m_glProgramUniform3iv_enc;
+    glProgramUniform3ui_client_proc_t m_glProgramUniform3ui_enc;
+    glProgramUniform3uiv_client_proc_t m_glProgramUniform3uiv_enc;
+    glProgramUniform4f_client_proc_t m_glProgramUniform4f_enc;
+    glProgramUniform4fv_client_proc_t m_glProgramUniform4fv_enc;
+    glProgramUniform4i_client_proc_t m_glProgramUniform4i_enc;
+    glProgramUniform4iv_client_proc_t m_glProgramUniform4iv_enc;
+    glProgramUniform4ui_client_proc_t m_glProgramUniform4ui_enc;
+    glProgramUniform4uiv_client_proc_t m_glProgramUniform4uiv_enc;
+    glProgramUniformMatrix2fv_client_proc_t m_glProgramUniformMatrix2fv_enc;
+    glProgramUniformMatrix2x3fv_client_proc_t m_glProgramUniformMatrix2x3fv_enc;
+    glProgramUniformMatrix2x4fv_client_proc_t m_glProgramUniformMatrix2x4fv_enc;
+    glProgramUniformMatrix3fv_client_proc_t m_glProgramUniformMatrix3fv_enc;
+    glProgramUniformMatrix3x2fv_client_proc_t m_glProgramUniformMatrix3x2fv_enc;
+    glProgramUniformMatrix3x4fv_client_proc_t m_glProgramUniformMatrix3x4fv_enc;
+    glProgramUniformMatrix4fv_client_proc_t m_glProgramUniformMatrix4fv_enc;
+    glProgramUniformMatrix4x2fv_client_proc_t m_glProgramUniformMatrix4x2fv_enc;
+    glProgramUniformMatrix4x3fv_client_proc_t m_glProgramUniformMatrix4x3fv_enc;
+
+    static void s_glProgramUniform1f(void* self, GLuint program, GLint location, GLfloat v0);
+    static void s_glProgramUniform2f(void* self, GLuint program, GLint location, GLfloat v0, GLfloat v1);
+    static void s_glProgramUniform3f(void* self, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+    static void s_glProgramUniform4f(void* self, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+    static void s_glProgramUniform1i(void* self, GLuint program, GLint location, GLint v0);
+    static void s_glProgramUniform2i(void* self, GLuint program, GLint location, GLint v0, GLint v1);
+    static void s_glProgramUniform3i(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
+    static void s_glProgramUniform4i(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+    static void s_glProgramUniform1ui(void* self, GLuint program, GLint location, GLuint v0);
+    static void s_glProgramUniform2ui(void* self, GLuint program, GLint location, GLint v0, GLuint v1);
+    static void s_glProgramUniform3ui(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLuint v2);
+    static void s_glProgramUniform4ui(void* self, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3);
+    static void s_glProgramUniform1fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    static void s_glProgramUniform2fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    static void s_glProgramUniform3fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    static void s_glProgramUniform4fv(void* self, GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    static void s_glProgramUniform1iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value);
+    static void s_glProgramUniform2iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value);
+    static void s_glProgramUniform3iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value);
+    static void s_glProgramUniform4iv(void* self, GLuint program, GLint location, GLsizei count, const GLint *value);
+    static void s_glProgramUniform1uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value);
+    static void s_glProgramUniform2uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value);
+    static void s_glProgramUniform3uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value);
+    static void s_glProgramUniform4uiv(void* self, GLuint program, GLint location, GLsizei count, const GLuint *value);
+    static void s_glProgramUniformMatrix2fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix3fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix4fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix2x3fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix3x2fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix2x4fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix4x2fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix3x4fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    static void s_glProgramUniformMatrix4x3fv(void* self, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+
+    glProgramParameteri_client_proc_t m_glProgramParameteri_enc;
+    glUseProgramStages_client_proc_t m_glUseProgramStages_enc;
+    glBindProgramPipeline_client_proc_t m_glBindProgramPipeline_enc;
+
+    static void s_glProgramParameteri(void* self, GLuint program, GLenum pname, GLint value);
+    static void s_glUseProgramStages(void *self, GLuint pipeline, GLbitfield stages, GLuint program);
+    static void s_glBindProgramPipeline(void *self, GLuint pipeline);
+
+    glGetProgramResourceiv_client_proc_t m_glGetProgramResourceiv_enc;
+    glGetProgramResourceIndex_client_proc_t m_glGetProgramResourceIndex_enc;
+    glGetProgramResourceLocation_client_proc_t m_glGetProgramResourceLocation_enc;
+    glGetProgramResourceName_client_proc_t m_glGetProgramResourceName_enc;
+    glGetProgramPipelineInfoLog_client_proc_t m_glGetProgramPipelineInfoLog_enc;
+
+    static void s_glGetProgramResourceiv(void* self, GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params);
+    static GLuint s_glGetProgramResourceIndex(void* self, GLuint program, GLenum programInterface, const char* name);
+    static GLint s_glGetProgramResourceLocation(void* self, GLuint program, GLenum programInterface, const char* name);
+    static void s_glGetProgramResourceName(void* self, GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name);
+
+    static void s_glGetProgramPipelineInfoLog(void* self, GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
+
+    // TODO: Compute shaders:
+    // make sure it's OK to put memory barriers and compute dispatch
+    // on the default encoding path
+   
+    glVertexAttribFormat_client_proc_t m_glVertexAttribFormat_enc;
+    glVertexAttribIFormat_client_proc_t m_glVertexAttribIFormat_enc;
+    glVertexBindingDivisor_client_proc_t m_glVertexBindingDivisor_enc;
+    glVertexAttribBinding_client_proc_t m_glVertexAttribBinding_enc;
+    glBindVertexBuffer_client_proc_t m_glBindVertexBuffer_enc;
+
+    static void s_glVertexAttribFormat(void* self, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
+    static void s_glVertexAttribIFormat(void* self, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
+    static void s_glVertexBindingDivisor(void* self, GLuint bindingindex, GLuint divisor);
+    static void s_glVertexAttribBinding(void* self, GLuint attribindex, GLuint bindingindex);
+    static void s_glBindVertexBuffer(void* self, GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride);
+
+    // Indirect draws
+    static void s_glDrawArraysIndirect(void* self, GLenum mode, const void* indirect);
+    static void s_glDrawElementsIndirect(void* self, GLenum mode, GLenum type, const void* indirect);
+
+    // Multisampled textures
+    glTexStorage2DMultisample_client_proc_t m_glTexStorage2DMultisample_enc;
+    static void s_glTexStorage2DMultisample(void* self, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
 
 public:
     glEGLImageTargetTexture2DOES_client_proc_t m_glEGLImageTargetTexture2DOES_enc;
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.cpp b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.cpp
index fc2a723..d1f73cd 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.cpp
@@ -18,19 +18,22 @@
 #include "GL2Encoder.h"
 #include <assert.h>
 
+#include <GLES3/gl31.h>
+
 namespace glesv2_enc {
 
 size_t pixelDataSize(void *self, GLsizei width, GLsizei height, GLenum format, GLenum type, int pack)
 {
     GL2Encoder *ctx = (GL2Encoder *)self;
     assert (ctx->state() != NULL);
-    return ctx->state()->pixelDataSize(width, height, format, type, pack);
+    return ctx->state()->pixelDataSize(width, height, 1, format, type, pack);
 }
 
 size_t pixelDataSize3D(void *self, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, int pack)
 {
-    size_t layerSize = pixelDataSize(self, width, height, format, type, pack);
-    return layerSize * depth;
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert (ctx->state() != NULL);
+    return ctx->state()->pixelDataSize(width, height, depth, format, type, pack);
 }
 
 GLenum uniformType(void * self, GLuint program, GLint location)
@@ -40,4 +43,27 @@ GLenum uniformType(void * self, GLuint program, GLint location)
     return ctx->shared()->getProgramUniformType(program, location);
 }
 
+size_t clearBufferNumElts(void* self, GLenum buffer) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert (ctx->state() != NULL);
+    return ctx->state()->clearBufferNumElts(buffer);
+}
+
+size_t numActiveUniformsInUniformBlock(void* self, GLuint program, GLuint blockIndex) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert (ctx->state() != NULL);
+    return ctx->state()->numActiveUniformsInUniformBlock(program, blockIndex);
+}
+
+size_t glActiveUniformBlockivParamSize(void* self, GLuint program, GLuint blockIndex, GLenum pname) {
+    GL2Encoder *ctx = (GL2Encoder *)self;
+    assert (ctx->state() != NULL);
+
+    if (pname == GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES) {
+        return ctx->state()->numActiveUniformsInUniformBlock(program, blockIndex);
+    } else {
+        return glUtilsParamSize(pname);
+    }
+}
+
 }  // namespace glesv2_enc
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.h b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.h
index 211e966..8d39ca3 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/GL2EncoderUtils.h
@@ -21,6 +21,9 @@ namespace glesv2_enc {
 size_t pixelDataSize(void *self, GLsizei width, GLsizei height, GLenum format, GLenum type, int pack);
 size_t pixelDataSize3D(void *self, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, int pack);
 GLenum uniformType(void * self, GLuint program, GLint location);
+size_t clearBufferNumElts(void* self, GLenum buffer);
+size_t numActiveUniformsInUniformBlock(void* self, GLuint program, GLuint blockIndex);
+size_t glActiveUniformBlockivParamSize(void* self, GLuint program, GLuint blockIndex, GLenum pname);
 
 }  // namespace glesv2_enc
 
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/GLESv2Validation.cpp b/vendor/anbox/android/opengl/system/GLESv2_enc/GLESv2Validation.cpp
new file mode 100644
index 0000000..c703325
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/GLESv2Validation.cpp
@@ -0,0 +1,841 @@
+/*
+* Copyright (C) 2016 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "GLESv2Validation.h"
+
+#include <sstream>
+
+namespace GLESv2Validation {
+
+GLbitfield allBufferMapAccessFlags =
+    GL_MAP_READ_BIT | GL_MAP_WRITE_BIT |
+    GL_MAP_INVALIDATE_RANGE_BIT |
+    GL_MAP_INVALIDATE_BUFFER_BIT |
+    GL_MAP_FLUSH_EXPLICIT_BIT |
+    GL_MAP_UNSYNCHRONIZED_BIT;
+
+bool bufferTarget(GL2Encoder* ctx, GLenum target) {
+    int glesMajorVersion = ctx->majorVersion();
+    int glesMinorVersion = ctx->minorVersion();
+    switch (target) {
+    case GL_ARRAY_BUFFER: // Vertex attributes
+    case GL_ELEMENT_ARRAY_BUFFER: // Vertex array indices
+        return true;
+        // GLES 3.0 buffers
+    case GL_COPY_READ_BUFFER: // Buffer copy source
+    case GL_COPY_WRITE_BUFFER: // Buffer copy destination
+    case GL_PIXEL_PACK_BUFFER: // Pixel read target
+    case GL_PIXEL_UNPACK_BUFFER: // Texture data source
+    case GL_TRANSFORM_FEEDBACK_BUFFER: // Transform feedback buffer
+    case GL_UNIFORM_BUFFER: // Uniform block storage
+        return glesMajorVersion >= 3;
+        // GLES 3.1 buffers
+    case GL_ATOMIC_COUNTER_BUFFER: // Atomic counter storage
+    case GL_DISPATCH_INDIRECT_BUFFER: // Indirect compute dispatch commands
+    case GL_DRAW_INDIRECT_BUFFER: // Indirect command arguments
+    case GL_SHADER_STORAGE_BUFFER: // Read-write storage for shaders
+        return glesMajorVersion >= 3 && glesMinorVersion >= 1;
+    default:
+        return false;
+    }
+}
+
+bool bufferParam(GL2Encoder* ctx, GLenum pname) {
+    int glesMajorVersion = ctx->majorVersion();
+    int glesMinorVersion = ctx->minorVersion();
+    switch (pname) {
+    case GL_BUFFER_SIZE:
+    case GL_BUFFER_USAGE:
+        return true;
+    case GL_BUFFER_ACCESS_FLAGS:
+    case GL_BUFFER_MAPPED:
+    case GL_BUFFER_MAP_LENGTH:
+    case GL_BUFFER_MAP_OFFSET:
+        return glesMajorVersion >= 3;
+    default:
+        return false;
+    }
+}
+
+bool pixelStoreParam(GL2Encoder* ctx, GLenum param) {
+    int glesMajorVersion = ctx->majorVersion();
+    switch(param) {
+    case GL_UNPACK_ALIGNMENT:
+    case GL_PACK_ALIGNMENT:
+        return true;
+    case GL_UNPACK_ROW_LENGTH:
+    case GL_UNPACK_IMAGE_HEIGHT:
+    case GL_UNPACK_SKIP_PIXELS:
+    case GL_UNPACK_SKIP_ROWS:
+    case GL_UNPACK_SKIP_IMAGES:
+    case GL_PACK_ROW_LENGTH:
+    case GL_PACK_SKIP_PIXELS:
+    case GL_PACK_SKIP_ROWS:
+        return glesMajorVersion >= 3;
+    default:
+        return false;
+    }
+}
+
+bool pixelStoreValue(GLenum param, GLint value) {
+    switch(param) {
+    case GL_UNPACK_ALIGNMENT:
+    case GL_PACK_ALIGNMENT:
+        return (value == 1) || (value == 2) || (value == 4) || (value == 8);
+    case GL_UNPACK_ROW_LENGTH:
+    case GL_UNPACK_IMAGE_HEIGHT:
+    case GL_UNPACK_SKIP_PIXELS:
+    case GL_UNPACK_SKIP_ROWS:
+    case GL_UNPACK_SKIP_IMAGES:
+    case GL_PACK_ROW_LENGTH:
+    case GL_PACK_SKIP_PIXELS:
+    case GL_PACK_SKIP_ROWS:
+        return value >= 0;
+    default:
+        return false;
+    }
+}
+
+bool rboFormat(GL2Encoder* ctx, GLenum internalformat) {
+    int glesMajorVersion = ctx->majorVersion();
+
+    switch (internalformat) {
+    // Funny internal formats
+    // that will cause an incomplete framebuffer
+    // attachment error pre-gles3. For dEQP,
+    // we can also just abort early here in
+    // RenderbufferStorage with a GL_INVALID_ENUM.
+    case GL_DEPTH_COMPONENT32F:
+    case GL_R8:
+    case GL_R8UI:
+    case GL_R8I:
+    case GL_R16UI:
+    case GL_R16I:
+    case GL_R32UI:
+    case GL_R32I:
+    case GL_RG8:
+    case GL_RG8UI:
+    case GL_RG8I:
+    case GL_RG16UI:
+    case GL_RG16I:
+    case GL_RG32UI:
+    case GL_RG32I:
+    case GL_SRGB8_ALPHA8:
+    case GL_RGBA8UI:
+    case GL_RGBA8I:
+    case GL_RGB10_A2:
+    case GL_RGB10_A2UI:
+    case GL_RGBA16UI:
+    case GL_RGBA16I:
+    case GL_RGBA32I:
+    case GL_RGBA32UI:
+    case GL_RGB32F:
+        return glesMajorVersion >= 3;
+        // These 4 formats are still not OK,
+        // but dEQP expects GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT or
+        // GL_FRAMEBUFFER_UNSUPPORTED if the extension is not present,
+        // not a GL_INVALID_ENUM from earlier on.
+        // So let's forward these to the rest of
+        // FBO initialization
+        // In GLES 3, these are rejected immediately if not
+        // supported.
+    case GL_R16F:
+    case GL_RG16F:
+    case GL_RGBA16F:
+    case GL_R32F:
+    case GL_RG32F:
+    case GL_RGBA32F:
+    case GL_R11F_G11F_B10F:
+        return glesMajorVersion >= 3 && ctx->hasExtension("GL_EXT_color_buffer_float");
+    case GL_RGB16F:
+        return glesMajorVersion >= 3 && ctx->hasExtension("GL_EXT_color_buffer_half_float");
+        // dEQP expects GL_FRAMEBUFFER_UNSUPPORTED or GL_FRAMEBUFFER_COMPLETE
+        // for this format
+        // These formats are OK
+    case GL_DEPTH_COMPONENT16:
+    case GL_DEPTH_COMPONENT24:
+    case GL_DEPTH_COMPONENT32_OES:
+    case GL_RGBA4:
+    case GL_RGB5_A1:
+    case GL_RGB565:
+    case GL_RGB8_OES:
+    case GL_RGBA8_OES:
+    case GL_STENCIL_INDEX8:
+    case GL_DEPTH32F_STENCIL8:
+    case GL_DEPTH24_STENCIL8_OES:
+        return true;
+        break;
+        // Everything else: still not OK,
+        // and they need the GL_INVALID_ENUM
+    }
+    return false;
+}
+
+bool framebufferTarget(GL2Encoder* ctx, GLenum target) {
+    int glesMajorVersion = ctx->majorVersion();
+    switch (target) {
+    case GL_FRAMEBUFFER:
+        return true;
+    case GL_DRAW_FRAMEBUFFER:
+    case GL_READ_FRAMEBUFFER:
+        return glesMajorVersion >= 3;
+    }
+    return false;
+}
+
+bool framebufferAttachment(GL2Encoder* ctx, GLenum attachment) {
+    int glesMajorVersion = ctx->majorVersion();
+    switch (attachment) {
+    case GL_COLOR_ATTACHMENT0:
+    case GL_DEPTH_ATTACHMENT:
+    case GL_STENCIL_ATTACHMENT:
+        return true;
+    case GL_COLOR_ATTACHMENT1:
+    case GL_COLOR_ATTACHMENT2:
+    case GL_COLOR_ATTACHMENT3:
+    case GL_COLOR_ATTACHMENT4:
+    case GL_COLOR_ATTACHMENT5:
+    case GL_COLOR_ATTACHMENT6:
+    case GL_COLOR_ATTACHMENT7:
+    case GL_COLOR_ATTACHMENT8:
+    case GL_COLOR_ATTACHMENT9:
+    case GL_COLOR_ATTACHMENT10:
+    case GL_COLOR_ATTACHMENT11:
+    case GL_COLOR_ATTACHMENT12:
+    case GL_COLOR_ATTACHMENT13:
+    case GL_COLOR_ATTACHMENT14:
+    case GL_COLOR_ATTACHMENT15:
+    case GL_DEPTH_STENCIL_ATTACHMENT:
+        return glesMajorVersion >= 3;
+    }
+    return false;
+}
+
+bool readPixelsFormat(GLenum format) {
+    switch (format) {
+    case GL_RED:
+    case GL_RED_INTEGER:
+    case GL_RG:
+    case GL_RG_INTEGER:
+    case GL_RGB:
+    case GL_RGB_INTEGER:
+    case GL_RGBA:
+    case GL_RGBA_INTEGER:
+    case GL_LUMINANCE_ALPHA:
+    case GL_LUMINANCE:
+    case GL_ALPHA:
+        return true;
+    }
+    return false;
+}
+
+bool readPixelsType(GLenum format) {
+    switch (format) {
+    case GL_UNSIGNED_BYTE:
+    case GL_BYTE:
+    case GL_HALF_FLOAT:
+    case GL_FLOAT:
+    case GL_INT:
+    case GL_UNSIGNED_SHORT_5_6_5:
+    case GL_UNSIGNED_SHORT_4_4_4_4:
+    case GL_UNSIGNED_SHORT_5_5_5_1:
+    case GL_UNSIGNED_INT:
+    case GL_UNSIGNED_INT_2_10_10_10_REV:
+    case GL_UNSIGNED_INT_10F_11F_11F_REV:
+    case GL_UNSIGNED_INT_5_9_9_9_REV:
+        return true;
+    }
+    return false;
+}
+
+bool vertexAttribType(GL2Encoder* ctx, GLenum type)
+{
+    int glesMajorVersion = ctx->majorVersion();
+    bool retval = false;
+    switch (type) {
+    case GL_BYTE:
+    case GL_UNSIGNED_BYTE:
+    case GL_SHORT:
+    case GL_UNSIGNED_SHORT:
+    case GL_FIXED:
+    case GL_FLOAT:
+    // The following are technically only available if certain GLES2 extensions are.
+    // However, they are supported by desktop GL3, which is a reasonable requirement
+    // for the desktop GL version. Therefore, consider them valid.
+    case GL_INT:
+    case GL_UNSIGNED_INT:
+    case GL_HALF_FLOAT_OES:
+        retval = true;
+        break;
+    case GL_HALF_FLOAT:
+    case GL_INT_2_10_10_10_REV:
+    case GL_UNSIGNED_INT_2_10_10_10_REV:
+        retval = glesMajorVersion >= 3;
+        break;
+    }
+    return retval;
+}
+
+bool readPixelsFboFormatMatch(GLenum format, GLenum type, GLenum fboTexType) {
+#define INVALID_TYPE_MATCH(x, y) \
+    if (type == x && fboTexType == y) return false; \
+    if (type == y && fboTexType == x) return false; \
+
+    // These are meant to reject additional format/type mismatches
+    // not caught by underlying system.
+    INVALID_TYPE_MATCH(GL_FLOAT, GL_BYTE)
+    INVALID_TYPE_MATCH(GL_FLOAT, GL_UNSIGNED_BYTE)
+    INVALID_TYPE_MATCH(GL_FLOAT, GL_UNSIGNED_INT)
+    INVALID_TYPE_MATCH(GL_FLOAT, GL_INT)
+
+    return true;
+}
+
+bool blitFramebufferFormat(GLenum readFormat, GLenum drawFormat) {
+#define INVALID_MATCH(x, y) \
+    if (readFormat == x && drawFormat == y) return false; \
+    if (readFormat == y && drawFormat == x) return false; \
+
+    INVALID_MATCH(GL_FLOAT, GL_BYTE)
+    INVALID_MATCH(GL_FLOAT, GL_UNSIGNED_BYTE)
+    INVALID_MATCH(GL_FLOAT, GL_UNSIGNED_INT)
+    INVALID_MATCH(GL_FLOAT, GL_INT)
+    INVALID_MATCH(GL_INT, GL_UNSIGNED_BYTE);
+    INVALID_MATCH(GL_UNSIGNED_INT, GL_UNSIGNED_BYTE);
+    INVALID_MATCH(GL_INT, GL_BYTE);
+    INVALID_MATCH(GL_UNSIGNED_INT, GL_BYTE);
+    INVALID_MATCH(GL_DEPTH32F_STENCIL8, GL_DEPTH24_STENCIL8);
+
+    return true;
+}
+
+bool textureTarget(GL2Encoder* ctx, GLenum target) {
+    int glesMajorVersion = ctx->majorVersion();
+    int glesMinorVersion = ctx->minorVersion();
+    switch (target) {
+    case GL_TEXTURE_EXTERNAL_OES:
+    case GL_TEXTURE_2D:
+    case GL_TEXTURE_CUBE_MAP:
+    case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+    case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+    case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+        return true;
+    case GL_TEXTURE_2D_ARRAY:
+    case GL_TEXTURE_3D:
+        return glesMajorVersion >= 3;
+    case GL_TEXTURE_2D_MULTISAMPLE:
+        return glesMajorVersion >= 3 &&
+               glesMinorVersion >= 1;
+    default:
+        break;
+    }
+    return false;
+}
+
+static GLsizei ceildiv(GLsizei x, GLsizei y) {
+    return (x + y - 1) / y;
+}
+
+GLsizei compressedTexImageSize(GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
+    GLsizei base_size = ceildiv(width, 4) * ceildiv(height, 4) * depth;
+#define COMPRESSED_TEX_IMAGE_SIZE_CASE(internal, multiplier) \
+    case internal: \
+        return base_size * multiplier; \
+
+    switch (internalformat) {
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_R11_EAC, 8)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_SIGNED_R11_EAC, 8)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_RG11_EAC, 16)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_SIGNED_RG11_EAC, 16)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_RGB8_ETC2, 8)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_SRGB8_ETC2, 8)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, 8)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, 8)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_RGBA8_ETC2_EAC, 16)
+    COMPRESSED_TEX_IMAGE_SIZE_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, 16)
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+bool isCompressedFormat(GLenum internalformat) {
+#define COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(internal) \
+    case internal: \
+        return true; \
+
+    switch (internalformat) {
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_R11_EAC)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SIGNED_R11_EAC)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RG11_EAC)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SIGNED_RG11_EAC)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGB8_ETC2)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ETC2)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA8_ETC2_EAC)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_4x4_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_5x4_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_5x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_6x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_6x6_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_8x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_8x6_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_8x8_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_10x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_10x6_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_10x8_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_10x10_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_12x10_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_RGBA_ASTC_12x12_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR)
+    COMPRESSED_TEX_IMAGE_IS_COMPRESSED_FORMAT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR)
+    default:
+        break;
+    }
+    return false;
+}
+
+bool supportedCompressedFormat(GL2Encoder* ctx, GLenum internalformat) {
+    int glesMajorVersion = ctx->majorVersion();
+    int glesMinorVersion = ctx->minorVersion();
+#define COMPRESSED_TEX_IMAGE_SUPPORT_CASE(internal, maj, min) \
+    case internal: \
+        if (maj < 3) return true; \
+        if (glesMajorVersion < maj) return false; \
+        if (glesMinorVersion < min) return false; \
+        break; \
+
+#define COMPRESSED_TEX_IMAGE_NOTSUPPORTED(internal) \
+    case internal: \
+        return false ; \
+
+    switch (internalformat) {
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_R11_EAC, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_SIGNED_R11_EAC, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_RG11_EAC, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_SIGNED_RG11_EAC, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_RGB8_ETC2, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_SRGB8_ETC2, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_RGBA8_ETC2_EAC, 2, 0)
+    COMPRESSED_TEX_IMAGE_SUPPORT_CASE(GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, 2, 0)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_4x4_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_5x4_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_5x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_6x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_6x6_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_8x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_8x6_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_8x8_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_10x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_10x6_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_10x8_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_10x10_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_12x10_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_RGBA_ASTC_12x12_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR)
+    COMPRESSED_TEX_IMAGE_NOTSUPPORTED(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR)
+    default:
+        break;
+    }
+    return true;
+}
+
+bool unsizedFormat(GLenum format) {
+    switch (format) {
+    case GL_RED:
+    case GL_RED_INTEGER:
+    case GL_DEPTH_COMPONENT:
+    case GL_DEPTH_STENCIL:
+    case GL_RG:
+    case GL_RG_INTEGER:
+    case GL_RGB:
+    case GL_RGB_INTEGER:
+    case GL_RGBA:
+    case GL_RGBA_INTEGER:
+    case GL_ALPHA:
+    case GL_LUMINANCE:
+    case GL_LUMINANCE_ALPHA:
+        return true;
+    }
+    return false;
+}
+
+// TODO: fix this
+bool filterableTexFormat(GL2Encoder* ctx, GLenum internalformat) {
+    switch (internalformat) {
+    case GL_R32F:
+    case GL_RG32F:
+    case GL_RGB32F:
+    case GL_RGBA32F:
+        return ctx->hasExtension("GL_OES_texture_float");
+    case GL_R8UI:
+    case GL_R8I:
+    case GL_R16UI:
+    case GL_R16I:
+    case GL_R32UI:
+    case GL_R32I:
+    case GL_RG8UI:
+    case GL_RG8I:
+    case GL_RG16UI:
+    case GL_RG16I:
+    case GL_RG32UI:
+    case GL_RG32I:
+    case GL_RGBA8UI:
+    case GL_RGBA8I:
+    case GL_RGB10_A2UI:
+    case GL_RGBA16UI:
+    case GL_RGBA16I:
+    case GL_RGBA32I:
+    case GL_RGBA32UI:
+        return false;
+    }
+    return true;
+}
+
+
+bool colorRenderableFormat(GL2Encoder* ctx, GLenum internalformat) {
+    int glesMajorVersion = ctx->majorVersion();
+    switch (internalformat) {
+    case GL_R8:
+    case GL_RG8:
+    case GL_RGB8:
+    case GL_RGB565:
+    case GL_RGBA4:
+    case GL_RGB5_A1:
+    case GL_RGBA8:
+    case GL_RGB10_A2:
+    case GL_RGB10_A2UI:
+    case GL_SRGB8_ALPHA8:
+    case GL_R8I:
+    case GL_R8UI:
+    case GL_R16I:
+    case GL_R16UI:
+    case GL_R32I:
+    case GL_R32UI:
+    case GL_RG8I:
+    case GL_RG8UI:
+    case GL_RG16I:
+    case GL_RG16UI:
+    case GL_RG32I:
+    case GL_RG32UI:
+    case GL_RGBA8I:
+    case GL_RGBA8UI:
+    case GL_RGBA16I:
+    case GL_RGBA16UI:
+    case GL_RGBA32I:
+    case GL_RGBA32UI:
+        return true;
+    case GL_R16F:
+    case GL_RG16F:
+    case GL_RGBA16F:
+    case GL_R32F:
+    case GL_RG32F:
+    case GL_RGBA32F:
+    case GL_R11F_G11F_B10F:
+        return glesMajorVersion >= 3 && ctx->hasExtension("GL_EXT_color_buffer_float");
+        break;
+    case GL_RGB16F:
+        return glesMajorVersion >= 3 && ctx->hasExtension("GL_EXT_color_buffer_half_float");
+        break;
+    }
+    return false;
+}
+
+bool depthRenderableFormat(GL2Encoder* ctx, GLenum internalformat) {
+    switch (internalformat) {
+    case GL_DEPTH_COMPONENT:
+    case GL_DEPTH_STENCIL:
+    case GL_DEPTH_COMPONENT16:
+    case GL_DEPTH_COMPONENT24:
+    case GL_DEPTH_COMPONENT32F:
+    case GL_DEPTH24_STENCIL8:
+    case GL_DEPTH32F_STENCIL8:
+        return true;
+    }
+    return false;
+}
+
+bool stencilRenderableFormat(GL2Encoder* ctx, GLenum internalformat) {
+    switch (internalformat) {
+    case GL_DEPTH_STENCIL:
+    case GL_STENCIL_INDEX8:
+    case GL_DEPTH24_STENCIL8:
+    case GL_DEPTH32F_STENCIL8:
+        return true;
+    }
+    return false;
+}
+
+bool isCubeMapTarget(GLenum target) {
+    switch (target) {
+    case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+    case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+    case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+        return true;
+    default:
+        break;
+    }
+    return false;
+}
+
+#define LIST_VALID_TEXFORMATS(f) \
+    f(GL_DEPTH_COMPONENT) \
+    f(GL_DEPTH_STENCIL) \
+    f(GL_RED) \
+    f(GL_RED_INTEGER) \
+    f(GL_RG) \
+    f(GL_RGB) \
+    f(GL_RGBA) \
+    f(GL_RGBA_INTEGER) \
+    f(GL_RGB_INTEGER) \
+    f(GL_RG_INTEGER) \
+    f(GL_BGRA_EXT) \
+    f(GL_ALPHA) \
+    f(GL_LUMINANCE) \
+    f(GL_LUMINANCE_ALPHA) \
+
+#define LIST_VALID_TEXTYPES(f) \
+    f(GL_BYTE) \
+    f(GL_FLOAT) \
+    f(GL_FLOAT_32_UNSIGNED_INT_24_8_REV) \
+    f(GL_HALF_FLOAT) \
+    f(GL_HALF_FLOAT_OES) \
+    f(GL_INT) \
+    f(GL_SHORT) \
+    f(GL_UNSIGNED_BYTE) \
+    f(GL_UNSIGNED_INT) \
+    f(GL_UNSIGNED_INT_10F_11F_11F_REV) \
+    f(GL_UNSIGNED_INT_2_10_10_10_REV) \
+    f(GL_UNSIGNED_INT_24_8) \
+    f(GL_UNSIGNED_INT_5_9_9_9_REV) \
+    f(GL_UNSIGNED_SHORT) \
+    f(GL_UNSIGNED_SHORT_4_4_4_4) \
+    f(GL_UNSIGNED_SHORT_5_5_5_1) \
+    f(GL_UNSIGNED_SHORT_5_6_5) \
+
+bool pixelType(GL2Encoder* ctx, GLenum type) {
+    int glesMajorVersion = ctx->majorVersion();
+    if (glesMajorVersion < 3) {
+        switch (type) {
+        case GL_UNSIGNED_BYTE:
+        case GL_UNSIGNED_SHORT:
+        case GL_UNSIGNED_SHORT_5_6_5:
+        case GL_UNSIGNED_SHORT_4_4_4_4:
+        case GL_UNSIGNED_SHORT_5_5_5_1:
+        case GL_UNSIGNED_INT:
+        case GL_UNSIGNED_INT_10F_11F_11F_REV:
+        case GL_UNSIGNED_INT_24_8:
+        case GL_HALF_FLOAT:
+        case GL_HALF_FLOAT_OES:
+        case GL_FLOAT:
+            return true;
+        }
+        return false;
+    }
+
+#define GLES3_TYPE_CASE(type) \
+    case type: \
+
+    switch (type) {
+        LIST_VALID_TEXTYPES(GLES3_TYPE_CASE)
+            return glesMajorVersion >= 3;
+        default:
+            break;
+    }
+
+    return false;
+}
+
+bool pixelFormat(GL2Encoder* ctx, GLenum format) {
+    int glesMajorVersion = ctx->majorVersion();
+    if (glesMajorVersion < 3) {
+        switch (format) {
+            case GL_DEPTH_COMPONENT:
+                // GLES3 compatible
+                // Required in dEQP
+            case GL_RED:
+            case GL_RG:
+            case GL_DEPTH_STENCIL_OES:
+            case GL_ALPHA:
+            case GL_RGB:
+            case GL_RGBA:
+            case GL_BGRA_EXT:
+            case GL_LUMINANCE:
+            case GL_LUMINANCE_ALPHA:
+                return true;
+        }
+        return false;
+    }
+
+#define GLES3_FORMAT_CASE(format) \
+    case format:
+
+    switch (format) {
+        LIST_VALID_TEXFORMATS(GLES3_FORMAT_CASE)
+            return glesMajorVersion >= 3;
+        default:
+            break;
+    }
+    return false;
+}
+#define LIST_VALID_TEX_INTERNALFORMATS(f) \
+    f(GL_R8) \
+    f(GL_R8_SNORM) \
+    f(GL_R16F) \
+    f(GL_R32F) \
+    f(GL_R8UI) \
+    f(GL_R8I) \
+    f(GL_R16UI) \
+    f(GL_R16I) \
+    f(GL_R32UI) \
+    f(GL_R32I) \
+    f(GL_RG8) \
+    f(GL_RG8_SNORM) \
+    f(GL_RG16F) \
+    f(GL_RG32F) \
+    f(GL_RG8UI) \
+    f(GL_RG8I) \
+    f(GL_RG16UI) \
+    f(GL_RG16I) \
+    f(GL_RG32UI) \
+    f(GL_RG32I) \
+    f(GL_RGB8) \
+    f(GL_SRGB8) \
+    f(GL_RGB565) \
+    f(GL_RGB8_SNORM) \
+    f(GL_R11F_G11F_B10F) \
+    f(GL_RGB9_E5) \
+    f(GL_RGB16F) \
+    f(GL_RGB32F) \
+    f(GL_RGB8UI) \
+    f(GL_RGB8I) \
+    f(GL_RGB16UI) \
+    f(GL_RGB16I) \
+    f(GL_RGB32UI) \
+    f(GL_RGB32I) \
+    f(GL_RGBA8) \
+    f(GL_SRGB8_ALPHA8) \
+    f(GL_RGBA8_SNORM) \
+    f(GL_RGB5_A1) \
+    f(GL_RGBA4) \
+    f(GL_RGB10_A2) \
+    f(GL_RGBA16F) \
+    f(GL_RGBA32F) \
+    f(GL_RGBA8UI) \
+    f(GL_RGBA8I) \
+    f(GL_RGB10_A2UI) \
+    f(GL_RGBA16UI) \
+    f(GL_RGBA16I) \
+    f(GL_RGBA32I) \
+    f(GL_RGBA32UI) \
+    f(GL_DEPTH_COMPONENT16) \
+    f(GL_DEPTH_COMPONENT24) \
+    f(GL_DEPTH_COMPONENT32F) \
+    f(GL_DEPTH24_STENCIL8) \
+    f(GL_DEPTH32F_STENCIL8) \
+    f(GL_COMPRESSED_R11_EAC) \
+    f(GL_COMPRESSED_SIGNED_R11_EAC) \
+    f(GL_COMPRESSED_RG11_EAC) \
+    f(GL_COMPRESSED_SIGNED_RG11_EAC) \
+    f(GL_COMPRESSED_RGB8_ETC2) \
+    f(GL_COMPRESSED_SRGB8_ETC2) \
+    f(GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2) \
+    f(GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2) \
+    f(GL_COMPRESSED_RGBA8_ETC2_EAC) \
+    f(GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC) \
+
+bool pixelInternalFormat(GLenum internalformat) {
+#define VALID_INTERNAL_FORMAT(format) \
+    case format: \
+        return true; \
+
+    switch (internalformat) {
+    LIST_VALID_TEX_INTERNALFORMATS(VALID_INTERNAL_FORMAT)
+    default:
+        break;
+    }
+    return false;
+}
+
+bool shaderType(GL2Encoder* ctx, GLenum type) {
+    int glesMajorVersion = ctx->majorVersion();
+    int glesMinorVersion = ctx->minorVersion();
+    switch (type) {
+    case GL_VERTEX_SHADER:
+    case GL_FRAGMENT_SHADER:
+        return true;
+    case GL_COMPUTE_SHADER:
+        return glesMajorVersion >= 3 && glesMinorVersion >= 1;
+    }
+    return false;
+}
+
+bool internalFormatTarget(GL2Encoder* ctx, GLenum target) {
+    int glesMajorVersion = ctx->majorVersion();
+    int glesMinorVersion = ctx->minorVersion();
+    switch (target) {
+    case GL_RENDERBUFFER:
+        return true;
+    case GL_TEXTURE_2D_MULTISAMPLE:
+        return glesMajorVersion >= 3 && glesMinorVersion >= 1;
+    }
+    return false;
+}
+
+std::string vertexAttribIndexRangeErrorMsg(GL2Encoder* ctx, GLuint index) {
+    std::stringstream ss;
+    GLint maxIndex;
+    ctx->glGetIntegerv(ctx, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
+    ss << "Invalid vertex attribute index. Wanted index: " << index << ". Max index: " << maxIndex;
+    return ss.str();
+}
+
+} // namespace GLESv2Validation
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/GLESv2Validation.h b/vendor/anbox/android/opengl/system/GLESv2_enc/GLESv2Validation.h
new file mode 100644
index 0000000..a37bd58
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/GLESv2Validation.h
@@ -0,0 +1,82 @@
+/*
+* Copyright (C) 2016 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef GLES_VALIDATION_H
+#define GLES_VALIDATION_H
+
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#include <GLES2/gl2platform.h>
+
+#include <GLES3/gl3.h>
+#include <GLES3/gl31.h>
+
+#include "GL2Encoder.h"
+
+#include <string>
+
+namespace GLESv2Validation {
+
+extern GLbitfield allBufferMapAccessFlags;
+bool bufferTarget(GL2Encoder* ctx, GLenum target);
+bool bufferParam(GL2Encoder* ctx, GLenum param);
+
+bool pixelStoreParam(GL2Encoder* ctx, GLenum param);
+bool pixelStoreValue(GLenum param, GLint value);
+
+bool rboFormat(GL2Encoder* ctx, GLenum internalformat);
+
+bool framebufferTarget(GL2Encoder* ctx, GLenum target);
+bool framebufferAttachment(GL2Encoder* ctx, GLenum attachment);
+
+bool readPixelsFormat(GLenum format);
+bool readPixelsType(GLenum type);
+
+bool vertexAttribType(GL2Encoder* ctx, GLenum type);
+
+bool readPixelsFboFormatMatch(GLenum format, GLenum type, GLenum fboTexType);
+bool blitFramebufferFormat(GLenum readFormat, GLenum drawFormat);
+
+bool textureTarget(GL2Encoder* ctx, GLenum target);
+
+GLsizei compressedTexImageSize(GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
+
+bool isCompressedFormat(GLenum internalformat);
+bool supportedCompressedFormat(GL2Encoder* ctx, GLenum internalformat);
+
+bool unsizedFormat(GLenum format);
+
+bool filterableTexFormat(GL2Encoder* ctx, GLenum internalformat);
+bool colorRenderableFormat(GL2Encoder* ctx, GLenum internalformat);
+bool depthRenderableFormat(GL2Encoder* ctx, GLenum internalformat);
+bool stencilRenderableFormat(GL2Encoder* ctx, GLenum internalformat);
+
+bool isCubeMapTarget(GLenum target);
+
+bool pixelType(GL2Encoder* ctx, GLenum type);
+bool pixelFormat(GL2Encoder* ctx, GLenum format);
+
+bool pixelInternalFormat(GLenum internalformat);
+
+bool shaderType(GL2Encoder* ctx, GLenum type);
+
+bool internalFormatTarget(GL2Encoder* ctx, GLenum target);
+
+std::string vertexAttribIndexRangeErrorMsg(GL2Encoder* ctx, GLuint index);
+
+} // namespace GLESv2Validation
+
+#endif
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.cpp b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.cpp
index f903542..9eb4ac4 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.cpp
@@ -218,6 +218,209 @@ int gl2_client_context_t::initDispatchByName(void *(*getProc)(const char *, void
 	glGetCompressedTextureFormats = (glGetCompressedTextureFormats_client_proc_t) getProc("glGetCompressedTextureFormats", userData);
 	glShaderString = (glShaderString_client_proc_t) getProc("glShaderString", userData);
 	glFinishRoundTrip = (glFinishRoundTrip_client_proc_t) getProc("glFinishRoundTrip", userData);
+	glGenVertexArrays = (glGenVertexArrays_client_proc_t) getProc("glGenVertexArrays", userData);
+	glBindVertexArray = (glBindVertexArray_client_proc_t) getProc("glBindVertexArray", userData);
+	glDeleteVertexArrays = (glDeleteVertexArrays_client_proc_t) getProc("glDeleteVertexArrays", userData);
+	glIsVertexArray = (glIsVertexArray_client_proc_t) getProc("glIsVertexArray", userData);
+	glMapBufferRange = (glMapBufferRange_client_proc_t) getProc("glMapBufferRange", userData);
+	glUnmapBuffer = (glUnmapBuffer_client_proc_t) getProc("glUnmapBuffer", userData);
+	glFlushMappedBufferRange = (glFlushMappedBufferRange_client_proc_t) getProc("glFlushMappedBufferRange", userData);
+	glMapBufferRangeAEMU = (glMapBufferRangeAEMU_client_proc_t) getProc("glMapBufferRangeAEMU", userData);
+	glUnmapBufferAEMU = (glUnmapBufferAEMU_client_proc_t) getProc("glUnmapBufferAEMU", userData);
+	glFlushMappedBufferRangeAEMU = (glFlushMappedBufferRangeAEMU_client_proc_t) getProc("glFlushMappedBufferRangeAEMU", userData);
+	glReadPixelsOffsetAEMU = (glReadPixelsOffsetAEMU_client_proc_t) getProc("glReadPixelsOffsetAEMU", userData);
+	glCompressedTexImage2DOffsetAEMU = (glCompressedTexImage2DOffsetAEMU_client_proc_t) getProc("glCompressedTexImage2DOffsetAEMU", userData);
+	glCompressedTexSubImage2DOffsetAEMU = (glCompressedTexSubImage2DOffsetAEMU_client_proc_t) getProc("glCompressedTexSubImage2DOffsetAEMU", userData);
+	glTexImage2DOffsetAEMU = (glTexImage2DOffsetAEMU_client_proc_t) getProc("glTexImage2DOffsetAEMU", userData);
+	glTexSubImage2DOffsetAEMU = (glTexSubImage2DOffsetAEMU_client_proc_t) getProc("glTexSubImage2DOffsetAEMU", userData);
+	glBindBufferRange = (glBindBufferRange_client_proc_t) getProc("glBindBufferRange", userData);
+	glBindBufferBase = (glBindBufferBase_client_proc_t) getProc("glBindBufferBase", userData);
+	glCopyBufferSubData = (glCopyBufferSubData_client_proc_t) getProc("glCopyBufferSubData", userData);
+	glClearBufferiv = (glClearBufferiv_client_proc_t) getProc("glClearBufferiv", userData);
+	glClearBufferuiv = (glClearBufferuiv_client_proc_t) getProc("glClearBufferuiv", userData);
+	glClearBufferfv = (glClearBufferfv_client_proc_t) getProc("glClearBufferfv", userData);
+	glClearBufferfi = (glClearBufferfi_client_proc_t) getProc("glClearBufferfi", userData);
+	glGetBufferParameteri64v = (glGetBufferParameteri64v_client_proc_t) getProc("glGetBufferParameteri64v", userData);
+	glGetBufferPointerv = (glGetBufferPointerv_client_proc_t) getProc("glGetBufferPointerv", userData);
+	glUniformBlockBinding = (glUniformBlockBinding_client_proc_t) getProc("glUniformBlockBinding", userData);
+	glGetUniformBlockIndex = (glGetUniformBlockIndex_client_proc_t) getProc("glGetUniformBlockIndex", userData);
+	glGetUniformIndices = (glGetUniformIndices_client_proc_t) getProc("glGetUniformIndices", userData);
+	glGetUniformIndicesAEMU = (glGetUniformIndicesAEMU_client_proc_t) getProc("glGetUniformIndicesAEMU", userData);
+	glGetActiveUniformBlockiv = (glGetActiveUniformBlockiv_client_proc_t) getProc("glGetActiveUniformBlockiv", userData);
+	glGetActiveUniformBlockName = (glGetActiveUniformBlockName_client_proc_t) getProc("glGetActiveUniformBlockName", userData);
+	glUniform1ui = (glUniform1ui_client_proc_t) getProc("glUniform1ui", userData);
+	glUniform2ui = (glUniform2ui_client_proc_t) getProc("glUniform2ui", userData);
+	glUniform3ui = (glUniform3ui_client_proc_t) getProc("glUniform3ui", userData);
+	glUniform4ui = (glUniform4ui_client_proc_t) getProc("glUniform4ui", userData);
+	glUniform1uiv = (glUniform1uiv_client_proc_t) getProc("glUniform1uiv", userData);
+	glUniform2uiv = (glUniform2uiv_client_proc_t) getProc("glUniform2uiv", userData);
+	glUniform3uiv = (glUniform3uiv_client_proc_t) getProc("glUniform3uiv", userData);
+	glUniform4uiv = (glUniform4uiv_client_proc_t) getProc("glUniform4uiv", userData);
+	glUniformMatrix2x3fv = (glUniformMatrix2x3fv_client_proc_t) getProc("glUniformMatrix2x3fv", userData);
+	glUniformMatrix3x2fv = (glUniformMatrix3x2fv_client_proc_t) getProc("glUniformMatrix3x2fv", userData);
+	glUniformMatrix2x4fv = (glUniformMatrix2x4fv_client_proc_t) getProc("glUniformMatrix2x4fv", userData);
+	glUniformMatrix4x2fv = (glUniformMatrix4x2fv_client_proc_t) getProc("glUniformMatrix4x2fv", userData);
+	glUniformMatrix3x4fv = (glUniformMatrix3x4fv_client_proc_t) getProc("glUniformMatrix3x4fv", userData);
+	glUniformMatrix4x3fv = (glUniformMatrix4x3fv_client_proc_t) getProc("glUniformMatrix4x3fv", userData);
+	glGetUniformuiv = (glGetUniformuiv_client_proc_t) getProc("glGetUniformuiv", userData);
+	glGetActiveUniformsiv = (glGetActiveUniformsiv_client_proc_t) getProc("glGetActiveUniformsiv", userData);
+	glVertexAttribI4i = (glVertexAttribI4i_client_proc_t) getProc("glVertexAttribI4i", userData);
+	glVertexAttribI4ui = (glVertexAttribI4ui_client_proc_t) getProc("glVertexAttribI4ui", userData);
+	glVertexAttribI4iv = (glVertexAttribI4iv_client_proc_t) getProc("glVertexAttribI4iv", userData);
+	glVertexAttribI4uiv = (glVertexAttribI4uiv_client_proc_t) getProc("glVertexAttribI4uiv", userData);
+	glVertexAttribIPointer = (glVertexAttribIPointer_client_proc_t) getProc("glVertexAttribIPointer", userData);
+	glVertexAttribIPointerOffsetAEMU = (glVertexAttribIPointerOffsetAEMU_client_proc_t) getProc("glVertexAttribIPointerOffsetAEMU", userData);
+	glVertexAttribIPointerDataAEMU = (glVertexAttribIPointerDataAEMU_client_proc_t) getProc("glVertexAttribIPointerDataAEMU", userData);
+	glGetVertexAttribIiv = (glGetVertexAttribIiv_client_proc_t) getProc("glGetVertexAttribIiv", userData);
+	glGetVertexAttribIuiv = (glGetVertexAttribIuiv_client_proc_t) getProc("glGetVertexAttribIuiv", userData);
+	glVertexAttribDivisor = (glVertexAttribDivisor_client_proc_t) getProc("glVertexAttribDivisor", userData);
+	glDrawArraysInstanced = (glDrawArraysInstanced_client_proc_t) getProc("glDrawArraysInstanced", userData);
+	glDrawElementsInstanced = (glDrawElementsInstanced_client_proc_t) getProc("glDrawElementsInstanced", userData);
+	glDrawElementsInstancedDataAEMU = (glDrawElementsInstancedDataAEMU_client_proc_t) getProc("glDrawElementsInstancedDataAEMU", userData);
+	glDrawElementsInstancedOffsetAEMU = (glDrawElementsInstancedOffsetAEMU_client_proc_t) getProc("glDrawElementsInstancedOffsetAEMU", userData);
+	glDrawRangeElements = (glDrawRangeElements_client_proc_t) getProc("glDrawRangeElements", userData);
+	glDrawRangeElementsDataAEMU = (glDrawRangeElementsDataAEMU_client_proc_t) getProc("glDrawRangeElementsDataAEMU", userData);
+	glDrawRangeElementsOffsetAEMU = (glDrawRangeElementsOffsetAEMU_client_proc_t) getProc("glDrawRangeElementsOffsetAEMU", userData);
+	glFenceSync = (glFenceSync_client_proc_t) getProc("glFenceSync", userData);
+	glClientWaitSync = (glClientWaitSync_client_proc_t) getProc("glClientWaitSync", userData);
+	glWaitSync = (glWaitSync_client_proc_t) getProc("glWaitSync", userData);
+	glDeleteSync = (glDeleteSync_client_proc_t) getProc("glDeleteSync", userData);
+	glIsSync = (glIsSync_client_proc_t) getProc("glIsSync", userData);
+	glGetSynciv = (glGetSynciv_client_proc_t) getProc("glGetSynciv", userData);
+	glFenceSyncAEMU = (glFenceSyncAEMU_client_proc_t) getProc("glFenceSyncAEMU", userData);
+	glClientWaitSyncAEMU = (glClientWaitSyncAEMU_client_proc_t) getProc("glClientWaitSyncAEMU", userData);
+	glWaitSyncAEMU = (glWaitSyncAEMU_client_proc_t) getProc("glWaitSyncAEMU", userData);
+	glDeleteSyncAEMU = (glDeleteSyncAEMU_client_proc_t) getProc("glDeleteSyncAEMU", userData);
+	glIsSyncAEMU = (glIsSyncAEMU_client_proc_t) getProc("glIsSyncAEMU", userData);
+	glGetSyncivAEMU = (glGetSyncivAEMU_client_proc_t) getProc("glGetSyncivAEMU", userData);
+	glDrawBuffers = (glDrawBuffers_client_proc_t) getProc("glDrawBuffers", userData);
+	glReadBuffer = (glReadBuffer_client_proc_t) getProc("glReadBuffer", userData);
+	glBlitFramebuffer = (glBlitFramebuffer_client_proc_t) getProc("glBlitFramebuffer", userData);
+	glInvalidateFramebuffer = (glInvalidateFramebuffer_client_proc_t) getProc("glInvalidateFramebuffer", userData);
+	glInvalidateSubFramebuffer = (glInvalidateSubFramebuffer_client_proc_t) getProc("glInvalidateSubFramebuffer", userData);
+	glFramebufferTextureLayer = (glFramebufferTextureLayer_client_proc_t) getProc("glFramebufferTextureLayer", userData);
+	glRenderbufferStorageMultisample = (glRenderbufferStorageMultisample_client_proc_t) getProc("glRenderbufferStorageMultisample", userData);
+	glTexStorage2D = (glTexStorage2D_client_proc_t) getProc("glTexStorage2D", userData);
+	glGetInternalformativ = (glGetInternalformativ_client_proc_t) getProc("glGetInternalformativ", userData);
+	glBeginTransformFeedback = (glBeginTransformFeedback_client_proc_t) getProc("glBeginTransformFeedback", userData);
+	glEndTransformFeedback = (glEndTransformFeedback_client_proc_t) getProc("glEndTransformFeedback", userData);
+	glGenTransformFeedbacks = (glGenTransformFeedbacks_client_proc_t) getProc("glGenTransformFeedbacks", userData);
+	glDeleteTransformFeedbacks = (glDeleteTransformFeedbacks_client_proc_t) getProc("glDeleteTransformFeedbacks", userData);
+	glBindTransformFeedback = (glBindTransformFeedback_client_proc_t) getProc("glBindTransformFeedback", userData);
+	glPauseTransformFeedback = (glPauseTransformFeedback_client_proc_t) getProc("glPauseTransformFeedback", userData);
+	glResumeTransformFeedback = (glResumeTransformFeedback_client_proc_t) getProc("glResumeTransformFeedback", userData);
+	glIsTransformFeedback = (glIsTransformFeedback_client_proc_t) getProc("glIsTransformFeedback", userData);
+	glTransformFeedbackVaryings = (glTransformFeedbackVaryings_client_proc_t) getProc("glTransformFeedbackVaryings", userData);
+	glTransformFeedbackVaryingsAEMU = (glTransformFeedbackVaryingsAEMU_client_proc_t) getProc("glTransformFeedbackVaryingsAEMU", userData);
+	glGetTransformFeedbackVarying = (glGetTransformFeedbackVarying_client_proc_t) getProc("glGetTransformFeedbackVarying", userData);
+	glGenSamplers = (glGenSamplers_client_proc_t) getProc("glGenSamplers", userData);
+	glDeleteSamplers = (glDeleteSamplers_client_proc_t) getProc("glDeleteSamplers", userData);
+	glBindSampler = (glBindSampler_client_proc_t) getProc("glBindSampler", userData);
+	glSamplerParameterf = (glSamplerParameterf_client_proc_t) getProc("glSamplerParameterf", userData);
+	glSamplerParameteri = (glSamplerParameteri_client_proc_t) getProc("glSamplerParameteri", userData);
+	glSamplerParameterfv = (glSamplerParameterfv_client_proc_t) getProc("glSamplerParameterfv", userData);
+	glSamplerParameteriv = (glSamplerParameteriv_client_proc_t) getProc("glSamplerParameteriv", userData);
+	glGetSamplerParameterfv = (glGetSamplerParameterfv_client_proc_t) getProc("glGetSamplerParameterfv", userData);
+	glGetSamplerParameteriv = (glGetSamplerParameteriv_client_proc_t) getProc("glGetSamplerParameteriv", userData);
+	glIsSampler = (glIsSampler_client_proc_t) getProc("glIsSampler", userData);
+	glGenQueries = (glGenQueries_client_proc_t) getProc("glGenQueries", userData);
+	glDeleteQueries = (glDeleteQueries_client_proc_t) getProc("glDeleteQueries", userData);
+	glBeginQuery = (glBeginQuery_client_proc_t) getProc("glBeginQuery", userData);
+	glEndQuery = (glEndQuery_client_proc_t) getProc("glEndQuery", userData);
+	glGetQueryiv = (glGetQueryiv_client_proc_t) getProc("glGetQueryiv", userData);
+	glGetQueryObjectuiv = (glGetQueryObjectuiv_client_proc_t) getProc("glGetQueryObjectuiv", userData);
+	glIsQuery = (glIsQuery_client_proc_t) getProc("glIsQuery", userData);
+	glProgramParameteri = (glProgramParameteri_client_proc_t) getProc("glProgramParameteri", userData);
+	glProgramBinary = (glProgramBinary_client_proc_t) getProc("glProgramBinary", userData);
+	glGetProgramBinary = (glGetProgramBinary_client_proc_t) getProc("glGetProgramBinary", userData);
+	glGetFragDataLocation = (glGetFragDataLocation_client_proc_t) getProc("glGetFragDataLocation", userData);
+	glGetInteger64v = (glGetInteger64v_client_proc_t) getProc("glGetInteger64v", userData);
+	glGetIntegeri_v = (glGetIntegeri_v_client_proc_t) getProc("glGetIntegeri_v", userData);
+	glGetInteger64i_v = (glGetInteger64i_v_client_proc_t) getProc("glGetInteger64i_v", userData);
+	glTexImage3D = (glTexImage3D_client_proc_t) getProc("glTexImage3D", userData);
+	glTexImage3DOffsetAEMU = (glTexImage3DOffsetAEMU_client_proc_t) getProc("glTexImage3DOffsetAEMU", userData);
+	glTexStorage3D = (glTexStorage3D_client_proc_t) getProc("glTexStorage3D", userData);
+	glTexSubImage3D = (glTexSubImage3D_client_proc_t) getProc("glTexSubImage3D", userData);
+	glTexSubImage3DOffsetAEMU = (glTexSubImage3DOffsetAEMU_client_proc_t) getProc("glTexSubImage3DOffsetAEMU", userData);
+	glCompressedTexImage3D = (glCompressedTexImage3D_client_proc_t) getProc("glCompressedTexImage3D", userData);
+	glCompressedTexImage3DOffsetAEMU = (glCompressedTexImage3DOffsetAEMU_client_proc_t) getProc("glCompressedTexImage3DOffsetAEMU", userData);
+	glCompressedTexSubImage3D = (glCompressedTexSubImage3D_client_proc_t) getProc("glCompressedTexSubImage3D", userData);
+	glCompressedTexSubImage3DOffsetAEMU = (glCompressedTexSubImage3DOffsetAEMU_client_proc_t) getProc("glCompressedTexSubImage3DOffsetAEMU", userData);
+	glCopyTexSubImage3D = (glCopyTexSubImage3D_client_proc_t) getProc("glCopyTexSubImage3D", userData);
+	glGetStringi = (glGetStringi_client_proc_t) getProc("glGetStringi", userData);
+	glGetBooleani_v = (glGetBooleani_v_client_proc_t) getProc("glGetBooleani_v", userData);
+	glMemoryBarrier = (glMemoryBarrier_client_proc_t) getProc("glMemoryBarrier", userData);
+	glMemoryBarrierByRegion = (glMemoryBarrierByRegion_client_proc_t) getProc("glMemoryBarrierByRegion", userData);
+	glGenProgramPipelines = (glGenProgramPipelines_client_proc_t) getProc("glGenProgramPipelines", userData);
+	glDeleteProgramPipelines = (glDeleteProgramPipelines_client_proc_t) getProc("glDeleteProgramPipelines", userData);
+	glBindProgramPipeline = (glBindProgramPipeline_client_proc_t) getProc("glBindProgramPipeline", userData);
+	glGetProgramPipelineiv = (glGetProgramPipelineiv_client_proc_t) getProc("glGetProgramPipelineiv", userData);
+	glGetProgramPipelineInfoLog = (glGetProgramPipelineInfoLog_client_proc_t) getProc("glGetProgramPipelineInfoLog", userData);
+	glValidateProgramPipeline = (glValidateProgramPipeline_client_proc_t) getProc("glValidateProgramPipeline", userData);
+	glIsProgramPipeline = (glIsProgramPipeline_client_proc_t) getProc("glIsProgramPipeline", userData);
+	glUseProgramStages = (glUseProgramStages_client_proc_t) getProc("glUseProgramStages", userData);
+	glActiveShaderProgram = (glActiveShaderProgram_client_proc_t) getProc("glActiveShaderProgram", userData);
+	glCreateShaderProgramv = (glCreateShaderProgramv_client_proc_t) getProc("glCreateShaderProgramv", userData);
+	glCreateShaderProgramvAEMU = (glCreateShaderProgramvAEMU_client_proc_t) getProc("glCreateShaderProgramvAEMU", userData);
+	glProgramUniform1f = (glProgramUniform1f_client_proc_t) getProc("glProgramUniform1f", userData);
+	glProgramUniform2f = (glProgramUniform2f_client_proc_t) getProc("glProgramUniform2f", userData);
+	glProgramUniform3f = (glProgramUniform3f_client_proc_t) getProc("glProgramUniform3f", userData);
+	glProgramUniform4f = (glProgramUniform4f_client_proc_t) getProc("glProgramUniform4f", userData);
+	glProgramUniform1i = (glProgramUniform1i_client_proc_t) getProc("glProgramUniform1i", userData);
+	glProgramUniform2i = (glProgramUniform2i_client_proc_t) getProc("glProgramUniform2i", userData);
+	glProgramUniform3i = (glProgramUniform3i_client_proc_t) getProc("glProgramUniform3i", userData);
+	glProgramUniform4i = (glProgramUniform4i_client_proc_t) getProc("glProgramUniform4i", userData);
+	glProgramUniform1ui = (glProgramUniform1ui_client_proc_t) getProc("glProgramUniform1ui", userData);
+	glProgramUniform2ui = (glProgramUniform2ui_client_proc_t) getProc("glProgramUniform2ui", userData);
+	glProgramUniform3ui = (glProgramUniform3ui_client_proc_t) getProc("glProgramUniform3ui", userData);
+	glProgramUniform4ui = (glProgramUniform4ui_client_proc_t) getProc("glProgramUniform4ui", userData);
+	glProgramUniform1fv = (glProgramUniform1fv_client_proc_t) getProc("glProgramUniform1fv", userData);
+	glProgramUniform2fv = (glProgramUniform2fv_client_proc_t) getProc("glProgramUniform2fv", userData);
+	glProgramUniform3fv = (glProgramUniform3fv_client_proc_t) getProc("glProgramUniform3fv", userData);
+	glProgramUniform4fv = (glProgramUniform4fv_client_proc_t) getProc("glProgramUniform4fv", userData);
+	glProgramUniform1iv = (glProgramUniform1iv_client_proc_t) getProc("glProgramUniform1iv", userData);
+	glProgramUniform2iv = (glProgramUniform2iv_client_proc_t) getProc("glProgramUniform2iv", userData);
+	glProgramUniform3iv = (glProgramUniform3iv_client_proc_t) getProc("glProgramUniform3iv", userData);
+	glProgramUniform4iv = (glProgramUniform4iv_client_proc_t) getProc("glProgramUniform4iv", userData);
+	glProgramUniform1uiv = (glProgramUniform1uiv_client_proc_t) getProc("glProgramUniform1uiv", userData);
+	glProgramUniform2uiv = (glProgramUniform2uiv_client_proc_t) getProc("glProgramUniform2uiv", userData);
+	glProgramUniform3uiv = (glProgramUniform3uiv_client_proc_t) getProc("glProgramUniform3uiv", userData);
+	glProgramUniform4uiv = (glProgramUniform4uiv_client_proc_t) getProc("glProgramUniform4uiv", userData);
+	glProgramUniformMatrix2fv = (glProgramUniformMatrix2fv_client_proc_t) getProc("glProgramUniformMatrix2fv", userData);
+	glProgramUniformMatrix3fv = (glProgramUniformMatrix3fv_client_proc_t) getProc("glProgramUniformMatrix3fv", userData);
+	glProgramUniformMatrix4fv = (glProgramUniformMatrix4fv_client_proc_t) getProc("glProgramUniformMatrix4fv", userData);
+	glProgramUniformMatrix2x3fv = (glProgramUniformMatrix2x3fv_client_proc_t) getProc("glProgramUniformMatrix2x3fv", userData);
+	glProgramUniformMatrix3x2fv = (glProgramUniformMatrix3x2fv_client_proc_t) getProc("glProgramUniformMatrix3x2fv", userData);
+	glProgramUniformMatrix2x4fv = (glProgramUniformMatrix2x4fv_client_proc_t) getProc("glProgramUniformMatrix2x4fv", userData);
+	glProgramUniformMatrix4x2fv = (glProgramUniformMatrix4x2fv_client_proc_t) getProc("glProgramUniformMatrix4x2fv", userData);
+	glProgramUniformMatrix3x4fv = (glProgramUniformMatrix3x4fv_client_proc_t) getProc("glProgramUniformMatrix3x4fv", userData);
+	glProgramUniformMatrix4x3fv = (glProgramUniformMatrix4x3fv_client_proc_t) getProc("glProgramUniformMatrix4x3fv", userData);
+	glGetProgramInterfaceiv = (glGetProgramInterfaceiv_client_proc_t) getProc("glGetProgramInterfaceiv", userData);
+	glGetProgramResourceiv = (glGetProgramResourceiv_client_proc_t) getProc("glGetProgramResourceiv", userData);
+	glGetProgramResourceIndex = (glGetProgramResourceIndex_client_proc_t) getProc("glGetProgramResourceIndex", userData);
+	glGetProgramResourceLocation = (glGetProgramResourceLocation_client_proc_t) getProc("glGetProgramResourceLocation", userData);
+	glGetProgramResourceName = (glGetProgramResourceName_client_proc_t) getProc("glGetProgramResourceName", userData);
+	glBindImageTexture = (glBindImageTexture_client_proc_t) getProc("glBindImageTexture", userData);
+	glDispatchCompute = (glDispatchCompute_client_proc_t) getProc("glDispatchCompute", userData);
+	glDispatchComputeIndirect = (glDispatchComputeIndirect_client_proc_t) getProc("glDispatchComputeIndirect", userData);
+	glBindVertexBuffer = (glBindVertexBuffer_client_proc_t) getProc("glBindVertexBuffer", userData);
+	glVertexAttribBinding = (glVertexAttribBinding_client_proc_t) getProc("glVertexAttribBinding", userData);
+	glVertexAttribFormat = (glVertexAttribFormat_client_proc_t) getProc("glVertexAttribFormat", userData);
+	glVertexAttribIFormat = (glVertexAttribIFormat_client_proc_t) getProc("glVertexAttribIFormat", userData);
+	glVertexBindingDivisor = (glVertexBindingDivisor_client_proc_t) getProc("glVertexBindingDivisor", userData);
+	glDrawArraysIndirect = (glDrawArraysIndirect_client_proc_t) getProc("glDrawArraysIndirect", userData);
+	glDrawArraysIndirectDataAEMU = (glDrawArraysIndirectDataAEMU_client_proc_t) getProc("glDrawArraysIndirectDataAEMU", userData);
+	glDrawArraysIndirectOffsetAEMU = (glDrawArraysIndirectOffsetAEMU_client_proc_t) getProc("glDrawArraysIndirectOffsetAEMU", userData);
+	glDrawElementsIndirect = (glDrawElementsIndirect_client_proc_t) getProc("glDrawElementsIndirect", userData);
+	glDrawElementsIndirectDataAEMU = (glDrawElementsIndirectDataAEMU_client_proc_t) getProc("glDrawElementsIndirectDataAEMU", userData);
+	glDrawElementsIndirectOffsetAEMU = (glDrawElementsIndirectOffsetAEMU_client_proc_t) getProc("glDrawElementsIndirectOffsetAEMU", userData);
+	glTexStorage2DMultisample = (glTexStorage2DMultisample_client_proc_t) getProc("glTexStorage2DMultisample", userData);
+	glSampleMaski = (glSampleMaski_client_proc_t) getProc("glSampleMaski", userData);
+	glGetMultisamplefv = (glGetMultisamplefv_client_proc_t) getProc("glGetMultisamplefv", userData);
+	glFramebufferParameteri = (glFramebufferParameteri_client_proc_t) getProc("glFramebufferParameteri", userData);
+	glGetFramebufferParameteriv = (glGetFramebufferParameteriv_client_proc_t) getProc("glGetFramebufferParameteriv", userData);
+	glGetTexLevelParameterfv = (glGetTexLevelParameterfv_client_proc_t) getProc("glGetTexLevelParameterfv", userData);
+	glGetTexLevelParameteriv = (glGetTexLevelParameteriv_client_proc_t) getProc("glGetTexLevelParameteriv", userData);
 	return 0;
 }
 
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.h b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.h
index 7035fec..6616e53 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_context.h
@@ -218,7 +218,210 @@ struct gl2_client_context_t {
 	glGetCompressedTextureFormats_client_proc_t glGetCompressedTextureFormats;
 	glShaderString_client_proc_t glShaderString;
 	glFinishRoundTrip_client_proc_t glFinishRoundTrip;
-	 virtual ~gl2_client_context_t() {}
+	glGenVertexArrays_client_proc_t glGenVertexArrays;
+	glBindVertexArray_client_proc_t glBindVertexArray;
+	glDeleteVertexArrays_client_proc_t glDeleteVertexArrays;
+	glIsVertexArray_client_proc_t glIsVertexArray;
+	glMapBufferRange_client_proc_t glMapBufferRange;
+	glUnmapBuffer_client_proc_t glUnmapBuffer;
+	glFlushMappedBufferRange_client_proc_t glFlushMappedBufferRange;
+	glMapBufferRangeAEMU_client_proc_t glMapBufferRangeAEMU;
+	glUnmapBufferAEMU_client_proc_t glUnmapBufferAEMU;
+	glFlushMappedBufferRangeAEMU_client_proc_t glFlushMappedBufferRangeAEMU;
+	glReadPixelsOffsetAEMU_client_proc_t glReadPixelsOffsetAEMU;
+	glCompressedTexImage2DOffsetAEMU_client_proc_t glCompressedTexImage2DOffsetAEMU;
+	glCompressedTexSubImage2DOffsetAEMU_client_proc_t glCompressedTexSubImage2DOffsetAEMU;
+	glTexImage2DOffsetAEMU_client_proc_t glTexImage2DOffsetAEMU;
+	glTexSubImage2DOffsetAEMU_client_proc_t glTexSubImage2DOffsetAEMU;
+	glBindBufferRange_client_proc_t glBindBufferRange;
+	glBindBufferBase_client_proc_t glBindBufferBase;
+	glCopyBufferSubData_client_proc_t glCopyBufferSubData;
+	glClearBufferiv_client_proc_t glClearBufferiv;
+	glClearBufferuiv_client_proc_t glClearBufferuiv;
+	glClearBufferfv_client_proc_t glClearBufferfv;
+	glClearBufferfi_client_proc_t glClearBufferfi;
+	glGetBufferParameteri64v_client_proc_t glGetBufferParameteri64v;
+	glGetBufferPointerv_client_proc_t glGetBufferPointerv;
+	glUniformBlockBinding_client_proc_t glUniformBlockBinding;
+	glGetUniformBlockIndex_client_proc_t glGetUniformBlockIndex;
+	glGetUniformIndices_client_proc_t glGetUniformIndices;
+	glGetUniformIndicesAEMU_client_proc_t glGetUniformIndicesAEMU;
+	glGetActiveUniformBlockiv_client_proc_t glGetActiveUniformBlockiv;
+	glGetActiveUniformBlockName_client_proc_t glGetActiveUniformBlockName;
+	glUniform1ui_client_proc_t glUniform1ui;
+	glUniform2ui_client_proc_t glUniform2ui;
+	glUniform3ui_client_proc_t glUniform3ui;
+	glUniform4ui_client_proc_t glUniform4ui;
+	glUniform1uiv_client_proc_t glUniform1uiv;
+	glUniform2uiv_client_proc_t glUniform2uiv;
+	glUniform3uiv_client_proc_t glUniform3uiv;
+	glUniform4uiv_client_proc_t glUniform4uiv;
+	glUniformMatrix2x3fv_client_proc_t glUniformMatrix2x3fv;
+	glUniformMatrix3x2fv_client_proc_t glUniformMatrix3x2fv;
+	glUniformMatrix2x4fv_client_proc_t glUniformMatrix2x4fv;
+	glUniformMatrix4x2fv_client_proc_t glUniformMatrix4x2fv;
+	glUniformMatrix3x4fv_client_proc_t glUniformMatrix3x4fv;
+	glUniformMatrix4x3fv_client_proc_t glUniformMatrix4x3fv;
+	glGetUniformuiv_client_proc_t glGetUniformuiv;
+	glGetActiveUniformsiv_client_proc_t glGetActiveUniformsiv;
+	glVertexAttribI4i_client_proc_t glVertexAttribI4i;
+	glVertexAttribI4ui_client_proc_t glVertexAttribI4ui;
+	glVertexAttribI4iv_client_proc_t glVertexAttribI4iv;
+	glVertexAttribI4uiv_client_proc_t glVertexAttribI4uiv;
+	glVertexAttribIPointer_client_proc_t glVertexAttribIPointer;
+	glVertexAttribIPointerOffsetAEMU_client_proc_t glVertexAttribIPointerOffsetAEMU;
+	glVertexAttribIPointerDataAEMU_client_proc_t glVertexAttribIPointerDataAEMU;
+	glGetVertexAttribIiv_client_proc_t glGetVertexAttribIiv;
+	glGetVertexAttribIuiv_client_proc_t glGetVertexAttribIuiv;
+	glVertexAttribDivisor_client_proc_t glVertexAttribDivisor;
+	glDrawArraysInstanced_client_proc_t glDrawArraysInstanced;
+	glDrawElementsInstanced_client_proc_t glDrawElementsInstanced;
+	glDrawElementsInstancedDataAEMU_client_proc_t glDrawElementsInstancedDataAEMU;
+	glDrawElementsInstancedOffsetAEMU_client_proc_t glDrawElementsInstancedOffsetAEMU;
+	glDrawRangeElements_client_proc_t glDrawRangeElements;
+	glDrawRangeElementsDataAEMU_client_proc_t glDrawRangeElementsDataAEMU;
+	glDrawRangeElementsOffsetAEMU_client_proc_t glDrawRangeElementsOffsetAEMU;
+	glFenceSync_client_proc_t glFenceSync;
+	glClientWaitSync_client_proc_t glClientWaitSync;
+	glWaitSync_client_proc_t glWaitSync;
+	glDeleteSync_client_proc_t glDeleteSync;
+	glIsSync_client_proc_t glIsSync;
+	glGetSynciv_client_proc_t glGetSynciv;
+	glFenceSyncAEMU_client_proc_t glFenceSyncAEMU;
+	glClientWaitSyncAEMU_client_proc_t glClientWaitSyncAEMU;
+	glWaitSyncAEMU_client_proc_t glWaitSyncAEMU;
+	glDeleteSyncAEMU_client_proc_t glDeleteSyncAEMU;
+	glIsSyncAEMU_client_proc_t glIsSyncAEMU;
+	glGetSyncivAEMU_client_proc_t glGetSyncivAEMU;
+	glDrawBuffers_client_proc_t glDrawBuffers;
+	glReadBuffer_client_proc_t glReadBuffer;
+	glBlitFramebuffer_client_proc_t glBlitFramebuffer;
+	glInvalidateFramebuffer_client_proc_t glInvalidateFramebuffer;
+	glInvalidateSubFramebuffer_client_proc_t glInvalidateSubFramebuffer;
+	glFramebufferTextureLayer_client_proc_t glFramebufferTextureLayer;
+	glRenderbufferStorageMultisample_client_proc_t glRenderbufferStorageMultisample;
+	glTexStorage2D_client_proc_t glTexStorage2D;
+	glGetInternalformativ_client_proc_t glGetInternalformativ;
+	glBeginTransformFeedback_client_proc_t glBeginTransformFeedback;
+	glEndTransformFeedback_client_proc_t glEndTransformFeedback;
+	glGenTransformFeedbacks_client_proc_t glGenTransformFeedbacks;
+	glDeleteTransformFeedbacks_client_proc_t glDeleteTransformFeedbacks;
+	glBindTransformFeedback_client_proc_t glBindTransformFeedback;
+	glPauseTransformFeedback_client_proc_t glPauseTransformFeedback;
+	glResumeTransformFeedback_client_proc_t glResumeTransformFeedback;
+	glIsTransformFeedback_client_proc_t glIsTransformFeedback;
+	glTransformFeedbackVaryings_client_proc_t glTransformFeedbackVaryings;
+	glTransformFeedbackVaryingsAEMU_client_proc_t glTransformFeedbackVaryingsAEMU;
+	glGetTransformFeedbackVarying_client_proc_t glGetTransformFeedbackVarying;
+	glGenSamplers_client_proc_t glGenSamplers;
+	glDeleteSamplers_client_proc_t glDeleteSamplers;
+	glBindSampler_client_proc_t glBindSampler;
+	glSamplerParameterf_client_proc_t glSamplerParameterf;
+	glSamplerParameteri_client_proc_t glSamplerParameteri;
+	glSamplerParameterfv_client_proc_t glSamplerParameterfv;
+	glSamplerParameteriv_client_proc_t glSamplerParameteriv;
+	glGetSamplerParameterfv_client_proc_t glGetSamplerParameterfv;
+	glGetSamplerParameteriv_client_proc_t glGetSamplerParameteriv;
+	glIsSampler_client_proc_t glIsSampler;
+	glGenQueries_client_proc_t glGenQueries;
+	glDeleteQueries_client_proc_t glDeleteQueries;
+	glBeginQuery_client_proc_t glBeginQuery;
+	glEndQuery_client_proc_t glEndQuery;
+	glGetQueryiv_client_proc_t glGetQueryiv;
+	glGetQueryObjectuiv_client_proc_t glGetQueryObjectuiv;
+	glIsQuery_client_proc_t glIsQuery;
+	glProgramParameteri_client_proc_t glProgramParameteri;
+	glProgramBinary_client_proc_t glProgramBinary;
+	glGetProgramBinary_client_proc_t glGetProgramBinary;
+	glGetFragDataLocation_client_proc_t glGetFragDataLocation;
+	glGetInteger64v_client_proc_t glGetInteger64v;
+	glGetIntegeri_v_client_proc_t glGetIntegeri_v;
+	glGetInteger64i_v_client_proc_t glGetInteger64i_v;
+	glTexImage3D_client_proc_t glTexImage3D;
+	glTexImage3DOffsetAEMU_client_proc_t glTexImage3DOffsetAEMU;
+	glTexStorage3D_client_proc_t glTexStorage3D;
+	glTexSubImage3D_client_proc_t glTexSubImage3D;
+	glTexSubImage3DOffsetAEMU_client_proc_t glTexSubImage3DOffsetAEMU;
+	glCompressedTexImage3D_client_proc_t glCompressedTexImage3D;
+	glCompressedTexImage3DOffsetAEMU_client_proc_t glCompressedTexImage3DOffsetAEMU;
+	glCompressedTexSubImage3D_client_proc_t glCompressedTexSubImage3D;
+	glCompressedTexSubImage3DOffsetAEMU_client_proc_t glCompressedTexSubImage3DOffsetAEMU;
+	glCopyTexSubImage3D_client_proc_t glCopyTexSubImage3D;
+	glGetStringi_client_proc_t glGetStringi;
+	glGetBooleani_v_client_proc_t glGetBooleani_v;
+	glMemoryBarrier_client_proc_t glMemoryBarrier;
+	glMemoryBarrierByRegion_client_proc_t glMemoryBarrierByRegion;
+	glGenProgramPipelines_client_proc_t glGenProgramPipelines;
+	glDeleteProgramPipelines_client_proc_t glDeleteProgramPipelines;
+	glBindProgramPipeline_client_proc_t glBindProgramPipeline;
+	glGetProgramPipelineiv_client_proc_t glGetProgramPipelineiv;
+	glGetProgramPipelineInfoLog_client_proc_t glGetProgramPipelineInfoLog;
+	glValidateProgramPipeline_client_proc_t glValidateProgramPipeline;
+	glIsProgramPipeline_client_proc_t glIsProgramPipeline;
+	glUseProgramStages_client_proc_t glUseProgramStages;
+	glActiveShaderProgram_client_proc_t glActiveShaderProgram;
+	glCreateShaderProgramv_client_proc_t glCreateShaderProgramv;
+	glCreateShaderProgramvAEMU_client_proc_t glCreateShaderProgramvAEMU;
+	glProgramUniform1f_client_proc_t glProgramUniform1f;
+	glProgramUniform2f_client_proc_t glProgramUniform2f;
+	glProgramUniform3f_client_proc_t glProgramUniform3f;
+	glProgramUniform4f_client_proc_t glProgramUniform4f;
+	glProgramUniform1i_client_proc_t glProgramUniform1i;
+	glProgramUniform2i_client_proc_t glProgramUniform2i;
+	glProgramUniform3i_client_proc_t glProgramUniform3i;
+	glProgramUniform4i_client_proc_t glProgramUniform4i;
+	glProgramUniform1ui_client_proc_t glProgramUniform1ui;
+	glProgramUniform2ui_client_proc_t glProgramUniform2ui;
+	glProgramUniform3ui_client_proc_t glProgramUniform3ui;
+	glProgramUniform4ui_client_proc_t glProgramUniform4ui;
+	glProgramUniform1fv_client_proc_t glProgramUniform1fv;
+	glProgramUniform2fv_client_proc_t glProgramUniform2fv;
+	glProgramUniform3fv_client_proc_t glProgramUniform3fv;
+	glProgramUniform4fv_client_proc_t glProgramUniform4fv;
+	glProgramUniform1iv_client_proc_t glProgramUniform1iv;
+	glProgramUniform2iv_client_proc_t glProgramUniform2iv;
+	glProgramUniform3iv_client_proc_t glProgramUniform3iv;
+	glProgramUniform4iv_client_proc_t glProgramUniform4iv;
+	glProgramUniform1uiv_client_proc_t glProgramUniform1uiv;
+	glProgramUniform2uiv_client_proc_t glProgramUniform2uiv;
+	glProgramUniform3uiv_client_proc_t glProgramUniform3uiv;
+	glProgramUniform4uiv_client_proc_t glProgramUniform4uiv;
+	glProgramUniformMatrix2fv_client_proc_t glProgramUniformMatrix2fv;
+	glProgramUniformMatrix3fv_client_proc_t glProgramUniformMatrix3fv;
+	glProgramUniformMatrix4fv_client_proc_t glProgramUniformMatrix4fv;
+	glProgramUniformMatrix2x3fv_client_proc_t glProgramUniformMatrix2x3fv;
+	glProgramUniformMatrix3x2fv_client_proc_t glProgramUniformMatrix3x2fv;
+	glProgramUniformMatrix2x4fv_client_proc_t glProgramUniformMatrix2x4fv;
+	glProgramUniformMatrix4x2fv_client_proc_t glProgramUniformMatrix4x2fv;
+	glProgramUniformMatrix3x4fv_client_proc_t glProgramUniformMatrix3x4fv;
+	glProgramUniformMatrix4x3fv_client_proc_t glProgramUniformMatrix4x3fv;
+	glGetProgramInterfaceiv_client_proc_t glGetProgramInterfaceiv;
+	glGetProgramResourceiv_client_proc_t glGetProgramResourceiv;
+	glGetProgramResourceIndex_client_proc_t glGetProgramResourceIndex;
+	glGetProgramResourceLocation_client_proc_t glGetProgramResourceLocation;
+	glGetProgramResourceName_client_proc_t glGetProgramResourceName;
+	glBindImageTexture_client_proc_t glBindImageTexture;
+	glDispatchCompute_client_proc_t glDispatchCompute;
+	glDispatchComputeIndirect_client_proc_t glDispatchComputeIndirect;
+	glBindVertexBuffer_client_proc_t glBindVertexBuffer;
+	glVertexAttribBinding_client_proc_t glVertexAttribBinding;
+	glVertexAttribFormat_client_proc_t glVertexAttribFormat;
+	glVertexAttribIFormat_client_proc_t glVertexAttribIFormat;
+	glVertexBindingDivisor_client_proc_t glVertexBindingDivisor;
+	glDrawArraysIndirect_client_proc_t glDrawArraysIndirect;
+	glDrawArraysIndirectDataAEMU_client_proc_t glDrawArraysIndirectDataAEMU;
+	glDrawArraysIndirectOffsetAEMU_client_proc_t glDrawArraysIndirectOffsetAEMU;
+	glDrawElementsIndirect_client_proc_t glDrawElementsIndirect;
+	glDrawElementsIndirectDataAEMU_client_proc_t glDrawElementsIndirectDataAEMU;
+	glDrawElementsIndirectOffsetAEMU_client_proc_t glDrawElementsIndirectOffsetAEMU;
+	glTexStorage2DMultisample_client_proc_t glTexStorage2DMultisample;
+	glSampleMaski_client_proc_t glSampleMaski;
+	glGetMultisamplefv_client_proc_t glGetMultisamplefv;
+	glFramebufferParameteri_client_proc_t glFramebufferParameteri;
+	glGetFramebufferParameteriv_client_proc_t glGetFramebufferParameteriv;
+	glGetTexLevelParameterfv_client_proc_t glGetTexLevelParameterfv;
+	glGetTexLevelParameteriv_client_proc_t glGetTexLevelParameteriv;
+	virtual ~gl2_client_context_t() {}
 
 	typedef gl2_client_context_t *CONTEXT_ACCESSOR_TYPE(void);
 	static void setContextAccessor(CONTEXT_ACCESSOR_TYPE *f);
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_proc.h b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_proc.h
index 445910d..8c88678 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_proc.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_client_proc.h
@@ -217,6 +217,209 @@ typedef void (gl2_APIENTRY *glDrawElementsData_client_proc_t) (void * ctx, GLenu
 typedef void (gl2_APIENTRY *glGetCompressedTextureFormats_client_proc_t) (void * ctx, int, GLint*);
 typedef void (gl2_APIENTRY *glShaderString_client_proc_t) (void * ctx, GLuint, const GLchar*, GLsizei);
 typedef int (gl2_APIENTRY *glFinishRoundTrip_client_proc_t) (void * ctx);
+typedef void (gl2_APIENTRY *glGenVertexArrays_client_proc_t) (void * ctx, GLsizei, GLuint*);
+typedef void (gl2_APIENTRY *glBindVertexArray_client_proc_t) (void * ctx, GLuint);
+typedef void (gl2_APIENTRY *glDeleteVertexArrays_client_proc_t) (void * ctx, GLsizei, const GLuint*);
+typedef GLboolean (gl2_APIENTRY *glIsVertexArray_client_proc_t) (void * ctx, GLuint);
+typedef void* (gl2_APIENTRY *glMapBufferRange_client_proc_t) (void * ctx, GLenum, GLintptr, GLsizeiptr, GLbitfield);
+typedef GLboolean (gl2_APIENTRY *glUnmapBuffer_client_proc_t) (void * ctx, GLenum);
+typedef void (gl2_APIENTRY *glFlushMappedBufferRange_client_proc_t) (void * ctx, GLenum, GLintptr, GLsizeiptr);
+typedef void (gl2_APIENTRY *glMapBufferRangeAEMU_client_proc_t) (void * ctx, GLenum, GLintptr, GLsizeiptr, GLbitfield, void*);
+typedef void (gl2_APIENTRY *glUnmapBufferAEMU_client_proc_t) (void * ctx, GLenum, GLintptr, GLsizeiptr, GLbitfield, void*, GLboolean*);
+typedef void (gl2_APIENTRY *glFlushMappedBufferRangeAEMU_client_proc_t) (void * ctx, GLenum, GLintptr, GLsizeiptr, GLbitfield, void*);
+typedef void (gl2_APIENTRY *glReadPixelsOffsetAEMU_client_proc_t) (void * ctx, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glCompressedTexImage2DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, GLuint);
+typedef void (gl2_APIENTRY *glCompressedTexSubImage2DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, GLuint);
+typedef void (gl2_APIENTRY *glTexImage2DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glTexSubImage2DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glBindBufferRange_client_proc_t) (void * ctx, GLenum, GLuint, GLuint, GLintptr, GLsizeiptr);
+typedef void (gl2_APIENTRY *glBindBufferBase_client_proc_t) (void * ctx, GLenum, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glCopyBufferSubData_client_proc_t) (void * ctx, GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr);
+typedef void (gl2_APIENTRY *glClearBufferiv_client_proc_t) (void * ctx, GLenum, GLint, const GLint*);
+typedef void (gl2_APIENTRY *glClearBufferuiv_client_proc_t) (void * ctx, GLenum, GLint, const GLuint*);
+typedef void (gl2_APIENTRY *glClearBufferfv_client_proc_t) (void * ctx, GLenum, GLint, const GLfloat*);
+typedef void (gl2_APIENTRY *glClearBufferfi_client_proc_t) (void * ctx, GLenum, GLint, GLfloat, GLint);
+typedef void (gl2_APIENTRY *glGetBufferParameteri64v_client_proc_t) (void * ctx, GLenum, GLenum, GLint64*);
+typedef void (gl2_APIENTRY *glGetBufferPointerv_client_proc_t) (void * ctx, GLenum, GLenum, GLvoid**);
+typedef void (gl2_APIENTRY *glUniformBlockBinding_client_proc_t) (void * ctx, GLuint, GLuint, GLuint);
+typedef GLuint (gl2_APIENTRY *glGetUniformBlockIndex_client_proc_t) (void * ctx, GLuint, const GLchar*);
+typedef void (gl2_APIENTRY *glGetUniformIndices_client_proc_t) (void * ctx, GLuint, GLsizei, const GLchar**, GLuint*);
+typedef void (gl2_APIENTRY *glGetUniformIndicesAEMU_client_proc_t) (void * ctx, GLuint, GLsizei, const GLchar*, GLsizei, GLuint*);
+typedef void (gl2_APIENTRY *glGetActiveUniformBlockiv_client_proc_t) (void * ctx, GLuint, GLuint, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glGetActiveUniformBlockName_client_proc_t) (void * ctx, GLuint, GLuint, GLsizei, GLsizei*, GLchar*);
+typedef void (gl2_APIENTRY *glUniform1ui_client_proc_t) (void * ctx, GLint, GLuint);
+typedef void (gl2_APIENTRY *glUniform2ui_client_proc_t) (void * ctx, GLint, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glUniform3ui_client_proc_t) (void * ctx, GLint, GLuint, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glUniform4ui_client_proc_t) (void * ctx, GLint, GLint, GLuint, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glUniform1uiv_client_proc_t) (void * ctx, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glUniform2uiv_client_proc_t) (void * ctx, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glUniform3uiv_client_proc_t) (void * ctx, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glUniform4uiv_client_proc_t) (void * ctx, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glUniformMatrix2x3fv_client_proc_t) (void * ctx, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glUniformMatrix3x2fv_client_proc_t) (void * ctx, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glUniformMatrix2x4fv_client_proc_t) (void * ctx, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glUniformMatrix4x2fv_client_proc_t) (void * ctx, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glUniformMatrix3x4fv_client_proc_t) (void * ctx, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glUniformMatrix4x3fv_client_proc_t) (void * ctx, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glGetUniformuiv_client_proc_t) (void * ctx, GLuint, GLint, GLuint*);
+typedef void (gl2_APIENTRY *glGetActiveUniformsiv_client_proc_t) (void * ctx, GLuint, GLsizei, const GLuint*, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glVertexAttribI4i_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLint, GLint);
+typedef void (gl2_APIENTRY *glVertexAttribI4ui_client_proc_t) (void * ctx, GLuint, GLuint, GLuint, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glVertexAttribI4iv_client_proc_t) (void * ctx, GLuint, const GLint*);
+typedef void (gl2_APIENTRY *glVertexAttribI4uiv_client_proc_t) (void * ctx, GLuint, const GLuint*);
+typedef void (gl2_APIENTRY *glVertexAttribIPointer_client_proc_t) (void * ctx, GLuint, GLint, GLenum, GLsizei, const GLvoid*);
+typedef void (gl2_APIENTRY *glVertexAttribIPointerOffsetAEMU_client_proc_t) (void * ctx, GLuint, GLint, GLenum, GLsizei, GLuint);
+typedef void (gl2_APIENTRY *glVertexAttribIPointerDataAEMU_client_proc_t) (void * ctx, GLuint, GLint, GLenum, GLsizei, void*, GLuint);
+typedef void (gl2_APIENTRY *glGetVertexAttribIiv_client_proc_t) (void * ctx, GLuint, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glGetVertexAttribIuiv_client_proc_t) (void * ctx, GLuint, GLenum, GLuint*);
+typedef void (gl2_APIENTRY *glVertexAttribDivisor_client_proc_t) (void * ctx, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glDrawArraysInstanced_client_proc_t) (void * ctx, GLenum, GLint, GLsizei, GLsizei);
+typedef void (gl2_APIENTRY *glDrawElementsInstanced_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, const void*, GLsizei);
+typedef void (gl2_APIENTRY *glDrawElementsInstancedDataAEMU_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, const void*, GLsizei, GLsizei);
+typedef void (gl2_APIENTRY *glDrawElementsInstancedOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, GLuint, GLsizei);
+typedef void (gl2_APIENTRY *glDrawRangeElements_client_proc_t) (void * ctx, GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid*);
+typedef void (gl2_APIENTRY *glDrawRangeElementsDataAEMU_client_proc_t) (void * ctx, GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid*, GLsizei);
+typedef void (gl2_APIENTRY *glDrawRangeElementsOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLuint, GLuint, GLsizei, GLenum, GLuint);
+typedef GLsync (gl2_APIENTRY *glFenceSync_client_proc_t) (void * ctx, GLenum, GLbitfield);
+typedef GLenum (gl2_APIENTRY *glClientWaitSync_client_proc_t) (void * ctx, GLsync, GLbitfield, GLuint64);
+typedef void (gl2_APIENTRY *glWaitSync_client_proc_t) (void * ctx, GLsync, GLbitfield, GLuint64);
+typedef void (gl2_APIENTRY *glDeleteSync_client_proc_t) (void * ctx, GLsync);
+typedef GLboolean (gl2_APIENTRY *glIsSync_client_proc_t) (void * ctx, GLsync);
+typedef void (gl2_APIENTRY *glGetSynciv_client_proc_t) (void * ctx, GLsync, GLenum, GLsizei, GLsizei*, GLint*);
+typedef uint64_t (gl2_APIENTRY *glFenceSyncAEMU_client_proc_t) (void * ctx, GLenum, GLbitfield);
+typedef GLenum (gl2_APIENTRY *glClientWaitSyncAEMU_client_proc_t) (void * ctx, uint64_t, GLbitfield, GLuint64);
+typedef void (gl2_APIENTRY *glWaitSyncAEMU_client_proc_t) (void * ctx, uint64_t, GLbitfield, GLuint64);
+typedef void (gl2_APIENTRY *glDeleteSyncAEMU_client_proc_t) (void * ctx, uint64_t);
+typedef GLboolean (gl2_APIENTRY *glIsSyncAEMU_client_proc_t) (void * ctx, uint64_t);
+typedef void (gl2_APIENTRY *glGetSyncivAEMU_client_proc_t) (void * ctx, uint64_t, GLenum, GLsizei, GLsizei*, GLint*);
+typedef void (gl2_APIENTRY *glDrawBuffers_client_proc_t) (void * ctx, GLsizei, const GLenum*);
+typedef void (gl2_APIENTRY *glReadBuffer_client_proc_t) (void * ctx, GLenum);
+typedef void (gl2_APIENTRY *glBlitFramebuffer_client_proc_t) (void * ctx, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);
+typedef void (gl2_APIENTRY *glInvalidateFramebuffer_client_proc_t) (void * ctx, GLenum, GLsizei, const GLenum*);
+typedef void (gl2_APIENTRY *glInvalidateSubFramebuffer_client_proc_t) (void * ctx, GLenum, GLsizei, const GLenum*, GLint, GLint, GLsizei, GLsizei);
+typedef void (gl2_APIENTRY *glFramebufferTextureLayer_client_proc_t) (void * ctx, GLenum, GLenum, GLuint, GLint, GLint);
+typedef void (gl2_APIENTRY *glRenderbufferStorageMultisample_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, GLsizei, GLsizei);
+typedef void (gl2_APIENTRY *glTexStorage2D_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, GLsizei, GLsizei);
+typedef void (gl2_APIENTRY *glGetInternalformativ_client_proc_t) (void * ctx, GLenum, GLenum, GLenum, GLsizei, GLint*);
+typedef void (gl2_APIENTRY *glBeginTransformFeedback_client_proc_t) (void * ctx, GLenum);
+typedef void (gl2_APIENTRY *glEndTransformFeedback_client_proc_t) (void * ctx);
+typedef void (gl2_APIENTRY *glGenTransformFeedbacks_client_proc_t) (void * ctx, GLsizei, GLuint*);
+typedef void (gl2_APIENTRY *glDeleteTransformFeedbacks_client_proc_t) (void * ctx, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glBindTransformFeedback_client_proc_t) (void * ctx, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glPauseTransformFeedback_client_proc_t) (void * ctx);
+typedef void (gl2_APIENTRY *glResumeTransformFeedback_client_proc_t) (void * ctx);
+typedef GLboolean (gl2_APIENTRY *glIsTransformFeedback_client_proc_t) (void * ctx, GLuint);
+typedef void (gl2_APIENTRY *glTransformFeedbackVaryings_client_proc_t) (void * ctx, GLuint, GLsizei, const char**, GLenum);
+typedef void (gl2_APIENTRY *glTransformFeedbackVaryingsAEMU_client_proc_t) (void * ctx, GLuint, GLsizei, const char*, GLuint, GLenum);
+typedef void (gl2_APIENTRY *glGetTransformFeedbackVarying_client_proc_t) (void * ctx, GLuint, GLuint, GLsizei, GLsizei*, GLsizei*, GLenum*, char*);
+typedef void (gl2_APIENTRY *glGenSamplers_client_proc_t) (void * ctx, GLsizei, GLuint*);
+typedef void (gl2_APIENTRY *glDeleteSamplers_client_proc_t) (void * ctx, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glBindSampler_client_proc_t) (void * ctx, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glSamplerParameterf_client_proc_t) (void * ctx, GLuint, GLenum, GLfloat);
+typedef void (gl2_APIENTRY *glSamplerParameteri_client_proc_t) (void * ctx, GLuint, GLenum, GLint);
+typedef void (gl2_APIENTRY *glSamplerParameterfv_client_proc_t) (void * ctx, GLuint, GLenum, const GLfloat*);
+typedef void (gl2_APIENTRY *glSamplerParameteriv_client_proc_t) (void * ctx, GLuint, GLenum, const GLint*);
+typedef void (gl2_APIENTRY *glGetSamplerParameterfv_client_proc_t) (void * ctx, GLuint, GLenum, GLfloat*);
+typedef void (gl2_APIENTRY *glGetSamplerParameteriv_client_proc_t) (void * ctx, GLuint, GLenum, GLint*);
+typedef GLboolean (gl2_APIENTRY *glIsSampler_client_proc_t) (void * ctx, GLuint);
+typedef void (gl2_APIENTRY *glGenQueries_client_proc_t) (void * ctx, GLsizei, GLuint*);
+typedef void (gl2_APIENTRY *glDeleteQueries_client_proc_t) (void * ctx, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glBeginQuery_client_proc_t) (void * ctx, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glEndQuery_client_proc_t) (void * ctx, GLenum);
+typedef void (gl2_APIENTRY *glGetQueryiv_client_proc_t) (void * ctx, GLenum, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glGetQueryObjectuiv_client_proc_t) (void * ctx, GLuint, GLenum, GLuint*);
+typedef GLboolean (gl2_APIENTRY *glIsQuery_client_proc_t) (void * ctx, GLuint);
+typedef void (gl2_APIENTRY *glProgramParameteri_client_proc_t) (void * ctx, GLuint, GLenum, GLint);
+typedef void (gl2_APIENTRY *glProgramBinary_client_proc_t) (void * ctx, GLuint, GLenum, const void*, GLsizei);
+typedef void (gl2_APIENTRY *glGetProgramBinary_client_proc_t) (void * ctx, GLuint, GLsizei, GLsizei*, GLenum*, void*);
+typedef GLint (gl2_APIENTRY *glGetFragDataLocation_client_proc_t) (void * ctx, GLuint, const char*);
+typedef void (gl2_APIENTRY *glGetInteger64v_client_proc_t) (void * ctx, GLenum, GLint64*);
+typedef void (gl2_APIENTRY *glGetIntegeri_v_client_proc_t) (void * ctx, GLenum, GLuint, GLint*);
+typedef void (gl2_APIENTRY *glGetInteger64i_v_client_proc_t) (void * ctx, GLenum, GLuint, GLint64*);
+typedef void (gl2_APIENTRY *glTexImage3D_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*);
+typedef void (gl2_APIENTRY *glTexImage3DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glTexStorage3D_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);
+typedef void (gl2_APIENTRY *glTexSubImage3D_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*);
+typedef void (gl2_APIENTRY *glTexSubImage3DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glCompressedTexImage3D_client_proc_t) (void * ctx, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid*);
+typedef void (gl2_APIENTRY *glCompressedTexImage3DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, GLuint);
+typedef void (gl2_APIENTRY *glCompressedTexSubImage3D_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid*);
+typedef void (gl2_APIENTRY *glCompressedTexSubImage3DOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, GLuint);
+typedef void (gl2_APIENTRY *glCopyTexSubImage3D_client_proc_t) (void * ctx, GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+typedef const GLubyte* (gl2_APIENTRY *glGetStringi_client_proc_t) (void * ctx, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glGetBooleani_v_client_proc_t) (void * ctx, GLenum, GLuint, GLboolean*);
+typedef void (gl2_APIENTRY *glMemoryBarrier_client_proc_t) (void * ctx, GLbitfield);
+typedef void (gl2_APIENTRY *glMemoryBarrierByRegion_client_proc_t) (void * ctx, GLbitfield);
+typedef void (gl2_APIENTRY *glGenProgramPipelines_client_proc_t) (void * ctx, GLsizei, GLuint*);
+typedef void (gl2_APIENTRY *glDeleteProgramPipelines_client_proc_t) (void * ctx, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glBindProgramPipeline_client_proc_t) (void * ctx, GLuint);
+typedef void (gl2_APIENTRY *glGetProgramPipelineiv_client_proc_t) (void * ctx, GLuint, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glGetProgramPipelineInfoLog_client_proc_t) (void * ctx, GLuint, GLsizei, GLsizei*, GLchar*);
+typedef void (gl2_APIENTRY *glValidateProgramPipeline_client_proc_t) (void * ctx, GLuint);
+typedef GLboolean (gl2_APIENTRY *glIsProgramPipeline_client_proc_t) (void * ctx, GLuint);
+typedef void (gl2_APIENTRY *glUseProgramStages_client_proc_t) (void * ctx, GLuint, GLbitfield, GLuint);
+typedef void (gl2_APIENTRY *glActiveShaderProgram_client_proc_t) (void * ctx, GLuint, GLuint);
+typedef GLuint (gl2_APIENTRY *glCreateShaderProgramv_client_proc_t) (void * ctx, GLenum, GLsizei, const char**);
+typedef GLuint (gl2_APIENTRY *glCreateShaderProgramvAEMU_client_proc_t) (void * ctx, GLenum, GLsizei, const char*, GLuint);
+typedef void (gl2_APIENTRY *glProgramUniform1f_client_proc_t) (void * ctx, GLuint, GLint, GLfloat);
+typedef void (gl2_APIENTRY *glProgramUniform2f_client_proc_t) (void * ctx, GLuint, GLint, GLfloat, GLfloat);
+typedef void (gl2_APIENTRY *glProgramUniform3f_client_proc_t) (void * ctx, GLuint, GLint, GLfloat, GLfloat, GLfloat);
+typedef void (gl2_APIENTRY *glProgramUniform4f_client_proc_t) (void * ctx, GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat);
+typedef void (gl2_APIENTRY *glProgramUniform1i_client_proc_t) (void * ctx, GLuint, GLint, GLint);
+typedef void (gl2_APIENTRY *glProgramUniform2i_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLint);
+typedef void (gl2_APIENTRY *glProgramUniform3i_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLint, GLint);
+typedef void (gl2_APIENTRY *glProgramUniform4i_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLint, GLint, GLint);
+typedef void (gl2_APIENTRY *glProgramUniform1ui_client_proc_t) (void * ctx, GLuint, GLint, GLuint);
+typedef void (gl2_APIENTRY *glProgramUniform2ui_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLuint);
+typedef void (gl2_APIENTRY *glProgramUniform3ui_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLint, GLuint);
+typedef void (gl2_APIENTRY *glProgramUniform4ui_client_proc_t) (void * ctx, GLuint, GLint, GLint, GLint, GLint, GLuint);
+typedef void (gl2_APIENTRY *glProgramUniform1fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniform2fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniform3fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniform4fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniform1iv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLint*);
+typedef void (gl2_APIENTRY *glProgramUniform2iv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLint*);
+typedef void (gl2_APIENTRY *glProgramUniform3iv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLint*);
+typedef void (gl2_APIENTRY *glProgramUniform4iv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLint*);
+typedef void (gl2_APIENTRY *glProgramUniform1uiv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glProgramUniform2uiv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glProgramUniform3uiv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glProgramUniform4uiv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, const GLuint*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix2fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix3fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix4fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix2x3fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix3x2fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix2x4fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix4x2fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix3x4fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glProgramUniformMatrix4x3fv_client_proc_t) (void * ctx, GLuint, GLint, GLsizei, GLboolean, const GLfloat*);
+typedef void (gl2_APIENTRY *glGetProgramInterfaceiv_client_proc_t) (void * ctx, GLuint, GLenum, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glGetProgramResourceiv_client_proc_t) (void * ctx, GLuint, GLenum, GLuint, GLsizei, const GLenum*, GLsizei, GLsizei*, GLint*);
+typedef GLuint (gl2_APIENTRY *glGetProgramResourceIndex_client_proc_t) (void * ctx, GLuint, GLenum, const char*);
+typedef GLint (gl2_APIENTRY *glGetProgramResourceLocation_client_proc_t) (void * ctx, GLuint, GLenum, const char*);
+typedef void (gl2_APIENTRY *glGetProgramResourceName_client_proc_t) (void * ctx, GLuint, GLenum, GLuint, GLsizei, GLsizei*, char*);
+typedef void (gl2_APIENTRY *glBindImageTexture_client_proc_t) (void * ctx, GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum);
+typedef void (gl2_APIENTRY *glDispatchCompute_client_proc_t) (void * ctx, GLuint, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glDispatchComputeIndirect_client_proc_t) (void * ctx, GLintptr);
+typedef void (gl2_APIENTRY *glBindVertexBuffer_client_proc_t) (void * ctx, GLuint, GLuint, GLintptr, GLintptr);
+typedef void (gl2_APIENTRY *glVertexAttribBinding_client_proc_t) (void * ctx, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glVertexAttribFormat_client_proc_t) (void * ctx, GLuint, GLint, GLenum, GLboolean, GLuint);
+typedef void (gl2_APIENTRY *glVertexAttribIFormat_client_proc_t) (void * ctx, GLuint, GLint, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glVertexBindingDivisor_client_proc_t) (void * ctx, GLuint, GLuint);
+typedef void (gl2_APIENTRY *glDrawArraysIndirect_client_proc_t) (void * ctx, GLenum, const void*);
+typedef void (gl2_APIENTRY *glDrawArraysIndirectDataAEMU_client_proc_t) (void * ctx, GLenum, const void*, GLuint);
+typedef void (gl2_APIENTRY *glDrawArraysIndirectOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glDrawElementsIndirect_client_proc_t) (void * ctx, GLenum, GLenum, const void*);
+typedef void (gl2_APIENTRY *glDrawElementsIndirectDataAEMU_client_proc_t) (void * ctx, GLenum, GLenum, const void*, GLuint);
+typedef void (gl2_APIENTRY *glDrawElementsIndirectOffsetAEMU_client_proc_t) (void * ctx, GLenum, GLenum, GLuint);
+typedef void (gl2_APIENTRY *glTexStorage2DMultisample_client_proc_t) (void * ctx, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);
+typedef void (gl2_APIENTRY *glSampleMaski_client_proc_t) (void * ctx, GLuint, GLbitfield);
+typedef void (gl2_APIENTRY *glGetMultisamplefv_client_proc_t) (void * ctx, GLenum, GLuint, GLfloat*);
+typedef void (gl2_APIENTRY *glFramebufferParameteri_client_proc_t) (void * ctx, GLenum, GLenum, GLint);
+typedef void (gl2_APIENTRY *glGetFramebufferParameteriv_client_proc_t) (void * ctx, GLenum, GLenum, GLint*);
+typedef void (gl2_APIENTRY *glGetTexLevelParameterfv_client_proc_t) (void * ctx, GLenum, GLint, GLenum, GLfloat*);
+typedef void (gl2_APIENTRY *glGetTexLevelParameteriv_client_proc_t) (void * ctx, GLenum, GLint, GLenum, GLint*);
 
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.cpp b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.cpp
index 615dcc1..8357c68 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.cpp
@@ -2,7 +2,6 @@
 // generated by 'emugen'
 
 
-#include <memory>
 #include <string.h>
 #include "gl2_opcodes.h"
 
@@ -439,9 +438,11 @@ GLenum glCheckFramebufferStatus_enc(void *self , GLenum target)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glCheckFramebufferStatus: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -777,9 +778,11 @@ GLuint glCreateProgram_enc(void *self )
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glCreateProgram: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -815,9 +818,11 @@ GLuint glCreateShader_enc(void *self , GLenum type)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glCreateShader: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1382,7 +1387,7 @@ void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
 	const unsigned int __size_buffers =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffers + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1399,9 +1404,11 @@ void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
 	stream->readback(buffers, __size_buffers);
 	if (useChecksum) checksumCalculator->addBuffer(buffers, __size_buffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenBuffers: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1444,7 +1451,7 @@ void glGenFramebuffers_enc(void *self , GLsizei n, GLuint* framebuffers)
 	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_framebuffers + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1461,9 +1468,11 @@ void glGenFramebuffers_enc(void *self , GLsizei n, GLuint* framebuffers)
 	stream->readback(framebuffers, __size_framebuffers);
 	if (useChecksum) checksumCalculator->addBuffer(framebuffers, __size_framebuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenFramebuffers: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1481,7 +1490,7 @@ void glGenRenderbuffers_enc(void *self , GLsizei n, GLuint* renderbuffers)
 	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_renderbuffers + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1498,9 +1507,11 @@ void glGenRenderbuffers_enc(void *self , GLsizei n, GLuint* renderbuffers)
 	stream->readback(renderbuffers, __size_renderbuffers);
 	if (useChecksum) checksumCalculator->addBuffer(renderbuffers, __size_renderbuffers);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenRenderbuffers: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1518,7 +1529,7 @@ void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
 	const unsigned int __size_textures =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_textures + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1535,9 +1546,11 @@ void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
 	stream->readback(textures, __size_textures);
 	if (useChecksum) checksumCalculator->addBuffer(textures, __size_textures);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenTextures: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1558,7 +1571,7 @@ void glGetActiveAttrib_enc(void *self , GLuint program, GLuint index, GLsizei bu
 	const unsigned int __size_name = ((name != NULL) ?  bufsize : 0);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_length + __size_size + __size_type + __size_name + 4*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 0 + 0 + 0 + 4*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1594,9 +1607,11 @@ void glGetActiveAttrib_enc(void *self , GLuint program, GLuint index, GLsizei bu
 		if (useChecksum) checksumCalculator->addBuffer(name, __size_name);
 	}
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetActiveAttrib: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1617,7 +1632,7 @@ void glGetActiveUniform_enc(void *self , GLuint program, GLuint index, GLsizei b
 	const unsigned int __size_name = ((name != NULL) ?  bufsize : 0);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_length + __size_size + __size_type + __size_name + 4*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 0 + 0 + 0 + 4*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1653,9 +1668,11 @@ void glGetActiveUniform_enc(void *self , GLuint program, GLuint index, GLsizei b
 		if (useChecksum) checksumCalculator->addBuffer(name, __size_name);
 	}
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetActiveUniform: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1674,7 +1691,7 @@ void glGetAttachedShaders_enc(void *self , GLuint program, GLsizei maxcount, GLs
 	const unsigned int __size_shaders =  (maxcount*sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_count + __size_shaders + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1697,9 +1714,11 @@ void glGetAttachedShaders_enc(void *self , GLuint program, GLsizei maxcount, GLs
 	stream->readback(shaders, __size_shaders);
 	if (useChecksum) checksumCalculator->addBuffer(shaders, __size_shaders);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetAttachedShaders: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1737,9 +1756,11 @@ int glGetAttribLocation_enc(void *self , GLuint program, const GLchar* name)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetAttribLocation: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1758,7 +1779,7 @@ void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLboolean));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1775,9 +1796,11 @@ void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetBooleanv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1795,7 +1818,7 @@ void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint*
 	const unsigned int __size_params =  (sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1813,9 +1836,11 @@ void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint*
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetBufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1849,9 +1874,11 @@ GLenum glGetError_enc(void *self )
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetError: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1870,7 +1897,7 @@ void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1887,9 +1914,11 @@ void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFloatv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1907,7 +1936,7 @@ void glGetFramebufferAttachmentParameteriv_enc(void *self , GLenum target, GLenu
 	const unsigned int __size_params =  (sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1926,9 +1955,11 @@ void glGetFramebufferAttachmentParameteriv_enc(void *self , GLenum target, GLenu
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetFramebufferAttachmentParameteriv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1946,7 +1977,7 @@ void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -1963,9 +1994,11 @@ void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetIntegerv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1980,10 +2013,10 @@ void glGetProgramiv_enc(void *self , GLuint program, GLenum pname, GLint* params
 	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
 	bool useChecksum = checksumCalculator->getVersion() > 0;
 
-	const unsigned int __size_params =  sizeof(GLint);
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2001,9 +2034,11 @@ void glGetProgramiv_enc(void *self , GLuint program, GLenum pname, GLint* params
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetProgramiv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2022,7 +2057,7 @@ void glGetProgramInfoLog_enc(void *self , GLuint program, GLsizei bufsize, GLsiz
 	const unsigned int __size_infolog =  bufsize;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_infolog + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2045,9 +2080,11 @@ void glGetProgramInfoLog_enc(void *self , GLuint program, GLsizei bufsize, GLsiz
 	stream->readback(infolog, __size_infolog);
 	if (useChecksum) checksumCalculator->addBuffer(infolog, __size_infolog);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetProgramInfoLog: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2065,7 +2102,7 @@ void glGetRenderbufferParameteriv_enc(void *self , GLenum target, GLenum pname,
 	const unsigned int __size_params =  sizeof(GLint);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2083,9 +2120,11 @@ void glGetRenderbufferParameteriv_enc(void *self , GLenum target, GLenum pname,
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetRenderbufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2103,7 +2142,7 @@ void glGetShaderiv_enc(void *self , GLuint shader, GLenum pname, GLint* params)
 	const unsigned int __size_params =  sizeof(GLint);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2121,9 +2160,11 @@ void glGetShaderiv_enc(void *self , GLuint shader, GLenum pname, GLint* params)
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetShaderiv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2142,7 +2183,7 @@ void glGetShaderInfoLog_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei
 	const unsigned int __size_infolog =  bufsize;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_infolog + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2165,9 +2206,11 @@ void glGetShaderInfoLog_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei
 	stream->readback(infolog, __size_infolog);
 	if (useChecksum) checksumCalculator->addBuffer(infolog, __size_infolog);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetShaderInfoLog: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2186,7 +2229,7 @@ void glGetShaderPrecisionFormat_enc(void *self , GLenum shadertype, GLenum preci
 	const unsigned int __size_precision =  (sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_range + __size_precision + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2207,9 +2250,11 @@ void glGetShaderPrecisionFormat_enc(void *self , GLenum shadertype, GLenum preci
 	stream->readback(precision, __size_precision);
 	if (useChecksum) checksumCalculator->addBuffer(precision, __size_precision);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetShaderPrecisionFormat: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2228,7 +2273,7 @@ void glGetShaderSource_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei*
 	const unsigned int __size_source =  bufsize;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_source + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2251,9 +2296,11 @@ void glGetShaderSource_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei*
 	stream->readback(source, __size_source);
 	if (useChecksum) checksumCalculator->addBuffer(source, __size_source);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetShaderSource: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2271,7 +2318,7 @@ void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat*
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2289,9 +2336,11 @@ void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat*
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexParameterfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2309,7 +2358,7 @@ void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* pa
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2327,9 +2376,11 @@ void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* pa
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetTexParameteriv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2347,7 +2398,7 @@ void glGetUniformfv_enc(void *self , GLuint program, GLint location, GLfloat* pa
 	const unsigned int __size_params =  glSizeof(glesv2_enc::uniformType(self, program, location));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2365,9 +2416,11 @@ void glGetUniformfv_enc(void *self , GLuint program, GLint location, GLfloat* pa
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetUniformfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2385,7 +2438,7 @@ void glGetUniformiv_enc(void *self , GLuint program, GLint location, GLint* para
 	const unsigned int __size_params =  glSizeof(glesv2_enc::uniformType(self, program, location));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2403,9 +2456,11 @@ void glGetUniformiv_enc(void *self , GLuint program, GLint location, GLint* para
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetUniformiv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2443,9 +2498,11 @@ int glGetUniformLocation_enc(void *self , GLuint program, const GLchar* name)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetUniformLocation: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2464,7 +2521,7 @@ void glGetVertexAttribfv_enc(void *self , GLuint index, GLenum pname, GLfloat* p
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2482,9 +2539,11 @@ void glGetVertexAttribfv_enc(void *self , GLuint index, GLenum pname, GLfloat* p
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetVertexAttribfv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2502,7 +2561,7 @@ void glGetVertexAttribiv_enc(void *self , GLuint index, GLenum pname, GLint* par
 	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2520,9 +2579,11 @@ void glGetVertexAttribiv_enc(void *self , GLuint index, GLenum pname, GLint* par
 	stream->readback(params, __size_params);
 	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetVertexAttribiv: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2583,9 +2644,11 @@ GLboolean glIsBuffer_enc(void *self , GLuint buffer)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsBuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2621,9 +2684,11 @@ GLboolean glIsEnabled_enc(void *self , GLenum cap)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsEnabled: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2659,9 +2724,11 @@ GLboolean glIsFramebuffer_enc(void *self , GLuint framebuffer)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsFramebuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2697,9 +2764,11 @@ GLboolean glIsProgram_enc(void *self , GLuint program)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsProgram: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2735,9 +2804,11 @@ GLboolean glIsRenderbuffer_enc(void *self , GLuint renderbuffer)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsRenderbuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2773,9 +2844,11 @@ GLboolean glIsShader_enc(void *self , GLuint shader)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsShader: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2811,9 +2884,11 @@ GLboolean glIsTexture_enc(void *self , GLuint texture)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsTexture: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -2934,7 +3009,7 @@ void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei heig
 	const unsigned int __size_pixels =  glesv2_enc::pixelDataSize(self, width, height, format, type, 1);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -2956,9 +3031,11 @@ void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei heig
 	stream->readback(pixels, __size_pixels);
 	if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glReadPixels: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4348,9 +4425,11 @@ GLboolean glUnmapBufferOES_enc(void *self , GLenum target)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glUnmapBufferOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4654,7 +4733,7 @@ void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
 	const unsigned int __size_arrays =  (n * sizeof(GLuint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_arrays + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -4671,9 +4750,11 @@ void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
 	stream->readback(arrays, __size_arrays);
 	if (useChecksum) checksumCalculator->addBuffer(arrays, __size_arrays);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGenVertexArraysOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4708,9 +4789,11 @@ GLboolean glIsVertexArrayOES_enc(void *self , GLuint array)
 	stream->readback(&retval, 1);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glIsVertexArrayOES: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4880,7 +4963,7 @@ void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
 	const unsigned int __size_formats =  (count * sizeof(GLint));
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_formats + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -4897,9 +4980,11 @@ void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
 	stream->readback(formats, __size_formats);
 	if (useChecksum) checksumCalculator->addBuffer(formats, __size_formats);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glGetCompressedTextureFormats: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4962,9 +5047,11 @@ int glFinishRoundTrip_enc(void *self )
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("glFinishRoundTrip: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -4972,6 +5059,5987 @@ int glFinishRoundTrip_enc(void *self )
 	return retval;
 }
 
+void glGenVertexArrays_enc(void *self , GLsizei n, GLuint* arrays)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_arrays =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGenVertexArrays;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_arrays; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(arrays, __size_arrays);
+	if (useChecksum) checksumCalculator->addBuffer(arrays, __size_arrays);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGenVertexArrays: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glBindVertexArray_enc(void *self , GLuint array)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindVertexArray;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &array, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDeleteVertexArrays_enc(void *self , GLsizei n, const GLuint* arrays)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_arrays =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_arrays + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDeleteVertexArrays;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_arrays; ptr += 4;
+	memcpy(ptr, arrays, __size_arrays);ptr += __size_arrays;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+GLboolean glIsVertexArray_enc(void *self , GLuint array)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glIsVertexArray;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &array, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLboolean retval;
+	stream->readback(&retval, 1);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glIsVertexArray: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glMapBufferRangeAEMU_enc(void *self , GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* mapped)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_mapped = ((mapped != NULL) ?  length : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glMapBufferRangeAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+		memcpy(ptr, &length, 4); ptr += 4;
+		memcpy(ptr, &access, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_mapped; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (mapped != NULL) {
+		stream->readback(mapped, __size_mapped);
+		if (useChecksum) checksumCalculator->addBuffer(mapped, __size_mapped);
+	}
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glMapBufferRangeAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glUnmapBufferAEMU_enc(void *self , GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer, GLboolean* out_res)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_guest_buffer = ((guest_buffer != NULL) ?  length : 0);
+	const unsigned int __size_out_res =  (sizeof(GLboolean));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + __size_guest_buffer + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUnmapBufferAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+		memcpy(ptr, &length, 4); ptr += 4;
+		memcpy(ptr, &access, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_guest_buffer; ptr += 4;
+	if (guest_buffer != NULL) memcpy(ptr, guest_buffer, __size_guest_buffer);ptr += __size_guest_buffer;
+	*(unsigned int *)(ptr) = __size_out_res; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(out_res, __size_out_res);
+	if (useChecksum) checksumCalculator->addBuffer(out_res, __size_out_res);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glUnmapBufferAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glFlushMappedBufferRangeAEMU_enc(void *self , GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_guest_buffer = ((guest_buffer != NULL) ?  length : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + __size_guest_buffer + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glFlushMappedBufferRangeAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+		memcpy(ptr, &length, 4); ptr += 4;
+		memcpy(ptr, &access, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_guest_buffer; ptr += 4;
+	if (guest_buffer != NULL) memcpy(ptr, guest_buffer, __size_guest_buffer);ptr += __size_guest_buffer;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glReadPixelsOffsetAEMU_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glReadPixelsOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &x, 4); ptr += 4;
+		memcpy(ptr, &y, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glCompressedTexImage2DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCompressedTexImage2DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &border, 4); ptr += 4;
+		memcpy(ptr, &imageSize, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glCompressedTexSubImage2DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCompressedTexSubImage2DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &imageSize, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glTexImage2DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexImage2DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &border, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glTexSubImage2DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexSubImage2DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBindBufferRange_enc(void *self , GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindBufferRange;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &buffer, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+		memcpy(ptr, &size, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBindBufferBase_enc(void *self , GLenum target, GLuint index, GLuint buffer)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindBufferBase;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &buffer, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glCopyBufferSubData_enc(void *self , GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCopyBufferSubData;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &readtarget, 4); ptr += 4;
+		memcpy(ptr, &writetarget, 4); ptr += 4;
+		memcpy(ptr, &readoffset, 4); ptr += 4;
+		memcpy(ptr, &writeoffset, 4); ptr += 4;
+		memcpy(ptr, &size, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->flush();
+}
+
+void glClearBufferiv_enc(void *self , GLenum buffer, GLint drawBuffer, const GLint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (sizeof(GLint) * glesv2_enc::clearBufferNumElts(self, buffer));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glClearBufferiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &buffer, 4); ptr += 4;
+		memcpy(ptr, &drawBuffer, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glClearBufferuiv_enc(void *self , GLenum buffer, GLint drawBuffer, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (sizeof(GLuint) * glesv2_enc::clearBufferNumElts(self, buffer));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glClearBufferuiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &buffer, 4); ptr += 4;
+		memcpy(ptr, &drawBuffer, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glClearBufferfv_enc(void *self , GLenum buffer, GLint drawBuffer, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (sizeof(GLfloat) * glesv2_enc::clearBufferNumElts(self, buffer));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glClearBufferfv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &buffer, 4); ptr += 4;
+		memcpy(ptr, &drawBuffer, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glClearBufferfi_enc(void *self , GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glClearBufferfi;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &buffer, 4); ptr += 4;
+		memcpy(ptr, &drawBuffer, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &stencil, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformBlockBinding_enc(void *self , GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformBlockBinding;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &uniformBlockIndex, 4); ptr += 4;
+		memcpy(ptr, &uniformBlockBinding, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+GLuint glGetUniformBlockIndex_enc(void *self , GLuint program, const GLchar* uniformBlockName)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_uniformBlockName =  (strlen(uniformBlockName) + 1);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_uniformBlockName + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetUniformBlockIndex;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_uniformBlockName; ptr += 4;
+	memcpy(ptr, uniformBlockName, __size_uniformBlockName);ptr += __size_uniformBlockName;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLuint retval;
+	stream->readback(&retval, 4);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetUniformBlockIndex: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glGetUniformIndicesAEMU_enc(void *self , GLuint program, GLsizei uniformCount, const GLchar* packedUniformNames, GLsizei packedLen, GLuint* uniformIndices)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_packedUniformNames =  packedLen;
+	const unsigned int __size_uniformIndices =  (uniformCount * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_packedUniformNames + 4 + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetUniformIndicesAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &uniformCount, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_packedUniformNames; ptr += 4;
+	memcpy(ptr, packedUniformNames, __size_packedUniformNames);ptr += __size_packedUniformNames;
+		memcpy(ptr, &packedLen, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_uniformIndices; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(uniformIndices, __size_uniformIndices);
+	if (useChecksum) checksumCalculator->addBuffer(uniformIndices, __size_uniformIndices);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetUniformIndicesAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetActiveUniformBlockiv_enc(void *self , GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glesv2_enc::glActiveUniformBlockivParamSize(self, program, uniformBlockIndex, pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetActiveUniformBlockiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &uniformBlockIndex, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetActiveUniformBlockiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetActiveUniformBlockName_enc(void *self , GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
+	const unsigned int __size_uniformBlockName = ((uniformBlockName != NULL) ?  bufSize : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetActiveUniformBlockName;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &uniformBlockIndex, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_uniformBlockName; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	if (uniformBlockName != NULL) {
+		stream->readback(uniformBlockName, __size_uniformBlockName);
+		if (useChecksum) checksumCalculator->addBuffer(uniformBlockName, __size_uniformBlockName);
+	}
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetActiveUniformBlockName: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glUniform1ui_enc(void *self , GLint location, GLuint v0)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform1ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform2ui_enc(void *self , GLint location, GLuint v0, GLuint v1)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform2ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform3ui_enc(void *self , GLint location, GLuint v0, GLuint v1, GLuint v2)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform3ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform4ui_enc(void *self , GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform4ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+		memcpy(ptr, &v3, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform1uiv_enc(void *self , GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform1uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform2uiv_enc(void *self , GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 2 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform2uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform3uiv_enc(void *self , GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 3 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform3uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniform4uiv_enc(void *self , GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 4 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniform4uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformMatrix2x3fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 6 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformMatrix2x3fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformMatrix3x2fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 6 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformMatrix3x2fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformMatrix2x4fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 8 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformMatrix2x4fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformMatrix4x2fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 8 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformMatrix4x2fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformMatrix3x4fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 12 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformMatrix3x4fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glUniformMatrix4x3fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 12 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUniformMatrix4x3fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetUniformuiv_enc(void *self , GLuint program, GLint location, GLuint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  glSizeof(glesv2_enc::uniformType(self, program, location));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetUniformuiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetUniformuiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetActiveUniformsiv_enc(void *self , GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_uniformIndices =  (uniformCount * sizeof(GLuint));
+	const unsigned int __size_params =  (uniformCount * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_uniformIndices + 4 + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetActiveUniformsiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &uniformCount, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_uniformIndices; ptr += 4;
+	memcpy(ptr, uniformIndices, __size_uniformIndices);ptr += __size_uniformIndices;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetActiveUniformsiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glVertexAttribI4i_enc(void *self , GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribI4i;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+		memcpy(ptr, &v3, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribI4ui_enc(void *self , GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribI4ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+		memcpy(ptr, &v3, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribI4iv_enc(void *self , GLuint index, const GLint* v)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_v =  (4 * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_v + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribI4iv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_v; ptr += 4;
+	memcpy(ptr, v, __size_v);ptr += __size_v;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribI4uiv_enc(void *self , GLuint index, const GLuint* v)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_v =  (4 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_v + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribI4uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_v; ptr += 4;
+	memcpy(ptr, v, __size_v);ptr += __size_v;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribIPointerOffsetAEMU_enc(void *self , GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribIPointerOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &size, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &stride, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribIPointerDataAEMU_enc(void *self , GLuint index, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data =  datalen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + __size_data + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribIPointerDataAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &size, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &stride, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_data; ptr += 4;
+	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, size, type, stride, datalen);ptr += __size_data;
+		memcpy(ptr, &datalen, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetVertexAttribIiv_enc(void *self , GLuint index, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetVertexAttribIiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetVertexAttribIiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetVertexAttribIuiv_enc(void *self , GLuint index, GLenum pname, GLuint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetVertexAttribIuiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetVertexAttribIuiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glVertexAttribDivisor_enc(void *self , GLuint index, GLuint divisor)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribDivisor;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &divisor, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawArraysInstanced_enc(void *self , GLenum mode, GLint first, GLsizei count, GLsizei primcount)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawArraysInstanced;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &first, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &primcount, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawElementsInstancedDataAEMU_enc(void *self , GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLsizei datalen)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_indices =  datalen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_indices + 4 + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawElementsInstancedDataAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_indices; ptr += 4;
+	memcpy(ptr, indices, __size_indices);ptr += __size_indices;
+		memcpy(ptr, &primcount, 4); ptr += 4;
+		memcpy(ptr, &datalen, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawElementsInstancedOffsetAEMU_enc(void *self , GLenum mode, GLsizei count, GLenum type, GLuint offset, GLsizei primcount)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawElementsInstancedOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+		memcpy(ptr, &primcount, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawRangeElementsDataAEMU_enc(void *self , GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices, GLsizei datalen)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_indices =  datalen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + __size_indices + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawRangeElementsDataAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &start, 4); ptr += 4;
+		memcpy(ptr, &end, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_indices; ptr += 4;
+	memcpy(ptr, indices, __size_indices);ptr += __size_indices;
+		memcpy(ptr, &datalen, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawRangeElementsOffsetAEMU_enc(void *self , GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawRangeElementsOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &start, 4); ptr += 4;
+		memcpy(ptr, &end, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+uint64_t glFenceSyncAEMU_enc(void *self , GLenum condition, GLbitfield flags)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glFenceSyncAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &condition, 4); ptr += 4;
+		memcpy(ptr, &flags, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	uint64_t retval;
+	stream->readback(&retval, 8);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 8);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glFenceSyncAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+GLenum glClientWaitSyncAEMU_enc(void *self , uint64_t wait_on, GLbitfield flags, GLuint64 timeout)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 8 + 4 + 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glClientWaitSyncAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &wait_on, 8); ptr += 8;
+		memcpy(ptr, &flags, 4); ptr += 4;
+		memcpy(ptr, &timeout, 8); ptr += 8;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLenum retval;
+	stream->readback(&retval, 4);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glClientWaitSyncAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glWaitSyncAEMU_enc(void *self , uint64_t wait_on, GLbitfield flags, GLuint64 timeout)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 8 + 4 + 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glWaitSyncAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &wait_on, 8); ptr += 8;
+		memcpy(ptr, &flags, 4); ptr += 4;
+		memcpy(ptr, &timeout, 8); ptr += 8;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDeleteSyncAEMU_enc(void *self , uint64_t to_delete)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDeleteSyncAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &to_delete, 8); ptr += 8;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+GLboolean glIsSyncAEMU_enc(void *self , uint64_t sync)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glIsSyncAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sync, 8); ptr += 8;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLboolean retval;
+	stream->readback(&retval, 1);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glIsSyncAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glGetSyncivAEMU_enc(void *self , uint64_t sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
+	const unsigned int __size_values =  (bufSize * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 8 + 4 + 4 + 0 + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetSyncivAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sync, 8); ptr += 8;
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_values; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	stream->readback(values, __size_values);
+	if (useChecksum) checksumCalculator->addBuffer(values, __size_values);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetSyncivAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glDrawBuffers_enc(void *self , GLsizei n, const GLenum* bufs)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_bufs =  (n * sizeof(GLenum));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_bufs + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_bufs; ptr += 4;
+	memcpy(ptr, bufs, __size_bufs);ptr += __size_bufs;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glReadBuffer_enc(void *self , GLenum src)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glReadBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &src, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBlitFramebuffer_enc(void *self , GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBlitFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &srcX0, 4); ptr += 4;
+		memcpy(ptr, &srcY0, 4); ptr += 4;
+		memcpy(ptr, &srcX1, 4); ptr += 4;
+		memcpy(ptr, &srcY1, 4); ptr += 4;
+		memcpy(ptr, &dstX0, 4); ptr += 4;
+		memcpy(ptr, &dstY0, 4); ptr += 4;
+		memcpy(ptr, &dstX1, 4); ptr += 4;
+		memcpy(ptr, &dstY1, 4); ptr += 4;
+		memcpy(ptr, &mask, 4); ptr += 4;
+		memcpy(ptr, &filter, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glInvalidateFramebuffer_enc(void *self , GLenum target, GLsizei numAttachments, const GLenum* attachments)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_attachments =  (numAttachments * sizeof(GLenum));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_attachments + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glInvalidateFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &numAttachments, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_attachments; ptr += 4;
+	memcpy(ptr, attachments, __size_attachments);ptr += __size_attachments;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glInvalidateSubFramebuffer_enc(void *self , GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_attachments =  (numAttachments * sizeof(GLenum));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_attachments + 4 + 4 + 4 + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glInvalidateSubFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &numAttachments, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_attachments; ptr += 4;
+	memcpy(ptr, attachments, __size_attachments);ptr += __size_attachments;
+		memcpy(ptr, &x, 4); ptr += 4;
+		memcpy(ptr, &y, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glFramebufferTextureLayer_enc(void *self , GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glFramebufferTextureLayer;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &attachment, 4); ptr += 4;
+		memcpy(ptr, &texture, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &layer, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glRenderbufferStorageMultisample_enc(void *self , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glRenderbufferStorageMultisample;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &samples, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glTexStorage2D_enc(void *self , GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexStorage2D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &levels, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetInternalformativ_enc(void *self , GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (sizeof(GLint) * bufSize);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetInternalformativ;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetInternalformativ: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glBeginTransformFeedback_enc(void *self , GLenum primitiveMode)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBeginTransformFeedback;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &primitiveMode, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glEndTransformFeedback_enc(void *self )
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glEndTransformFeedback;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGenTransformFeedbacks_enc(void *self , GLsizei n, GLuint* ids)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_ids =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGenTransformFeedbacks;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_ids; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(ids, __size_ids);
+	if (useChecksum) checksumCalculator->addBuffer(ids, __size_ids);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGenTransformFeedbacks: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glDeleteTransformFeedbacks_enc(void *self , GLsizei n, const GLuint* ids)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_ids =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_ids + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDeleteTransformFeedbacks;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_ids; ptr += 4;
+	memcpy(ptr, ids, __size_ids);ptr += __size_ids;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBindTransformFeedback_enc(void *self , GLenum target, GLuint id)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindTransformFeedback;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &id, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glPauseTransformFeedback_enc(void *self )
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glPauseTransformFeedback;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glResumeTransformFeedback_enc(void *self )
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glResumeTransformFeedback;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+GLboolean glIsTransformFeedback_enc(void *self , GLuint id)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glIsTransformFeedback;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &id, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLboolean retval;
+	stream->readback(&retval, 1);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glIsTransformFeedback: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glTransformFeedbackVaryingsAEMU_enc(void *self , GLuint program, GLsizei count, const char* packedVaryings, GLuint packedVaryingsLen, GLenum bufferMode)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_packedVaryings =  packedVaryingsLen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_packedVaryings + 4 + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTransformFeedbackVaryingsAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_packedVaryings; ptr += 4;
+	memcpy(ptr, packedVaryings, __size_packedVaryings);ptr += __size_packedVaryings;
+		memcpy(ptr, &packedVaryingsLen, 4); ptr += 4;
+		memcpy(ptr, &bufferMode, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetTransformFeedbackVarying_enc(void *self , GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
+	const unsigned int __size_size =  (sizeof(GLsizei));
+	const unsigned int __size_type = ((type != NULL) ?  (sizeof(GLenum)) : 0);
+	const unsigned int __size_name = ((name != NULL) ?  bufSize : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 0 + 0 + 0 + 4*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetTransformFeedbackVarying;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_size; ptr += 4;
+	*(unsigned int *)(ptr) = __size_type; ptr += 4;
+	*(unsigned int *)(ptr) = __size_name; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	stream->readback(size, __size_size);
+	if (useChecksum) checksumCalculator->addBuffer(size, __size_size);
+	if (type != NULL) {
+		stream->readback(type, __size_type);
+		if (useChecksum) checksumCalculator->addBuffer(type, __size_type);
+	}
+	if (name != NULL) {
+		stream->readback(name, __size_name);
+		if (useChecksum) checksumCalculator->addBuffer(name, __size_name);
+	}
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetTransformFeedbackVarying: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGenSamplers_enc(void *self , GLsizei n, GLuint* samplers)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_samplers =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGenSamplers;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_samplers; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(samplers, __size_samplers);
+	if (useChecksum) checksumCalculator->addBuffer(samplers, __size_samplers);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGenSamplers: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glDeleteSamplers_enc(void *self , GLsizei n, const GLuint* samplers)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_samplers =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_samplers + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDeleteSamplers;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_samplers; ptr += 4;
+	memcpy(ptr, samplers, __size_samplers);ptr += __size_samplers;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBindSampler_enc(void *self , GLuint unit, GLuint sampler)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindSampler;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &unit, 4); ptr += 4;
+		memcpy(ptr, &sampler, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glSamplerParameterf_enc(void *self , GLuint sampler, GLenum pname, GLfloat param)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glSamplerParameterf;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &param, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glSamplerParameteri_enc(void *self , GLuint sampler, GLenum pname, GLint param)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glSamplerParameteri;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &param, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glSamplerParameterfv_enc(void *self , GLuint sampler, GLenum pname, const GLfloat* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glSamplerParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+	memcpy(ptr, params, __size_params);ptr += __size_params;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glSamplerParameteriv_enc(void *self , GLuint sampler, GLenum pname, const GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glSamplerParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+	memcpy(ptr, params, __size_params);ptr += __size_params;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetSamplerParameterfv_enc(void *self , GLuint sampler, GLenum pname, GLfloat* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetSamplerParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetSamplerParameterfv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetSamplerParameteriv_enc(void *self , GLuint sampler, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetSamplerParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetSamplerParameteriv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+GLboolean glIsSampler_enc(void *self , GLuint sampler)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glIsSampler;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &sampler, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLboolean retval;
+	stream->readback(&retval, 1);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glIsSampler: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glGenQueries_enc(void *self , GLsizei n, GLuint* queries)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_queries =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGenQueries;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_queries; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(queries, __size_queries);
+	if (useChecksum) checksumCalculator->addBuffer(queries, __size_queries);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGenQueries: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glDeleteQueries_enc(void *self , GLsizei n, const GLuint* queries)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_queries =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_queries + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDeleteQueries;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_queries; ptr += 4;
+	memcpy(ptr, queries, __size_queries);ptr += __size_queries;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBeginQuery_enc(void *self , GLenum target, GLuint query)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBeginQuery;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &query, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glEndQuery_enc(void *self , GLenum target)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glEndQuery;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetQueryiv_enc(void *self , GLenum target, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetQueryiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetQueryiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetQueryObjectuiv_enc(void *self , GLuint query, GLenum pname, GLuint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetQueryObjectuiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &query, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetQueryObjectuiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+GLboolean glIsQuery_enc(void *self , GLuint query)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glIsQuery;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &query, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLboolean retval;
+	stream->readback(&retval, 1);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glIsQuery: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glProgramParameteri_enc(void *self , GLuint program, GLenum pname, GLint value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramParameteri;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &value, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramBinary_enc(void *self , GLuint program, GLenum binaryFormat, const void* binary, GLsizei length)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_binary =  length;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_binary + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramBinary;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &binaryFormat, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_binary; ptr += 4;
+	memcpy(ptr, binary, __size_binary);ptr += __size_binary;
+		memcpy(ptr, &length, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetProgramBinary_enc(void *self , GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
+	const unsigned int __size_binaryFormat =  (sizeof(GLenum));
+	const unsigned int __size_binary =  bufSize;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 0 + 3*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramBinary;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_binaryFormat; ptr += 4;
+	*(unsigned int *)(ptr) = __size_binary; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	stream->readback(binaryFormat, __size_binaryFormat);
+	if (useChecksum) checksumCalculator->addBuffer(binaryFormat, __size_binaryFormat);
+	stream->readback(binary, __size_binary);
+	if (useChecksum) checksumCalculator->addBuffer(binary, __size_binary);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramBinary: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+GLint glGetFragDataLocation_enc(void *self , GLuint program, const char* name)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_name =  (strlen(name) + 1);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_name + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetFragDataLocation;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_name; ptr += 4;
+	memcpy(ptr, name, __size_name);ptr += __size_name;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLint retval;
+	stream->readback(&retval, 4);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetFragDataLocation: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glGetInteger64v_enc(void *self , GLenum pname, GLint64* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data =  (glUtilsParamSize(pname) * sizeof(GLint64));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetInteger64v;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_data; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(data, __size_data);
+	if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetInteger64v: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetIntegeri_v_enc(void *self , GLenum target, GLuint index, GLint* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data =  (sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetIntegeri_v;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_data; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(data, __size_data);
+	if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetIntegeri_v: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetInteger64i_v_enc(void *self , GLenum target, GLuint index, GLint64* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data =  (sizeof(GLint64));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetInteger64i_v;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_data; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(data, __size_data);
+	if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetInteger64i_v: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glTexImage3D_enc(void *self , GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data = ((data != NULL) ?  glesv2_enc::pixelDataSize3D(self, width, height, depth, format, type, 0) : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
+	ptr = buf;
+	int tmp = OP_glTexImage3D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &internalFormat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &border, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	stream->flush();
+	stream->writeFully(&__size_data,4);
+	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
+	if (data != NULL) {
+		stream->writeFully(data, __size_data);
+		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	}
+	buf = stream->alloc(checksumSize);
+	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);
+
+}
+
+void glTexImage3DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexImage3DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &internalFormat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &border, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glTexStorage3D_enc(void *self , GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexStorage3D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &levels, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glTexSubImage3D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data = ((data != NULL) ?  glesv2_enc::pixelDataSize3D(self, width, height, depth, format, type, 0) : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
+	ptr = buf;
+	int tmp = OP_glTexSubImage3D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &zoffset, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	stream->flush();
+	stream->writeFully(&__size_data,4);
+	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
+	if (data != NULL) {
+		stream->writeFully(data, __size_data);
+		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	}
+	buf = stream->alloc(checksumSize);
+	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);
+
+}
+
+void glTexSubImage3DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexSubImage3DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &zoffset, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glCompressedTexImage3D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
+	ptr = buf;
+	int tmp = OP_glCompressedTexImage3D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &border, 4); ptr += 4;
+		memcpy(ptr, &imageSize, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	stream->flush();
+	stream->writeFully(&__size_data,4);
+	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
+	if (data != NULL) {
+		stream->writeFully(data, __size_data);
+		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	}
+	buf = stream->alloc(checksumSize);
+	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);
+
+}
+
+void glCompressedTexImage3DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCompressedTexImage3DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &border, 4); ptr += 4;
+		memcpy(ptr, &imageSize, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glCompressedTexSubImage3D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
+	ptr = buf;
+	int tmp = OP_glCompressedTexSubImage3D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &zoffset, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &imageSize, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	stream->flush();
+	stream->writeFully(&__size_data,4);
+	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
+	if (data != NULL) {
+		stream->writeFully(data, __size_data);
+		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	}
+	buf = stream->alloc(checksumSize);
+	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);
+
+}
+
+void glCompressedTexSubImage3DOffsetAEMU_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLuint data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCompressedTexSubImage3DOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &zoffset, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &depth, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &imageSize, 4); ptr += 4;
+		memcpy(ptr, &data, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glCopyTexSubImage3D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCopyTexSubImage3D;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &xoffset, 4); ptr += 4;
+		memcpy(ptr, &yoffset, 4); ptr += 4;
+		memcpy(ptr, &zoffset, 4); ptr += 4;
+		memcpy(ptr, &x, 4); ptr += 4;
+		memcpy(ptr, &y, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetBooleani_v_enc(void *self , GLenum target, GLuint index, GLboolean* data)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_data =  (sizeof(GLboolean));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetBooleani_v;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_data; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(data, __size_data);
+	if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetBooleani_v: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glMemoryBarrier_enc(void *self , GLbitfield barriers)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glMemoryBarrier;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &barriers, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glMemoryBarrierByRegion_enc(void *self , GLbitfield barriers)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glMemoryBarrierByRegion;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &barriers, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGenProgramPipelines_enc(void *self , GLsizei n, GLuint* pipelines)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_pipelines =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGenProgramPipelines;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_pipelines; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(pipelines, __size_pipelines);
+	if (useChecksum) checksumCalculator->addBuffer(pipelines, __size_pipelines);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGenProgramPipelines: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glDeleteProgramPipelines_enc(void *self , GLsizei n, const GLuint* pipelines)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_pipelines =  (n * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_pipelines + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDeleteProgramPipelines;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &n, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_pipelines; ptr += 4;
+	memcpy(ptr, pipelines, __size_pipelines);ptr += __size_pipelines;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBindProgramPipeline_enc(void *self , GLuint pipeline)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindProgramPipeline;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetProgramPipelineiv_enc(void *self , GLuint pipeline, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramPipelineiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramPipelineiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetProgramPipelineInfoLog_enc(void *self , GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_length = ((length != NULL) ?  sizeof(GLsizei) : 0);
+	const unsigned int __size_infoLog =  bufSize;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramPipelineInfoLog;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_infoLog; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	stream->readback(infoLog, __size_infoLog);
+	if (useChecksum) checksumCalculator->addBuffer(infoLog, __size_infoLog);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramPipelineInfoLog: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glValidateProgramPipeline_enc(void *self , GLuint pipeline)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glValidateProgramPipeline;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+GLboolean glIsProgramPipeline_enc(void *self , GLuint pipeline)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glIsProgramPipeline;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLboolean retval;
+	stream->readback(&retval, 1);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glIsProgramPipeline: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glUseProgramStages_enc(void *self , GLuint pipeline, GLbitfield stages, GLuint program)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glUseProgramStages;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+		memcpy(ptr, &stages, 4); ptr += 4;
+		memcpy(ptr, &program, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glActiveShaderProgram_enc(void *self , GLuint pipeline, GLuint program)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glActiveShaderProgram;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pipeline, 4); ptr += 4;
+		memcpy(ptr, &program, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+GLuint glCreateShaderProgramvAEMU_enc(void *self , GLenum type, GLsizei count, const char* packedStrings, GLuint packedLen)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_packedStrings =  packedLen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_packedStrings + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glCreateShaderProgramvAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_packedStrings; ptr += 4;
+	memcpy(ptr, packedStrings, __size_packedStrings);ptr += __size_packedStrings;
+		memcpy(ptr, &packedLen, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLuint retval;
+	stream->readback(&retval, 4);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glCreateShaderProgramvAEMU: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glProgramUniform1f_enc(void *self , GLuint program, GLint location, GLfloat v0)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform1f;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform2f_enc(void *self , GLuint program, GLint location, GLfloat v0, GLfloat v1)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform2f;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform3f_enc(void *self , GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform3f;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform4f_enc(void *self , GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform4f;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+		memcpy(ptr, &v3, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform1i_enc(void *self , GLuint program, GLint location, GLint v0)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform1i;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform2i_enc(void *self , GLuint program, GLint location, GLint v0, GLint v1)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform2i;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform3i_enc(void *self , GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform3i;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform4i_enc(void *self , GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform4i;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+		memcpy(ptr, &v3, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform1ui_enc(void *self , GLuint program, GLint location, GLuint v0)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform1ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform2ui_enc(void *self , GLuint program, GLint location, GLint v0, GLuint v1)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform2ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform3ui_enc(void *self , GLuint program, GLint location, GLint v0, GLint v1, GLuint v2)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform3ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform4ui_enc(void *self , GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform4ui;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &v0, 4); ptr += 4;
+		memcpy(ptr, &v1, 4); ptr += 4;
+		memcpy(ptr, &v2, 4); ptr += 4;
+		memcpy(ptr, &v3, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform1fv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform1fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform2fv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 2 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform2fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform3fv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 3 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform3fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform4fv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 4 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform4fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform1iv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform1iv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform2iv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 2 * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform2iv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform3iv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 3 * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform3iv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform4iv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 4 * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform4iv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform1uiv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform1uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform2uiv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 2 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform2uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform3uiv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 3 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform3uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniform4uiv_enc(void *self , GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 4 * sizeof(GLuint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniform4uiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix2fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 4 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix2fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix3fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 9 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix3fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix4fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 16 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix4fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix2x3fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 6 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix2x3fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix3x2fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 6 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix3x2fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix2x4fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 8 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix2x4fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix4x2fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 8 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix4x2fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix3x4fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 12 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix3x4fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glProgramUniformMatrix4x3fv_enc(void *self , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_value =  (count * 12 * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + __size_value + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glProgramUniformMatrix4x3fv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &location, 4); ptr += 4;
+		memcpy(ptr, &count, 4); ptr += 4;
+		memcpy(ptr, &transpose, 1); ptr += 1;
+	*(unsigned int *)(ptr) = __size_value; ptr += 4;
+	memcpy(ptr, value, __size_value);ptr += __size_value;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetProgramInterfaceiv_enc(void *self , GLuint program, GLenum programInterface, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramInterfaceiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &programInterface, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramInterfaceiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetProgramResourceiv_enc(void *self , GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_props =  (propCount * sizeof(GLenum));
+	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
+	const unsigned int __size_params =  (bufSize * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + __size_props + 4 + 0 + 0 + 3*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramResourceiv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &programInterface, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &propCount, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_props; ptr += 4;
+	memcpy(ptr, props, __size_props);ptr += __size_props;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramResourceiv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+GLuint glGetProgramResourceIndex_enc(void *self , GLuint program, GLenum programInterface, const char* name)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_name =  (strlen(name) + 1);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_name + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramResourceIndex;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &programInterface, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_name; ptr += 4;
+	memcpy(ptr, name, __size_name);ptr += __size_name;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLuint retval;
+	stream->readback(&retval, 4);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramResourceIndex: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+GLint glGetProgramResourceLocation_enc(void *self , GLuint program, GLenum programInterface, const char* name)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_name =  (strlen(name) + 1);
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_name + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramResourceLocation;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &programInterface, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_name; ptr += 4;
+	memcpy(ptr, name, __size_name);ptr += __size_name;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+	GLint retval;
+	stream->readback(&retval, 4);
+	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramResourceLocation: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+	return retval;
+}
+
+void glGetProgramResourceName_enc(void *self , GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
+	const unsigned int __size_name =  bufSize;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 0 + 0 + 2*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetProgramResourceName;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &program, 4); ptr += 4;
+		memcpy(ptr, &programInterface, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+		memcpy(ptr, &bufSize, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_length; ptr += 4;
+	*(unsigned int *)(ptr) = __size_name; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	if (length != NULL) {
+		stream->readback(length, __size_length);
+		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
+	}
+	stream->readback(name, __size_name);
+	if (useChecksum) checksumCalculator->addBuffer(name, __size_name);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetProgramResourceName: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glBindImageTexture_enc(void *self , GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindImageTexture;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &unit, 4); ptr += 4;
+		memcpy(ptr, &texture, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &layered, 1); ptr += 1;
+		memcpy(ptr, &layer, 4); ptr += 4;
+		memcpy(ptr, &access, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDispatchCompute_enc(void *self , GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDispatchCompute;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &num_groups_x, 4); ptr += 4;
+		memcpy(ptr, &num_groups_y, 4); ptr += 4;
+		memcpy(ptr, &num_groups_z, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDispatchComputeIndirect_enc(void *self , GLintptr indirect)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDispatchComputeIndirect;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &indirect, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glBindVertexBuffer_enc(void *self , GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glBindVertexBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &bindingindex, 4); ptr += 4;
+		memcpy(ptr, &buffer, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+		memcpy(ptr, &stride, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribBinding_enc(void *self , GLuint attribindex, GLuint bindingindex)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribBinding;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &attribindex, 4); ptr += 4;
+		memcpy(ptr, &bindingindex, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribFormat_enc(void *self , GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribFormat;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &attribindex, 4); ptr += 4;
+		memcpy(ptr, &size, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &normalized, 1); ptr += 1;
+		memcpy(ptr, &relativeoffset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexAttribIFormat_enc(void *self , GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexAttribIFormat;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &attribindex, 4); ptr += 4;
+		memcpy(ptr, &size, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &relativeoffset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glVertexBindingDivisor_enc(void *self , GLuint bindingindex, GLuint divisor)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glVertexBindingDivisor;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &bindingindex, 4); ptr += 4;
+		memcpy(ptr, &divisor, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawArraysIndirectDataAEMU_enc(void *self , GLenum mode, const void* indirect, GLuint datalen)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_indirect =  datalen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + __size_indirect + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawArraysIndirectDataAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_indirect; ptr += 4;
+	memcpy(ptr, indirect, __size_indirect);ptr += __size_indirect;
+		memcpy(ptr, &datalen, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawArraysIndirectOffsetAEMU_enc(void *self , GLenum mode, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawArraysIndirectOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawElementsIndirectDataAEMU_enc(void *self , GLenum mode, GLenum type, const void* indirect, GLuint datalen)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_indirect =  datalen;
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_indirect + 4 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawElementsIndirectDataAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_indirect; ptr += 4;
+	memcpy(ptr, indirect, __size_indirect);ptr += __size_indirect;
+		memcpy(ptr, &datalen, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glDrawElementsIndirectOffsetAEMU_enc(void *self , GLenum mode, GLenum type, GLuint offset)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glDrawElementsIndirectOffsetAEMU;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &mode, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+		memcpy(ptr, &offset, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glTexStorage2DMultisample_enc(void *self , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 1;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glTexStorage2DMultisample;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &samples, 4); ptr += 4;
+		memcpy(ptr, &internalformat, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &fixedsamplelocations, 1); ptr += 1;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glSampleMaski_enc(void *self , GLuint maskNumber, GLbitfield mask)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glSampleMaski;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &maskNumber, 4); ptr += 4;
+		memcpy(ptr, &mask, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetMultisamplefv_enc(void *self , GLenum pname, GLuint index, GLfloat* val)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_val =  (glUtilsParamSize(pname) * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetMultisamplefv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &index, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_val; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(val, __size_val);
+	if (useChecksum) checksumCalculator->addBuffer(val, __size_val);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetMultisamplefv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glFramebufferParameteri_enc(void *self , GLenum target, GLenum pname, GLint param)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glFramebufferParameteri;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+		memcpy(ptr, &param, 4); ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+}
+
+void glGetFramebufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetFramebufferParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetFramebufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetTexLevelParameterfv_enc(void *self , GLenum target, GLint level, GLenum pname, GLfloat* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetTexLevelParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetTexLevelParameterfv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
+void glGetTexLevelParameteriv_enc(void *self , GLenum target, GLint level, GLenum pname, GLint* params)
+{
+
+	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
+	IOStream *stream = ctx->m_stream;
+	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+	bool useChecksum = checksumCalculator->getVersion() > 0;
+
+	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
+	 unsigned char *ptr;
+	 unsigned char *buf;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
+	 const size_t checksumSize = checksumCalculator->checksumByteSize();
+	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
+	buf = stream->alloc(totalSize);
+	ptr = buf;
+	int tmp = OP_glGetTexLevelParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
+	memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+		memcpy(ptr, &target, 4); ptr += 4;
+		memcpy(ptr, &level, 4); ptr += 4;
+		memcpy(ptr, &pname, 4); ptr += 4;
+	*(unsigned int *)(ptr) = __size_params; ptr += 4;
+
+	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+	stream->readback(params, __size_params);
+	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
+	if (useChecksum) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("glGetTexLevelParameteriv: GL communication error, please report this issue to b.android.com.\n");
+			abort();
+		}
+	}
+}
+
 }  // namespace
 
 gl2_encoder_context_t::gl2_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator)
@@ -5187,5 +11255,208 @@ gl2_encoder_context_t::gl2_encoder_context_t(IOStream *stream, ChecksumCalculato
 	this->glGetCompressedTextureFormats = &glGetCompressedTextureFormats_enc;
 	this->glShaderString = &glShaderString_enc;
 	this->glFinishRoundTrip = &glFinishRoundTrip_enc;
+	this->glGenVertexArrays = &glGenVertexArrays_enc;
+	this->glBindVertexArray = &glBindVertexArray_enc;
+	this->glDeleteVertexArrays = &glDeleteVertexArrays_enc;
+	this->glIsVertexArray = &glIsVertexArray_enc;
+	this->glMapBufferRange = (glMapBufferRange_client_proc_t) &enc_unsupported;
+	this->glUnmapBuffer = (glUnmapBuffer_client_proc_t) &enc_unsupported;
+	this->glFlushMappedBufferRange = (glFlushMappedBufferRange_client_proc_t) &enc_unsupported;
+	this->glMapBufferRangeAEMU = &glMapBufferRangeAEMU_enc;
+	this->glUnmapBufferAEMU = &glUnmapBufferAEMU_enc;
+	this->glFlushMappedBufferRangeAEMU = &glFlushMappedBufferRangeAEMU_enc;
+	this->glReadPixelsOffsetAEMU = &glReadPixelsOffsetAEMU_enc;
+	this->glCompressedTexImage2DOffsetAEMU = &glCompressedTexImage2DOffsetAEMU_enc;
+	this->glCompressedTexSubImage2DOffsetAEMU = &glCompressedTexSubImage2DOffsetAEMU_enc;
+	this->glTexImage2DOffsetAEMU = &glTexImage2DOffsetAEMU_enc;
+	this->glTexSubImage2DOffsetAEMU = &glTexSubImage2DOffsetAEMU_enc;
+	this->glBindBufferRange = &glBindBufferRange_enc;
+	this->glBindBufferBase = &glBindBufferBase_enc;
+	this->glCopyBufferSubData = &glCopyBufferSubData_enc;
+	this->glClearBufferiv = &glClearBufferiv_enc;
+	this->glClearBufferuiv = &glClearBufferuiv_enc;
+	this->glClearBufferfv = &glClearBufferfv_enc;
+	this->glClearBufferfi = &glClearBufferfi_enc;
+	this->glGetBufferParameteri64v = (glGetBufferParameteri64v_client_proc_t) &enc_unsupported;
+	this->glGetBufferPointerv = (glGetBufferPointerv_client_proc_t) &enc_unsupported;
+	this->glUniformBlockBinding = &glUniformBlockBinding_enc;
+	this->glGetUniformBlockIndex = &glGetUniformBlockIndex_enc;
+	this->glGetUniformIndices = (glGetUniformIndices_client_proc_t) &enc_unsupported;
+	this->glGetUniformIndicesAEMU = &glGetUniformIndicesAEMU_enc;
+	this->glGetActiveUniformBlockiv = &glGetActiveUniformBlockiv_enc;
+	this->glGetActiveUniformBlockName = &glGetActiveUniformBlockName_enc;
+	this->glUniform1ui = &glUniform1ui_enc;
+	this->glUniform2ui = &glUniform2ui_enc;
+	this->glUniform3ui = &glUniform3ui_enc;
+	this->glUniform4ui = &glUniform4ui_enc;
+	this->glUniform1uiv = &glUniform1uiv_enc;
+	this->glUniform2uiv = &glUniform2uiv_enc;
+	this->glUniform3uiv = &glUniform3uiv_enc;
+	this->glUniform4uiv = &glUniform4uiv_enc;
+	this->glUniformMatrix2x3fv = &glUniformMatrix2x3fv_enc;
+	this->glUniformMatrix3x2fv = &glUniformMatrix3x2fv_enc;
+	this->glUniformMatrix2x4fv = &glUniformMatrix2x4fv_enc;
+	this->glUniformMatrix4x2fv = &glUniformMatrix4x2fv_enc;
+	this->glUniformMatrix3x4fv = &glUniformMatrix3x4fv_enc;
+	this->glUniformMatrix4x3fv = &glUniformMatrix4x3fv_enc;
+	this->glGetUniformuiv = &glGetUniformuiv_enc;
+	this->glGetActiveUniformsiv = &glGetActiveUniformsiv_enc;
+	this->glVertexAttribI4i = &glVertexAttribI4i_enc;
+	this->glVertexAttribI4ui = &glVertexAttribI4ui_enc;
+	this->glVertexAttribI4iv = &glVertexAttribI4iv_enc;
+	this->glVertexAttribI4uiv = &glVertexAttribI4uiv_enc;
+	this->glVertexAttribIPointer = (glVertexAttribIPointer_client_proc_t) &enc_unsupported;
+	this->glVertexAttribIPointerOffsetAEMU = &glVertexAttribIPointerOffsetAEMU_enc;
+	this->glVertexAttribIPointerDataAEMU = &glVertexAttribIPointerDataAEMU_enc;
+	this->glGetVertexAttribIiv = &glGetVertexAttribIiv_enc;
+	this->glGetVertexAttribIuiv = &glGetVertexAttribIuiv_enc;
+	this->glVertexAttribDivisor = &glVertexAttribDivisor_enc;
+	this->glDrawArraysInstanced = &glDrawArraysInstanced_enc;
+	this->glDrawElementsInstanced = (glDrawElementsInstanced_client_proc_t) &enc_unsupported;
+	this->glDrawElementsInstancedDataAEMU = &glDrawElementsInstancedDataAEMU_enc;
+	this->glDrawElementsInstancedOffsetAEMU = &glDrawElementsInstancedOffsetAEMU_enc;
+	this->glDrawRangeElements = (glDrawRangeElements_client_proc_t) &enc_unsupported;
+	this->glDrawRangeElementsDataAEMU = &glDrawRangeElementsDataAEMU_enc;
+	this->glDrawRangeElementsOffsetAEMU = &glDrawRangeElementsOffsetAEMU_enc;
+	this->glFenceSync = (glFenceSync_client_proc_t) &enc_unsupported;
+	this->glClientWaitSync = (glClientWaitSync_client_proc_t) &enc_unsupported;
+	this->glWaitSync = (glWaitSync_client_proc_t) &enc_unsupported;
+	this->glDeleteSync = (glDeleteSync_client_proc_t) &enc_unsupported;
+	this->glIsSync = (glIsSync_client_proc_t) &enc_unsupported;
+	this->glGetSynciv = (glGetSynciv_client_proc_t) &enc_unsupported;
+	this->glFenceSyncAEMU = &glFenceSyncAEMU_enc;
+	this->glClientWaitSyncAEMU = &glClientWaitSyncAEMU_enc;
+	this->glWaitSyncAEMU = &glWaitSyncAEMU_enc;
+	this->glDeleteSyncAEMU = &glDeleteSyncAEMU_enc;
+	this->glIsSyncAEMU = &glIsSyncAEMU_enc;
+	this->glGetSyncivAEMU = &glGetSyncivAEMU_enc;
+	this->glDrawBuffers = &glDrawBuffers_enc;
+	this->glReadBuffer = &glReadBuffer_enc;
+	this->glBlitFramebuffer = &glBlitFramebuffer_enc;
+	this->glInvalidateFramebuffer = &glInvalidateFramebuffer_enc;
+	this->glInvalidateSubFramebuffer = &glInvalidateSubFramebuffer_enc;
+	this->glFramebufferTextureLayer = &glFramebufferTextureLayer_enc;
+	this->glRenderbufferStorageMultisample = &glRenderbufferStorageMultisample_enc;
+	this->glTexStorage2D = &glTexStorage2D_enc;
+	this->glGetInternalformativ = &glGetInternalformativ_enc;
+	this->glBeginTransformFeedback = &glBeginTransformFeedback_enc;
+	this->glEndTransformFeedback = &glEndTransformFeedback_enc;
+	this->glGenTransformFeedbacks = &glGenTransformFeedbacks_enc;
+	this->glDeleteTransformFeedbacks = &glDeleteTransformFeedbacks_enc;
+	this->glBindTransformFeedback = &glBindTransformFeedback_enc;
+	this->glPauseTransformFeedback = &glPauseTransformFeedback_enc;
+	this->glResumeTransformFeedback = &glResumeTransformFeedback_enc;
+	this->glIsTransformFeedback = &glIsTransformFeedback_enc;
+	this->glTransformFeedbackVaryings = (glTransformFeedbackVaryings_client_proc_t) &enc_unsupported;
+	this->glTransformFeedbackVaryingsAEMU = &glTransformFeedbackVaryingsAEMU_enc;
+	this->glGetTransformFeedbackVarying = &glGetTransformFeedbackVarying_enc;
+	this->glGenSamplers = &glGenSamplers_enc;
+	this->glDeleteSamplers = &glDeleteSamplers_enc;
+	this->glBindSampler = &glBindSampler_enc;
+	this->glSamplerParameterf = &glSamplerParameterf_enc;
+	this->glSamplerParameteri = &glSamplerParameteri_enc;
+	this->glSamplerParameterfv = &glSamplerParameterfv_enc;
+	this->glSamplerParameteriv = &glSamplerParameteriv_enc;
+	this->glGetSamplerParameterfv = &glGetSamplerParameterfv_enc;
+	this->glGetSamplerParameteriv = &glGetSamplerParameteriv_enc;
+	this->glIsSampler = &glIsSampler_enc;
+	this->glGenQueries = &glGenQueries_enc;
+	this->glDeleteQueries = &glDeleteQueries_enc;
+	this->glBeginQuery = &glBeginQuery_enc;
+	this->glEndQuery = &glEndQuery_enc;
+	this->glGetQueryiv = &glGetQueryiv_enc;
+	this->glGetQueryObjectuiv = &glGetQueryObjectuiv_enc;
+	this->glIsQuery = &glIsQuery_enc;
+	this->glProgramParameteri = &glProgramParameteri_enc;
+	this->glProgramBinary = &glProgramBinary_enc;
+	this->glGetProgramBinary = &glGetProgramBinary_enc;
+	this->glGetFragDataLocation = &glGetFragDataLocation_enc;
+	this->glGetInteger64v = &glGetInteger64v_enc;
+	this->glGetIntegeri_v = &glGetIntegeri_v_enc;
+	this->glGetInteger64i_v = &glGetInteger64i_v_enc;
+	this->glTexImage3D = &glTexImage3D_enc;
+	this->glTexImage3DOffsetAEMU = &glTexImage3DOffsetAEMU_enc;
+	this->glTexStorage3D = &glTexStorage3D_enc;
+	this->glTexSubImage3D = &glTexSubImage3D_enc;
+	this->glTexSubImage3DOffsetAEMU = &glTexSubImage3DOffsetAEMU_enc;
+	this->glCompressedTexImage3D = &glCompressedTexImage3D_enc;
+	this->glCompressedTexImage3DOffsetAEMU = &glCompressedTexImage3DOffsetAEMU_enc;
+	this->glCompressedTexSubImage3D = &glCompressedTexSubImage3D_enc;
+	this->glCompressedTexSubImage3DOffsetAEMU = &glCompressedTexSubImage3DOffsetAEMU_enc;
+	this->glCopyTexSubImage3D = &glCopyTexSubImage3D_enc;
+	this->glGetStringi = (glGetStringi_client_proc_t) &enc_unsupported;
+	this->glGetBooleani_v = &glGetBooleani_v_enc;
+	this->glMemoryBarrier = &glMemoryBarrier_enc;
+	this->glMemoryBarrierByRegion = &glMemoryBarrierByRegion_enc;
+	this->glGenProgramPipelines = &glGenProgramPipelines_enc;
+	this->glDeleteProgramPipelines = &glDeleteProgramPipelines_enc;
+	this->glBindProgramPipeline = &glBindProgramPipeline_enc;
+	this->glGetProgramPipelineiv = &glGetProgramPipelineiv_enc;
+	this->glGetProgramPipelineInfoLog = &glGetProgramPipelineInfoLog_enc;
+	this->glValidateProgramPipeline = &glValidateProgramPipeline_enc;
+	this->glIsProgramPipeline = &glIsProgramPipeline_enc;
+	this->glUseProgramStages = &glUseProgramStages_enc;
+	this->glActiveShaderProgram = &glActiveShaderProgram_enc;
+	this->glCreateShaderProgramv = (glCreateShaderProgramv_client_proc_t) &enc_unsupported;
+	this->glCreateShaderProgramvAEMU = &glCreateShaderProgramvAEMU_enc;
+	this->glProgramUniform1f = &glProgramUniform1f_enc;
+	this->glProgramUniform2f = &glProgramUniform2f_enc;
+	this->glProgramUniform3f = &glProgramUniform3f_enc;
+	this->glProgramUniform4f = &glProgramUniform4f_enc;
+	this->glProgramUniform1i = &glProgramUniform1i_enc;
+	this->glProgramUniform2i = &glProgramUniform2i_enc;
+	this->glProgramUniform3i = &glProgramUniform3i_enc;
+	this->glProgramUniform4i = &glProgramUniform4i_enc;
+	this->glProgramUniform1ui = &glProgramUniform1ui_enc;
+	this->glProgramUniform2ui = &glProgramUniform2ui_enc;
+	this->glProgramUniform3ui = &glProgramUniform3ui_enc;
+	this->glProgramUniform4ui = &glProgramUniform4ui_enc;
+	this->glProgramUniform1fv = &glProgramUniform1fv_enc;
+	this->glProgramUniform2fv = &glProgramUniform2fv_enc;
+	this->glProgramUniform3fv = &glProgramUniform3fv_enc;
+	this->glProgramUniform4fv = &glProgramUniform4fv_enc;
+	this->glProgramUniform1iv = &glProgramUniform1iv_enc;
+	this->glProgramUniform2iv = &glProgramUniform2iv_enc;
+	this->glProgramUniform3iv = &glProgramUniform3iv_enc;
+	this->glProgramUniform4iv = &glProgramUniform4iv_enc;
+	this->glProgramUniform1uiv = &glProgramUniform1uiv_enc;
+	this->glProgramUniform2uiv = &glProgramUniform2uiv_enc;
+	this->glProgramUniform3uiv = &glProgramUniform3uiv_enc;
+	this->glProgramUniform4uiv = &glProgramUniform4uiv_enc;
+	this->glProgramUniformMatrix2fv = &glProgramUniformMatrix2fv_enc;
+	this->glProgramUniformMatrix3fv = &glProgramUniformMatrix3fv_enc;
+	this->glProgramUniformMatrix4fv = &glProgramUniformMatrix4fv_enc;
+	this->glProgramUniformMatrix2x3fv = &glProgramUniformMatrix2x3fv_enc;
+	this->glProgramUniformMatrix3x2fv = &glProgramUniformMatrix3x2fv_enc;
+	this->glProgramUniformMatrix2x4fv = &glProgramUniformMatrix2x4fv_enc;
+	this->glProgramUniformMatrix4x2fv = &glProgramUniformMatrix4x2fv_enc;
+	this->glProgramUniformMatrix3x4fv = &glProgramUniformMatrix3x4fv_enc;
+	this->glProgramUniformMatrix4x3fv = &glProgramUniformMatrix4x3fv_enc;
+	this->glGetProgramInterfaceiv = &glGetProgramInterfaceiv_enc;
+	this->glGetProgramResourceiv = &glGetProgramResourceiv_enc;
+	this->glGetProgramResourceIndex = &glGetProgramResourceIndex_enc;
+	this->glGetProgramResourceLocation = &glGetProgramResourceLocation_enc;
+	this->glGetProgramResourceName = &glGetProgramResourceName_enc;
+	this->glBindImageTexture = &glBindImageTexture_enc;
+	this->glDispatchCompute = &glDispatchCompute_enc;
+	this->glDispatchComputeIndirect = &glDispatchComputeIndirect_enc;
+	this->glBindVertexBuffer = &glBindVertexBuffer_enc;
+	this->glVertexAttribBinding = &glVertexAttribBinding_enc;
+	this->glVertexAttribFormat = &glVertexAttribFormat_enc;
+	this->glVertexAttribIFormat = &glVertexAttribIFormat_enc;
+	this->glVertexBindingDivisor = &glVertexBindingDivisor_enc;
+	this->glDrawArraysIndirect = (glDrawArraysIndirect_client_proc_t) &enc_unsupported;
+	this->glDrawArraysIndirectDataAEMU = &glDrawArraysIndirectDataAEMU_enc;
+	this->glDrawArraysIndirectOffsetAEMU = &glDrawArraysIndirectOffsetAEMU_enc;
+	this->glDrawElementsIndirect = (glDrawElementsIndirect_client_proc_t) &enc_unsupported;
+	this->glDrawElementsIndirectDataAEMU = &glDrawElementsIndirectDataAEMU_enc;
+	this->glDrawElementsIndirectOffsetAEMU = &glDrawElementsIndirectOffsetAEMU_enc;
+	this->glTexStorage2DMultisample = &glTexStorage2DMultisample_enc;
+	this->glSampleMaski = &glSampleMaski_enc;
+	this->glGetMultisamplefv = &glGetMultisamplefv_enc;
+	this->glFramebufferParameteri = &glFramebufferParameteri_enc;
+	this->glGetFramebufferParameteriv = &glGetFramebufferParameteriv_enc;
+	this->glGetTexLevelParameterfv = &glGetTexLevelParameterfv_enc;
+	this->glGetTexLevelParameteriv = &glGetTexLevelParameteriv_enc;
 }
 
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.h b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.h
index 760d729..4129b9d 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_enc.h
@@ -19,6 +19,7 @@ struct gl2_encoder_context_t : public gl2_client_context_t {
 	ChecksumCalculator *m_checksumCalculator;
 
 	gl2_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator);
+	virtual uint64_t lockAndWriteDma(void* data, uint32_t sz) { return 0; }
 };
 
-#endif  // GUARD_gl2_encoder_context_t
\ No newline at end of file
+#endif  // GUARD_gl2_encoder_context_t
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_entry.cpp b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_entry.cpp
index 3812aae..5713921 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_entry.cpp
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_entry.cpp
@@ -4,7 +4,6 @@
 #include <stdlib.h>
 #include "gl2_client_context.h"
 
-#ifndef GL_TRUE
 extern "C" {
 	void glActiveTexture(GLenum texture);
 	void glAttachShader(GLuint program, GLuint shader);
@@ -214,9 +213,211 @@ extern "C" {
 	void glGetCompressedTextureFormats(int count, GLint* formats);
 	void glShaderString(GLuint shader, const GLchar* string, GLsizei len);
 	int glFinishRoundTrip();
+	void glGenVertexArrays(GLsizei n, GLuint* arrays);
+	void glBindVertexArray(GLuint array);
+	void glDeleteVertexArrays(GLsizei n, const GLuint* arrays);
+	GLboolean glIsVertexArray(GLuint array);
+	void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
+	GLboolean glUnmapBuffer(GLenum target);
+	void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
+	void glMapBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* mapped);
+	void glUnmapBufferAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer, GLboolean* out_res);
+	void glFlushMappedBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer);
+	void glReadPixelsOffsetAEMU(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset);
+	void glCompressedTexImage2DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLuint offset);
+	void glCompressedTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLuint offset);
+	void glTexImage2DOffsetAEMU(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLuint offset);
+	void glTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset);
+	void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+	void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
+	void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
+	void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint* value);
+	void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint* value);
+	void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat* value);
+	void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
+	void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64* data);
+	void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid** params);
+	void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
+	GLuint glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName);
+	void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices);
+	void glGetUniformIndicesAEMU(GLuint program, GLsizei uniformCount, const GLchar* packedUniformNames, GLsizei packedLen, GLuint* uniformIndices);
+	void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
+	void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
+	void glUniform1ui(GLint location, GLuint v0);
+	void glUniform2ui(GLint location, GLuint v0, GLuint v1);
+	void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
+	void glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3);
+	void glUniform1uiv(GLint location, GLsizei count, const GLuint* value);
+	void glUniform2uiv(GLint location, GLsizei count, const GLuint* value);
+	void glUniform3uiv(GLint location, GLsizei count, const GLuint* value);
+	void glUniform4uiv(GLint location, GLsizei count, const GLuint* value);
+	void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glGetUniformuiv(GLuint program, GLint location, GLuint* params);
+	void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
+	void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
+	void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
+	void glVertexAttribI4iv(GLuint index, const GLint* v);
+	void glVertexAttribI4uiv(GLuint index, const GLuint* v);
+	void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
+	void glVertexAttribIPointerOffsetAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset);
+	void glVertexAttribIPointerDataAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
+	void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params);
+	void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params);
+	void glVertexAttribDivisor(GLuint index, GLuint divisor);
+	void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
+	void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
+	void glDrawElementsInstancedDataAEMU(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLsizei datalen);
+	void glDrawElementsInstancedOffsetAEMU(GLenum mode, GLsizei count, GLenum type, GLuint offset, GLsizei primcount);
+	void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices);
+	void glDrawRangeElementsDataAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices, GLsizei datalen);
+	void glDrawRangeElementsOffsetAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLuint offset);
+	GLsync glFenceSync(GLenum condition, GLbitfield flags);
+	GLenum glClientWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout);
+	void glWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout);
+	void glDeleteSync(GLsync to_delete);
+	GLboolean glIsSync(GLsync sync);
+	void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values);
+	uint64_t glFenceSyncAEMU(GLenum condition, GLbitfield flags);
+	GLenum glClientWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout);
+	void glWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout);
+	void glDeleteSyncAEMU(uint64_t to_delete);
+	GLboolean glIsSyncAEMU(uint64_t sync);
+	void glGetSyncivAEMU(uint64_t sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values);
+	void glDrawBuffers(GLsizei n, const GLenum* bufs);
+	void glReadBuffer(GLenum src);
+	void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+	void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments);
+	void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
+	void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
+	void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+	void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
+	void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
+	void glBeginTransformFeedback(GLenum primitiveMode);
+	void glEndTransformFeedback();
+	void glGenTransformFeedbacks(GLsizei n, GLuint* ids);
+	void glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids);
+	void glBindTransformFeedback(GLenum target, GLuint id);
+	void glPauseTransformFeedback();
+	void glResumeTransformFeedback();
+	GLboolean glIsTransformFeedback(GLuint id);
+	void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char** varyings, GLenum bufferMode);
+	void glTransformFeedbackVaryingsAEMU(GLuint program, GLsizei count, const char* packedVaryings, GLuint packedVaryingsLen, GLenum bufferMode);
+	void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name);
+	void glGenSamplers(GLsizei n, GLuint* samplers);
+	void glDeleteSamplers(GLsizei n, const GLuint* samplers);
+	void glBindSampler(GLuint unit, GLuint sampler);
+	void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
+	void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
+	void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* params);
+	void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* params);
+	void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params);
+	void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params);
+	GLboolean glIsSampler(GLuint sampler);
+	void glGenQueries(GLsizei n, GLuint* queries);
+	void glDeleteQueries(GLsizei n, const GLuint* queries);
+	void glBeginQuery(GLenum target, GLuint query);
+	void glEndQuery(GLenum target);
+	void glGetQueryiv(GLenum target, GLenum pname, GLint* params);
+	void glGetQueryObjectuiv(GLuint query, GLenum pname, GLuint* params);
+	GLboolean glIsQuery(GLuint query);
+	void glProgramParameteri(GLuint program, GLenum pname, GLint value);
+	void glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length);
+	void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
+	GLint glGetFragDataLocation(GLuint program, const char* name);
+	void glGetInteger64v(GLenum pname, GLint64* data);
+	void glGetIntegeri_v(GLenum target, GLuint index, GLint* data);
+	void glGetInteger64i_v(GLenum target, GLuint index, GLint64* data);
+	void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data);
+	void glTexImage3DOffsetAEMU(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLuint offset);
+	void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
+	void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data);
+	void glTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLuint offset);
+	void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
+	void glCompressedTexImage3DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLuint offset);
+	void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
+	void glCompressedTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLuint data);
+	void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+	const GLubyte* glGetStringi(GLenum name, GLuint index);
+	void glGetBooleani_v(GLenum target, GLuint index, GLboolean* data);
+	void glMemoryBarrier(GLbitfield barriers);
+	void glMemoryBarrierByRegion(GLbitfield barriers);
+	void glGenProgramPipelines(GLsizei n, GLuint* pipelines);
+	void glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines);
+	void glBindProgramPipeline(GLuint pipeline);
+	void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params);
+	void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
+	void glValidateProgramPipeline(GLuint pipeline);
+	GLboolean glIsProgramPipeline(GLuint pipeline);
+	void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
+	void glActiveShaderProgram(GLuint pipeline, GLuint program);
+	GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char** strings);
+	GLuint glCreateShaderProgramvAEMU(GLenum type, GLsizei count, const char* packedStrings, GLuint packedLen);
+	void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
+	void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
+	void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+	void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+	void glProgramUniform1i(GLuint program, GLint location, GLint v0);
+	void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
+	void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
+	void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+	void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
+	void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1);
+	void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2);
+	void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3);
+	void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
+	void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
+	void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
+	void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
+	void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value);
+	void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value);
+	void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value);
+	void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value);
+	void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
+	void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
+	void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
+	void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
+	void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+	void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params);
+	void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params);
+	GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char* name);
+	GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char* name);
+	void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name);
+	void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
+	void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
+	void glDispatchComputeIndirect(GLintptr indirect);
+	void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride);
+	void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
+	void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
+	void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
+	void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
+	void glDrawArraysIndirect(GLenum mode, const void* indirect);
+	void glDrawArraysIndirectDataAEMU(GLenum mode, const void* indirect, GLuint datalen);
+	void glDrawArraysIndirectOffsetAEMU(GLenum mode, GLuint offset);
+	void glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect);
+	void glDrawElementsIndirectDataAEMU(GLenum mode, GLenum type, const void* indirect, GLuint datalen);
+	void glDrawElementsIndirectOffsetAEMU(GLenum mode, GLenum type, GLuint offset);
+	void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
+	void glSampleMaski(GLuint maskNumber, GLbitfield mask);
+	void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val);
+	void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
+	void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params);
+	void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params);
+	void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params);
 };
 
-#endif
 #ifndef GET_CONTEXT
 static gl2_client_context_t::CONTEXT_ACCESSOR_TYPE *getCurrentContext = NULL;
 void gl2_client_context_t::setContextAccessor(CONTEXT_ACCESSOR_TYPE *f) { getCurrentContext = f; }
@@ -352,12 +553,14 @@ void glCompileShader(GLuint shader)
 void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
 {
 	GET_CONTEXT;
+	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glCompressedTexImage2D(ctx, target, level, internalformat, width, height, border, imageSize, data);
 }
 
 void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
 {
 	GET_CONTEXT;
+	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glCompressedTexSubImage2D(ctx, target, level, xoffset, yoffset, width, height, format, imageSize, data);
 }
 
@@ -558,12 +761,14 @@ void glGenTextures(GLsizei n, GLuint* textures)
 void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
 {
 	GET_CONTEXT;
+	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glGetActiveAttrib(ctx, program, index, bufsize, length, size, type, name);
 }
 
 void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
 {
 	GET_CONTEXT;
+	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glGetActiveUniform(ctx, program, index, bufsize, length, size, type, name);
 }
 
@@ -624,6 +829,7 @@ void glGetProgramiv(GLuint program, GLenum pname, GLint* params)
 void glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
 {
 	GET_CONTEXT;
+	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glGetProgramInfoLog(ctx, program, bufsize, length, infolog);
 }
 
@@ -642,6 +848,7 @@ void glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
 void glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
 {
 	GET_CONTEXT;
+	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glGetShaderInfoLog(ctx, shader, bufsize, length, infolog);
 }
 
@@ -654,6 +861,7 @@ void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint*
 void glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
 {
 	GET_CONTEXT;
+	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glGetShaderSource(ctx, shader, bufsize, length, source);
 }
 
@@ -1140,12 +1348,14 @@ void glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yof
 void glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
 {
 	GET_CONTEXT;
+	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glCompressedTexImage3DOES(ctx, target, level, internalformat, width, height, depth, border, imageSize, data);
 }
 
 void glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
 {
 	GET_CONTEXT;
+	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
 	ctx->glCompressedTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
 }
 
@@ -1481,3 +1691,1239 @@ int glFinishRoundTrip()
 	return ctx->glFinishRoundTrip(ctx);
 }
 
+void glGenVertexArrays(GLsizei n, GLuint* arrays)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGenVertexArrays(ctx, n, arrays);
+}
+
+void glBindVertexArray(GLuint array)
+{
+	GET_CONTEXT;
+	ctx->glBindVertexArray(ctx, array);
+}
+
+void glDeleteVertexArrays(GLsizei n, const GLuint* arrays)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glDeleteVertexArrays(ctx, n, arrays);
+}
+
+GLboolean glIsVertexArray(GLuint array)
+{
+	GET_CONTEXT;
+	return ctx->glIsVertexArray(ctx, array);
+}
+
+void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
+{
+	GET_CONTEXT;
+	return ctx->glMapBufferRange(ctx, target, offset, length, access);
+}
+
+GLboolean glUnmapBuffer(GLenum target)
+{
+	GET_CONTEXT;
+	return ctx->glUnmapBuffer(ctx, target);
+}
+
+void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
+{
+	GET_CONTEXT;
+	ctx->glFlushMappedBufferRange(ctx, target, offset, length);
+}
+
+void glMapBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* mapped)
+{
+	GET_CONTEXT;
+	ctx->glMapBufferRangeAEMU(ctx, target, offset, length, access, mapped);
+}
+
+void glUnmapBufferAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer, GLboolean* out_res)
+{
+	GET_CONTEXT;
+	ctx->glUnmapBufferAEMU(ctx, target, offset, length, access, guest_buffer, out_res);
+}
+
+void glFlushMappedBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer)
+{
+	GET_CONTEXT;
+	ctx->glFlushMappedBufferRangeAEMU(ctx, target, offset, length, access, guest_buffer);
+}
+
+void glReadPixelsOffsetAEMU(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glReadPixelsOffsetAEMU(ctx, x, y, width, height, format, type, offset);
+}
+
+void glCompressedTexImage2DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glCompressedTexImage2DOffsetAEMU(ctx, target, level, internalformat, width, height, border, imageSize, offset);
+}
+
+void glCompressedTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glCompressedTexSubImage2DOffsetAEMU(ctx, target, level, xoffset, yoffset, width, height, format, imageSize, offset);
+}
+
+void glTexImage2DOffsetAEMU(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glTexImage2DOffsetAEMU(ctx, target, level, internalformat, width, height, border, format, type, offset);
+}
+
+void glTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glTexSubImage2DOffsetAEMU(ctx, target, level, xoffset, yoffset, width, height, format, type, offset);
+}
+
+void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
+{
+	GET_CONTEXT;
+	ctx->glBindBufferRange(ctx, target, index, buffer, offset, size);
+}
+
+void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
+{
+	GET_CONTEXT;
+	ctx->glBindBufferBase(ctx, target, index, buffer);
+}
+
+void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
+{
+	GET_CONTEXT;
+	ctx->glCopyBufferSubData(ctx, readtarget, writetarget, readoffset, writeoffset, size);
+}
+
+void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint* value)
+{
+	GET_CONTEXT;
+	ctx->glClearBufferiv(ctx, buffer, drawBuffer, value);
+}
+
+void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glClearBufferuiv(ctx, buffer, drawBuffer, value);
+}
+
+void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glClearBufferfv(ctx, buffer, drawBuffer, value);
+}
+
+void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)
+{
+	GET_CONTEXT;
+	ctx->glClearBufferfi(ctx, buffer, drawBuffer, depth, stencil);
+}
+
+void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64* data)
+{
+	GET_CONTEXT;
+	ctx->glGetBufferParameteri64v(ctx, target, value, data);
+}
+
+void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid** params)
+{
+	GET_CONTEXT;
+	ctx->glGetBufferPointerv(ctx, target, pname, params);
+}
+
+void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
+{
+	GET_CONTEXT;
+	ctx->glUniformBlockBinding(ctx, program, uniformBlockIndex, uniformBlockBinding);
+}
+
+GLuint glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName)
+{
+	GET_CONTEXT;
+	return ctx->glGetUniformBlockIndex(ctx, program, uniformBlockName);
+}
+
+void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices)
+{
+	GET_CONTEXT;
+	ctx->glGetUniformIndices(ctx, program, uniformCount, uniformNames, uniformIndices);
+}
+
+void glGetUniformIndicesAEMU(GLuint program, GLsizei uniformCount, const GLchar* packedUniformNames, GLsizei packedLen, GLuint* uniformIndices)
+{
+	GET_CONTEXT;
+	ctx->glGetUniformIndicesAEMU(ctx, program, uniformCount, packedUniformNames, packedLen, uniformIndices);
+}
+
+void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetActiveUniformBlockiv(ctx, program, uniformBlockIndex, pname, params);
+}
+
+void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetActiveUniformBlockName(ctx, program, uniformBlockIndex, bufSize, length, uniformBlockName);
+}
+
+void glUniform1ui(GLint location, GLuint v0)
+{
+	GET_CONTEXT;
+	ctx->glUniform1ui(ctx, location, v0);
+}
+
+void glUniform2ui(GLint location, GLuint v0, GLuint v1)
+{
+	GET_CONTEXT;
+	ctx->glUniform2ui(ctx, location, v0, v1);
+}
+
+void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
+{
+	GET_CONTEXT;
+	ctx->glUniform3ui(ctx, location, v0, v1, v2);
+}
+
+void glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)
+{
+	GET_CONTEXT;
+	ctx->glUniform4ui(ctx, location, v0, v1, v2, v3);
+}
+
+void glUniform1uiv(GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glUniform1uiv(ctx, location, count, value);
+}
+
+void glUniform2uiv(GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glUniform2uiv(ctx, location, count, value);
+}
+
+void glUniform3uiv(GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glUniform3uiv(ctx, location, count, value);
+}
+
+void glUniform4uiv(GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glUniform4uiv(ctx, location, count, value);
+}
+
+void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glUniformMatrix2x3fv(ctx, location, count, transpose, value);
+}
+
+void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glUniformMatrix3x2fv(ctx, location, count, transpose, value);
+}
+
+void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glUniformMatrix2x4fv(ctx, location, count, transpose, value);
+}
+
+void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glUniformMatrix4x2fv(ctx, location, count, transpose, value);
+}
+
+void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glUniformMatrix3x4fv(ctx, location, count, transpose, value);
+}
+
+void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glUniformMatrix4x3fv(ctx, location, count, transpose, value);
+}
+
+void glGetUniformuiv(GLuint program, GLint location, GLuint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetUniformuiv(ctx, program, location, params);
+}
+
+void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetActiveUniformsiv(ctx, program, uniformCount, uniformIndices, pname, params);
+}
+
+void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribI4i(ctx, index, v0, v1, v2, v3);
+}
+
+void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribI4ui(ctx, index, v0, v1, v2, v3);
+}
+
+void glVertexAttribI4iv(GLuint index, const GLint* v)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribI4iv(ctx, index, v);
+}
+
+void glVertexAttribI4uiv(GLuint index, const GLuint* v)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribI4uiv(ctx, index, v);
+}
+
+void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribIPointer(ctx, index, size, type, stride, pointer);
+}
+
+void glVertexAttribIPointerOffsetAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribIPointerOffsetAEMU(ctx, index, size, type, stride, offset);
+}
+
+void glVertexAttribIPointerDataAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribIPointerDataAEMU(ctx, index, size, type, stride, data, datalen);
+}
+
+void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetVertexAttribIiv(ctx, index, pname, params);
+}
+
+void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetVertexAttribIuiv(ctx, index, pname, params);
+}
+
+void glVertexAttribDivisor(GLuint index, GLuint divisor)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribDivisor(ctx, index, divisor);
+}
+
+void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
+{
+	GET_CONTEXT;
+	ctx->glDrawArraysInstanced(ctx, mode, first, count, primcount);
+}
+
+void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount)
+{
+	GET_CONTEXT;
+	ctx->glDrawElementsInstanced(ctx, mode, count, type, indices, primcount);
+}
+
+void glDrawElementsInstancedDataAEMU(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLsizei datalen)
+{
+	GET_CONTEXT;
+	ctx->glDrawElementsInstancedDataAEMU(ctx, mode, count, type, indices, primcount, datalen);
+}
+
+void glDrawElementsInstancedOffsetAEMU(GLenum mode, GLsizei count, GLenum type, GLuint offset, GLsizei primcount)
+{
+	GET_CONTEXT;
+	ctx->glDrawElementsInstancedOffsetAEMU(ctx, mode, count, type, offset, primcount);
+}
+
+void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices)
+{
+	GET_CONTEXT;
+	ctx->glDrawRangeElements(ctx, mode, start, end, count, type, indices);
+}
+
+void glDrawRangeElementsDataAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices, GLsizei datalen)
+{
+	GET_CONTEXT;
+	ctx->glDrawRangeElementsDataAEMU(ctx, mode, start, end, count, type, indices, datalen);
+}
+
+void glDrawRangeElementsOffsetAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glDrawRangeElementsOffsetAEMU(ctx, mode, start, end, count, type, offset);
+}
+
+GLsync glFenceSync(GLenum condition, GLbitfield flags)
+{
+	GET_CONTEXT;
+	return ctx->glFenceSync(ctx, condition, flags);
+}
+
+GLenum glClientWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout)
+{
+	GET_CONTEXT;
+	return ctx->glClientWaitSync(ctx, wait_on, flags, timeout);
+}
+
+void glWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout)
+{
+	GET_CONTEXT;
+	ctx->glWaitSync(ctx, wait_on, flags, timeout);
+}
+
+void glDeleteSync(GLsync to_delete)
+{
+	GET_CONTEXT;
+	ctx->glDeleteSync(ctx, to_delete);
+}
+
+GLboolean glIsSync(GLsync sync)
+{
+	GET_CONTEXT;
+	return ctx->glIsSync(ctx, sync);
+}
+
+void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values)
+{
+	GET_CONTEXT;
+	ctx->glGetSynciv(ctx, sync, pname, bufSize, length, values);
+}
+
+uint64_t glFenceSyncAEMU(GLenum condition, GLbitfield flags)
+{
+	GET_CONTEXT;
+	return ctx->glFenceSyncAEMU(ctx, condition, flags);
+}
+
+GLenum glClientWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout)
+{
+	GET_CONTEXT;
+	return ctx->glClientWaitSyncAEMU(ctx, wait_on, flags, timeout);
+}
+
+void glWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout)
+{
+	GET_CONTEXT;
+	ctx->glWaitSyncAEMU(ctx, wait_on, flags, timeout);
+}
+
+void glDeleteSyncAEMU(uint64_t to_delete)
+{
+	GET_CONTEXT;
+	ctx->glDeleteSyncAEMU(ctx, to_delete);
+}
+
+GLboolean glIsSyncAEMU(uint64_t sync)
+{
+	GET_CONTEXT;
+	return ctx->glIsSyncAEMU(ctx, sync);
+}
+
+void glGetSyncivAEMU(uint64_t sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetSyncivAEMU(ctx, sync, pname, bufSize, length, values);
+}
+
+void glDrawBuffers(GLsizei n, const GLenum* bufs)
+{
+	GET_CONTEXT;
+	ctx->glDrawBuffers(ctx, n, bufs);
+}
+
+void glReadBuffer(GLenum src)
+{
+	GET_CONTEXT;
+	ctx->glReadBuffer(ctx, src);
+}
+
+void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
+{
+	GET_CONTEXT;
+	ctx->glBlitFramebuffer(ctx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
+}
+
+void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments)
+{
+	GET_CONTEXT;
+	ctx->glInvalidateFramebuffer(ctx, target, numAttachments, attachments);
+}
+
+void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+	GET_CONTEXT;
+	ctx->glInvalidateSubFramebuffer(ctx, target, numAttachments, attachments, x, y, width, height);
+}
+
+void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
+{
+	GET_CONTEXT;
+	ctx->glFramebufferTextureLayer(ctx, target, attachment, texture, level, layer);
+}
+
+void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
+{
+	GET_CONTEXT;
+	ctx->glRenderbufferStorageMultisample(ctx, target, samples, internalformat, width, height);
+}
+
+void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
+{
+	GET_CONTEXT;
+	ctx->glTexStorage2D(ctx, target, levels, internalformat, width, height);
+}
+
+void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetInternalformativ(ctx, target, internalformat, pname, bufSize, params);
+}
+
+void glBeginTransformFeedback(GLenum primitiveMode)
+{
+	GET_CONTEXT;
+	ctx->glBeginTransformFeedback(ctx, primitiveMode);
+}
+
+void glEndTransformFeedback()
+{
+	GET_CONTEXT;
+	ctx->glEndTransformFeedback(ctx);
+}
+
+void glGenTransformFeedbacks(GLsizei n, GLuint* ids)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGenTransformFeedbacks(ctx, n, ids);
+}
+
+void glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glDeleteTransformFeedbacks(ctx, n, ids);
+}
+
+void glBindTransformFeedback(GLenum target, GLuint id)
+{
+	GET_CONTEXT;
+	ctx->glBindTransformFeedback(ctx, target, id);
+}
+
+void glPauseTransformFeedback()
+{
+	GET_CONTEXT;
+	ctx->glPauseTransformFeedback(ctx);
+}
+
+void glResumeTransformFeedback()
+{
+	GET_CONTEXT;
+	ctx->glResumeTransformFeedback(ctx);
+}
+
+GLboolean glIsTransformFeedback(GLuint id)
+{
+	GET_CONTEXT;
+	return ctx->glIsTransformFeedback(ctx, id);
+}
+
+void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char** varyings, GLenum bufferMode)
+{
+	GET_CONTEXT;
+	ctx->glTransformFeedbackVaryings(ctx, program, count, varyings, bufferMode);
+}
+
+void glTransformFeedbackVaryingsAEMU(GLuint program, GLsizei count, const char* packedVaryings, GLuint packedVaryingsLen, GLenum bufferMode)
+{
+	GET_CONTEXT;
+	ctx->glTransformFeedbackVaryingsAEMU(ctx, program, count, packedVaryings, packedVaryingsLen, bufferMode);
+}
+
+void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetTransformFeedbackVarying(ctx, program, index, bufSize, length, size, type, name);
+}
+
+void glGenSamplers(GLsizei n, GLuint* samplers)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGenSamplers(ctx, n, samplers);
+}
+
+void glDeleteSamplers(GLsizei n, const GLuint* samplers)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glDeleteSamplers(ctx, n, samplers);
+}
+
+void glBindSampler(GLuint unit, GLuint sampler)
+{
+	GET_CONTEXT;
+	ctx->glBindSampler(ctx, unit, sampler);
+}
+
+void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
+{
+	GET_CONTEXT;
+	ctx->glSamplerParameterf(ctx, sampler, pname, param);
+}
+
+void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
+{
+	GET_CONTEXT;
+	ctx->glSamplerParameteri(ctx, sampler, pname, param);
+}
+
+void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* params)
+{
+	GET_CONTEXT;
+	ctx->glSamplerParameterfv(ctx, sampler, pname, params);
+}
+
+void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glSamplerParameteriv(ctx, sampler, pname, params);
+}
+
+void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params)
+{
+	GET_CONTEXT;
+	ctx->glGetSamplerParameterfv(ctx, sampler, pname, params);
+}
+
+void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetSamplerParameteriv(ctx, sampler, pname, params);
+}
+
+GLboolean glIsSampler(GLuint sampler)
+{
+	GET_CONTEXT;
+	return ctx->glIsSampler(ctx, sampler);
+}
+
+void glGenQueries(GLsizei n, GLuint* queries)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGenQueries(ctx, n, queries);
+}
+
+void glDeleteQueries(GLsizei n, const GLuint* queries)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glDeleteQueries(ctx, n, queries);
+}
+
+void glBeginQuery(GLenum target, GLuint query)
+{
+	GET_CONTEXT;
+	ctx->glBeginQuery(ctx, target, query);
+}
+
+void glEndQuery(GLenum target)
+{
+	GET_CONTEXT;
+	ctx->glEndQuery(ctx, target);
+}
+
+void glGetQueryiv(GLenum target, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetQueryiv(ctx, target, pname, params);
+}
+
+void glGetQueryObjectuiv(GLuint query, GLenum pname, GLuint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetQueryObjectuiv(ctx, query, pname, params);
+}
+
+GLboolean glIsQuery(GLuint query)
+{
+	GET_CONTEXT;
+	return ctx->glIsQuery(ctx, query);
+}
+
+void glProgramParameteri(GLuint program, GLenum pname, GLint value)
+{
+	GET_CONTEXT;
+	ctx->glProgramParameteri(ctx, program, pname, value);
+}
+
+void glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length)
+{
+	GET_CONTEXT;
+	ctx->glProgramBinary(ctx, program, binaryFormat, binary, length);
+}
+
+void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetProgramBinary(ctx, program, bufSize, length, binaryFormat, binary);
+}
+
+GLint glGetFragDataLocation(GLuint program, const char* name)
+{
+	GET_CONTEXT;
+	return ctx->glGetFragDataLocation(ctx, program, name);
+}
+
+void glGetInteger64v(GLenum pname, GLint64* data)
+{
+	GET_CONTEXT;
+	ctx->glGetInteger64v(ctx, pname, data);
+}
+
+void glGetIntegeri_v(GLenum target, GLuint index, GLint* data)
+{
+	GET_CONTEXT;
+	ctx->glGetIntegeri_v(ctx, target, index, data);
+}
+
+void glGetInteger64i_v(GLenum target, GLuint index, GLint64* data)
+{
+	GET_CONTEXT;
+	ctx->glGetInteger64i_v(ctx, target, index, data);
+}
+
+void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data)
+{
+	GET_CONTEXT;
+	ctx->glTexImage3D(ctx, target, level, internalFormat, width, height, depth, border, format, type, data);
+}
+
+void glTexImage3DOffsetAEMU(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glTexImage3DOffsetAEMU(ctx, target, level, internalFormat, width, height, depth, border, format, type, offset);
+}
+
+void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
+{
+	GET_CONTEXT;
+	ctx->glTexStorage3D(ctx, target, levels, internalformat, width, height, depth);
+}
+
+void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data)
+{
+	GET_CONTEXT;
+	ctx->glTexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
+}
+
+void glTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glTexSubImage3DOffsetAEMU(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
+}
+
+void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
+{
+	GET_CONTEXT;
+	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glCompressedTexImage3D(ctx, target, level, internalformat, width, height, depth, border, imageSize, data);
+}
+
+void glCompressedTexImage3DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glCompressedTexImage3DOffsetAEMU(ctx, target, level, internalformat, width, height, depth, border, imageSize, offset);
+}
+
+void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
+{
+	GET_CONTEXT;
+	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glCompressedTexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
+}
+
+void glCompressedTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLuint data)
+{
+	GET_CONTEXT;
+	ctx->glCompressedTexSubImage3DOffsetAEMU(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
+}
+
+void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+	GET_CONTEXT;
+	ctx->glCopyTexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset, x, y, width, height);
+}
+
+const GLubyte* glGetStringi(GLenum name, GLuint index)
+{
+	GET_CONTEXT;
+	return ctx->glGetStringi(ctx, name, index);
+}
+
+void glGetBooleani_v(GLenum target, GLuint index, GLboolean* data)
+{
+	GET_CONTEXT;
+	ctx->glGetBooleani_v(ctx, target, index, data);
+}
+
+void glMemoryBarrier(GLbitfield barriers)
+{
+	GET_CONTEXT;
+	ctx->glMemoryBarrier(ctx, barriers);
+}
+
+void glMemoryBarrierByRegion(GLbitfield barriers)
+{
+	GET_CONTEXT;
+	ctx->glMemoryBarrierByRegion(ctx, barriers);
+}
+
+void glGenProgramPipelines(GLsizei n, GLuint* pipelines)
+{
+	GET_CONTEXT;
+	ctx->glGenProgramPipelines(ctx, n, pipelines);
+}
+
+void glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines)
+{
+	GET_CONTEXT;
+	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glDeleteProgramPipelines(ctx, n, pipelines);
+}
+
+void glBindProgramPipeline(GLuint pipeline)
+{
+	GET_CONTEXT;
+	ctx->glBindProgramPipeline(ctx, pipeline);
+}
+
+void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetProgramPipelineiv(ctx, pipeline, pname, params);
+}
+
+void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetProgramPipelineInfoLog(ctx, pipeline, bufSize, length, infoLog);
+}
+
+void glValidateProgramPipeline(GLuint pipeline)
+{
+	GET_CONTEXT;
+	ctx->glValidateProgramPipeline(ctx, pipeline);
+}
+
+GLboolean glIsProgramPipeline(GLuint pipeline)
+{
+	GET_CONTEXT;
+	return ctx->glIsProgramPipeline(ctx, pipeline);
+}
+
+void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
+{
+	GET_CONTEXT;
+	ctx->glUseProgramStages(ctx, pipeline, stages, program);
+}
+
+void glActiveShaderProgram(GLuint pipeline, GLuint program)
+{
+	GET_CONTEXT;
+	ctx->glActiveShaderProgram(ctx, pipeline, program);
+}
+
+GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char** strings)
+{
+	GET_CONTEXT;
+	return ctx->glCreateShaderProgramv(ctx, type, count, strings);
+}
+
+GLuint glCreateShaderProgramvAEMU(GLenum type, GLsizei count, const char* packedStrings, GLuint packedLen)
+{
+	GET_CONTEXT;
+	return ctx->glCreateShaderProgramvAEMU(ctx, type, count, packedStrings, packedLen);
+}
+
+void glProgramUniform1f(GLuint program, GLint location, GLfloat v0)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform1f(ctx, program, location, v0);
+}
+
+void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform2f(ctx, program, location, v0, v1);
+}
+
+void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform3f(ctx, program, location, v0, v1, v2);
+}
+
+void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform4f(ctx, program, location, v0, v1, v2, v3);
+}
+
+void glProgramUniform1i(GLuint program, GLint location, GLint v0)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform1i(ctx, program, location, v0);
+}
+
+void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform2i(ctx, program, location, v0, v1);
+}
+
+void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform3i(ctx, program, location, v0, v1, v2);
+}
+
+void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform4i(ctx, program, location, v0, v1, v2, v3);
+}
+
+void glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform1ui(ctx, program, location, v0);
+}
+
+void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform2ui(ctx, program, location, v0, v1);
+}
+
+void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform3ui(ctx, program, location, v0, v1, v2);
+}
+
+void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform4ui(ctx, program, location, v0, v1, v2, v3);
+}
+
+void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform1fv(ctx, program, location, count, value);
+}
+
+void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform2fv(ctx, program, location, count, value);
+}
+
+void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform3fv(ctx, program, location, count, value);
+}
+
+void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform4fv(ctx, program, location, count, value);
+}
+
+void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform1iv(ctx, program, location, count, value);
+}
+
+void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform2iv(ctx, program, location, count, value);
+}
+
+void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform3iv(ctx, program, location, count, value);
+}
+
+void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform4iv(ctx, program, location, count, value);
+}
+
+void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform1uiv(ctx, program, location, count, value);
+}
+
+void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform2uiv(ctx, program, location, count, value);
+}
+
+void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform3uiv(ctx, program, location, count, value);
+}
+
+void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniform4uiv(ctx, program, location, count, value);
+}
+
+void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix2fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix3fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix4fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix2x3fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix3x2fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix2x4fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix4x2fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix3x4fv(ctx, program, location, count, transpose, value);
+}
+
+void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
+{
+	GET_CONTEXT;
+	ctx->glProgramUniformMatrix4x3fv(ctx, program, location, count, transpose, value);
+}
+
+void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetProgramInterfaceiv(ctx, program, programInterface, pname, params);
+}
+
+void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetProgramResourceiv(ctx, program, programInterface, index, propCount, props, bufSize, length, params);
+}
+
+GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char* name)
+{
+	GET_CONTEXT;
+	return ctx->glGetProgramResourceIndex(ctx, program, programInterface, name);
+}
+
+GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char* name)
+{
+	GET_CONTEXT;
+	return ctx->glGetProgramResourceLocation(ctx, program, programInterface, name);
+}
+
+void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name)
+{
+	GET_CONTEXT;
+	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
+	ctx->glGetProgramResourceName(ctx, program, programInterface, index, bufSize, length, name);
+}
+
+void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
+{
+	GET_CONTEXT;
+	ctx->glBindImageTexture(ctx, unit, texture, level, layered, layer, access, format);
+}
+
+void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
+{
+	GET_CONTEXT;
+	ctx->glDispatchCompute(ctx, num_groups_x, num_groups_y, num_groups_z);
+}
+
+void glDispatchComputeIndirect(GLintptr indirect)
+{
+	GET_CONTEXT;
+	ctx->glDispatchComputeIndirect(ctx, indirect);
+}
+
+void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride)
+{
+	GET_CONTEXT;
+	ctx->glBindVertexBuffer(ctx, bindingindex, buffer, offset, stride);
+}
+
+void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribBinding(ctx, attribindex, bindingindex);
+}
+
+void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribFormat(ctx, attribindex, size, type, normalized, relativeoffset);
+}
+
+void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
+{
+	GET_CONTEXT;
+	ctx->glVertexAttribIFormat(ctx, attribindex, size, type, relativeoffset);
+}
+
+void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
+{
+	GET_CONTEXT;
+	ctx->glVertexBindingDivisor(ctx, bindingindex, divisor);
+}
+
+void glDrawArraysIndirect(GLenum mode, const void* indirect)
+{
+	GET_CONTEXT;
+	ctx->glDrawArraysIndirect(ctx, mode, indirect);
+}
+
+void glDrawArraysIndirectDataAEMU(GLenum mode, const void* indirect, GLuint datalen)
+{
+	GET_CONTEXT;
+	ctx->glDrawArraysIndirectDataAEMU(ctx, mode, indirect, datalen);
+}
+
+void glDrawArraysIndirectOffsetAEMU(GLenum mode, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glDrawArraysIndirectOffsetAEMU(ctx, mode, offset);
+}
+
+void glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect)
+{
+	GET_CONTEXT;
+	ctx->glDrawElementsIndirect(ctx, mode, type, indirect);
+}
+
+void glDrawElementsIndirectDataAEMU(GLenum mode, GLenum type, const void* indirect, GLuint datalen)
+{
+	GET_CONTEXT;
+	ctx->glDrawElementsIndirectDataAEMU(ctx, mode, type, indirect, datalen);
+}
+
+void glDrawElementsIndirectOffsetAEMU(GLenum mode, GLenum type, GLuint offset)
+{
+	GET_CONTEXT;
+	ctx->glDrawElementsIndirectOffsetAEMU(ctx, mode, type, offset);
+}
+
+void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
+{
+	GET_CONTEXT;
+	ctx->glTexStorage2DMultisample(ctx, target, samples, internalformat, width, height, fixedsamplelocations);
+}
+
+void glSampleMaski(GLuint maskNumber, GLbitfield mask)
+{
+	GET_CONTEXT;
+	ctx->glSampleMaski(ctx, maskNumber, mask);
+}
+
+void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val)
+{
+	GET_CONTEXT;
+	ctx->glGetMultisamplefv(ctx, pname, index, val);
+}
+
+void glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
+{
+	GET_CONTEXT;
+	ctx->glFramebufferParameteri(ctx, target, pname, param);
+}
+
+void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetFramebufferParameteriv(ctx, target, pname, params);
+}
+
+void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params)
+{
+	GET_CONTEXT;
+	ctx->glGetTexLevelParameterfv(ctx, target, level, pname, params);
+}
+
+void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params)
+{
+	GET_CONTEXT;
+	ctx->glGetTexLevelParameteriv(ctx, target, level, pname, params);
+}
+
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_ftable.h b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_ftable.h
index 25df4f0..99fe978 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_ftable.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_ftable.h
@@ -209,6 +209,178 @@ static const struct _gl2_funcs_by_name {
 	{"glExtGetProgramBinarySourceQCOM", (void*)glExtGetProgramBinarySourceQCOM},
 	{"glStartTilingQCOM", (void*)glStartTilingQCOM},
 	{"glEndTilingQCOM", (void*)glEndTilingQCOM},
+	{"glGenVertexArrays", (void*)glGenVertexArrays},
+	{"glBindVertexArray", (void*)glBindVertexArray},
+	{"glDeleteVertexArrays", (void*)glDeleteVertexArrays},
+	{"glIsVertexArray", (void*)glIsVertexArray},
+	{"glMapBufferRange", (void*)glMapBufferRange},
+	{"glUnmapBuffer", (void*)glUnmapBuffer},
+	{"glFlushMappedBufferRange", (void*)glFlushMappedBufferRange},
+	{"glBindBufferRange", (void*)glBindBufferRange},
+	{"glBindBufferBase", (void*)glBindBufferBase},
+	{"glCopyBufferSubData", (void*)glCopyBufferSubData},
+	{"glClearBufferiv", (void*)glClearBufferiv},
+	{"glClearBufferuiv", (void*)glClearBufferuiv},
+	{"glClearBufferfv", (void*)glClearBufferfv},
+	{"glClearBufferfi", (void*)glClearBufferfi},
+	{"glGetBufferParameteri64v", (void*)glGetBufferParameteri64v},
+	{"glGetBufferPointerv", (void*)glGetBufferPointerv},
+	{"glUniformBlockBinding", (void*)glUniformBlockBinding},
+	{"glGetUniformBlockIndex", (void*)glGetUniformBlockIndex},
+	{"glGetUniformIndices", (void*)glGetUniformIndices},
+	{"glGetActiveUniformBlockiv", (void*)glGetActiveUniformBlockiv},
+	{"glGetActiveUniformBlockName", (void*)glGetActiveUniformBlockName},
+	{"glUniform1ui", (void*)glUniform1ui},
+	{"glUniform2ui", (void*)glUniform2ui},
+	{"glUniform3ui", (void*)glUniform3ui},
+	{"glUniform4ui", (void*)glUniform4ui},
+	{"glUniform1uiv", (void*)glUniform1uiv},
+	{"glUniform2uiv", (void*)glUniform2uiv},
+	{"glUniform3uiv", (void*)glUniform3uiv},
+	{"glUniform4uiv", (void*)glUniform4uiv},
+	{"glUniformMatrix2x3fv", (void*)glUniformMatrix2x3fv},
+	{"glUniformMatrix3x2fv", (void*)glUniformMatrix3x2fv},
+	{"glUniformMatrix2x4fv", (void*)glUniformMatrix2x4fv},
+	{"glUniformMatrix4x2fv", (void*)glUniformMatrix4x2fv},
+	{"glUniformMatrix3x4fv", (void*)glUniformMatrix3x4fv},
+	{"glUniformMatrix4x3fv", (void*)glUniformMatrix4x3fv},
+	{"glGetUniformuiv", (void*)glGetUniformuiv},
+	{"glGetActiveUniformsiv", (void*)glGetActiveUniformsiv},
+	{"glVertexAttribI4i", (void*)glVertexAttribI4i},
+	{"glVertexAttribI4ui", (void*)glVertexAttribI4ui},
+	{"glVertexAttribI4iv", (void*)glVertexAttribI4iv},
+	{"glVertexAttribI4uiv", (void*)glVertexAttribI4uiv},
+	{"glVertexAttribIPointer", (void*)glVertexAttribIPointer},
+	{"glGetVertexAttribIiv", (void*)glGetVertexAttribIiv},
+	{"glGetVertexAttribIuiv", (void*)glGetVertexAttribIuiv},
+	{"glVertexAttribDivisor", (void*)glVertexAttribDivisor},
+	{"glDrawArraysInstanced", (void*)glDrawArraysInstanced},
+	{"glDrawElementsInstanced", (void*)glDrawElementsInstanced},
+	{"glDrawRangeElements", (void*)glDrawRangeElements},
+	{"glFenceSync", (void*)glFenceSync},
+	{"glClientWaitSync", (void*)glClientWaitSync},
+	{"glWaitSync", (void*)glWaitSync},
+	{"glDeleteSync", (void*)glDeleteSync},
+	{"glIsSync", (void*)glIsSync},
+	{"glGetSynciv", (void*)glGetSynciv},
+	{"glDrawBuffers", (void*)glDrawBuffers},
+	{"glReadBuffer", (void*)glReadBuffer},
+	{"glBlitFramebuffer", (void*)glBlitFramebuffer},
+	{"glInvalidateFramebuffer", (void*)glInvalidateFramebuffer},
+	{"glInvalidateSubFramebuffer", (void*)glInvalidateSubFramebuffer},
+	{"glFramebufferTextureLayer", (void*)glFramebufferTextureLayer},
+	{"glRenderbufferStorageMultisample", (void*)glRenderbufferStorageMultisample},
+	{"glTexStorage2D", (void*)glTexStorage2D},
+	{"glGetInternalformativ", (void*)glGetInternalformativ},
+	{"glBeginTransformFeedback", (void*)glBeginTransformFeedback},
+	{"glEndTransformFeedback", (void*)glEndTransformFeedback},
+	{"glGenTransformFeedbacks", (void*)glGenTransformFeedbacks},
+	{"glDeleteTransformFeedbacks", (void*)glDeleteTransformFeedbacks},
+	{"glBindTransformFeedback", (void*)glBindTransformFeedback},
+	{"glPauseTransformFeedback", (void*)glPauseTransformFeedback},
+	{"glResumeTransformFeedback", (void*)glResumeTransformFeedback},
+	{"glIsTransformFeedback", (void*)glIsTransformFeedback},
+	{"glTransformFeedbackVaryings", (void*)glTransformFeedbackVaryings},
+	{"glGetTransformFeedbackVarying", (void*)glGetTransformFeedbackVarying},
+	{"glGenSamplers", (void*)glGenSamplers},
+	{"glDeleteSamplers", (void*)glDeleteSamplers},
+	{"glBindSampler", (void*)glBindSampler},
+	{"glSamplerParameterf", (void*)glSamplerParameterf},
+	{"glSamplerParameteri", (void*)glSamplerParameteri},
+	{"glSamplerParameterfv", (void*)glSamplerParameterfv},
+	{"glSamplerParameteriv", (void*)glSamplerParameteriv},
+	{"glGetSamplerParameterfv", (void*)glGetSamplerParameterfv},
+	{"glGetSamplerParameteriv", (void*)glGetSamplerParameteriv},
+	{"glIsSampler", (void*)glIsSampler},
+	{"glGenQueries", (void*)glGenQueries},
+	{"glDeleteQueries", (void*)glDeleteQueries},
+	{"glBeginQuery", (void*)glBeginQuery},
+	{"glEndQuery", (void*)glEndQuery},
+	{"glGetQueryiv", (void*)glGetQueryiv},
+	{"glGetQueryObjectuiv", (void*)glGetQueryObjectuiv},
+	{"glIsQuery", (void*)glIsQuery},
+	{"glProgramParameteri", (void*)glProgramParameteri},
+	{"glProgramBinary", (void*)glProgramBinary},
+	{"glGetProgramBinary", (void*)glGetProgramBinary},
+	{"glGetFragDataLocation", (void*)glGetFragDataLocation},
+	{"glGetInteger64v", (void*)glGetInteger64v},
+	{"glGetIntegeri_v", (void*)glGetIntegeri_v},
+	{"glGetInteger64i_v", (void*)glGetInteger64i_v},
+	{"glTexImage3D", (void*)glTexImage3D},
+	{"glTexStorage3D", (void*)glTexStorage3D},
+	{"glTexSubImage3D", (void*)glTexSubImage3D},
+	{"glCompressedTexImage3D", (void*)glCompressedTexImage3D},
+	{"glCompressedTexSubImage3D", (void*)glCompressedTexSubImage3D},
+	{"glCopyTexSubImage3D", (void*)glCopyTexSubImage3D},
+	{"glGetStringi", (void*)glGetStringi},
+	{"glGetBooleani_v", (void*)glGetBooleani_v},
+	{"glMemoryBarrier", (void*)glMemoryBarrier},
+	{"glMemoryBarrierByRegion", (void*)glMemoryBarrierByRegion},
+	{"glGenProgramPipelines", (void*)glGenProgramPipelines},
+	{"glDeleteProgramPipelines", (void*)glDeleteProgramPipelines},
+	{"glBindProgramPipeline", (void*)glBindProgramPipeline},
+	{"glGetProgramPipelineiv", (void*)glGetProgramPipelineiv},
+	{"glGetProgramPipelineInfoLog", (void*)glGetProgramPipelineInfoLog},
+	{"glValidateProgramPipeline", (void*)glValidateProgramPipeline},
+	{"glIsProgramPipeline", (void*)glIsProgramPipeline},
+	{"glUseProgramStages", (void*)glUseProgramStages},
+	{"glActiveShaderProgram", (void*)glActiveShaderProgram},
+	{"glCreateShaderProgramv", (void*)glCreateShaderProgramv},
+	{"glProgramUniform1f", (void*)glProgramUniform1f},
+	{"glProgramUniform2f", (void*)glProgramUniform2f},
+	{"glProgramUniform3f", (void*)glProgramUniform3f},
+	{"glProgramUniform4f", (void*)glProgramUniform4f},
+	{"glProgramUniform1i", (void*)glProgramUniform1i},
+	{"glProgramUniform2i", (void*)glProgramUniform2i},
+	{"glProgramUniform3i", (void*)glProgramUniform3i},
+	{"glProgramUniform4i", (void*)glProgramUniform4i},
+	{"glProgramUniform1ui", (void*)glProgramUniform1ui},
+	{"glProgramUniform2ui", (void*)glProgramUniform2ui},
+	{"glProgramUniform3ui", (void*)glProgramUniform3ui},
+	{"glProgramUniform4ui", (void*)glProgramUniform4ui},
+	{"glProgramUniform1fv", (void*)glProgramUniform1fv},
+	{"glProgramUniform2fv", (void*)glProgramUniform2fv},
+	{"glProgramUniform3fv", (void*)glProgramUniform3fv},
+	{"glProgramUniform4fv", (void*)glProgramUniform4fv},
+	{"glProgramUniform1iv", (void*)glProgramUniform1iv},
+	{"glProgramUniform2iv", (void*)glProgramUniform2iv},
+	{"glProgramUniform3iv", (void*)glProgramUniform3iv},
+	{"glProgramUniform4iv", (void*)glProgramUniform4iv},
+	{"glProgramUniform1uiv", (void*)glProgramUniform1uiv},
+	{"glProgramUniform2uiv", (void*)glProgramUniform2uiv},
+	{"glProgramUniform3uiv", (void*)glProgramUniform3uiv},
+	{"glProgramUniform4uiv", (void*)glProgramUniform4uiv},
+	{"glProgramUniformMatrix2fv", (void*)glProgramUniformMatrix2fv},
+	{"glProgramUniformMatrix3fv", (void*)glProgramUniformMatrix3fv},
+	{"glProgramUniformMatrix4fv", (void*)glProgramUniformMatrix4fv},
+	{"glProgramUniformMatrix2x3fv", (void*)glProgramUniformMatrix2x3fv},
+	{"glProgramUniformMatrix3x2fv", (void*)glProgramUniformMatrix3x2fv},
+	{"glProgramUniformMatrix2x4fv", (void*)glProgramUniformMatrix2x4fv},
+	{"glProgramUniformMatrix4x2fv", (void*)glProgramUniformMatrix4x2fv},
+	{"glProgramUniformMatrix3x4fv", (void*)glProgramUniformMatrix3x4fv},
+	{"glProgramUniformMatrix4x3fv", (void*)glProgramUniformMatrix4x3fv},
+	{"glGetProgramInterfaceiv", (void*)glGetProgramInterfaceiv},
+	{"glGetProgramResourceiv", (void*)glGetProgramResourceiv},
+	{"glGetProgramResourceIndex", (void*)glGetProgramResourceIndex},
+	{"glGetProgramResourceLocation", (void*)glGetProgramResourceLocation},
+	{"glGetProgramResourceName", (void*)glGetProgramResourceName},
+	{"glBindImageTexture", (void*)glBindImageTexture},
+	{"glDispatchCompute", (void*)glDispatchCompute},
+	{"glDispatchComputeIndirect", (void*)glDispatchComputeIndirect},
+	{"glBindVertexBuffer", (void*)glBindVertexBuffer},
+	{"glVertexAttribBinding", (void*)glVertexAttribBinding},
+	{"glVertexAttribFormat", (void*)glVertexAttribFormat},
+	{"glVertexAttribIFormat", (void*)glVertexAttribIFormat},
+	{"glVertexBindingDivisor", (void*)glVertexBindingDivisor},
+	{"glDrawArraysIndirect", (void*)glDrawArraysIndirect},
+	{"glDrawElementsIndirect", (void*)glDrawElementsIndirect},
+	{"glTexStorage2DMultisample", (void*)glTexStorage2DMultisample},
+	{"glSampleMaski", (void*)glSampleMaski},
+	{"glGetMultisamplefv", (void*)glGetMultisamplefv},
+	{"glFramebufferParameteri", (void*)glFramebufferParameteri},
+	{"glGetFramebufferParameteriv", (void*)glGetFramebufferParameteriv},
+	{"glGetTexLevelParameterfv", (void*)glGetTexLevelParameterfv},
+	{"glGetTexLevelParameteriv", (void*)glGetTexLevelParameteriv},
 };
 static const int gl2_num_funcs = sizeof(gl2_funcs_by_name) / sizeof(struct _gl2_funcs_by_name);
 
diff --git a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_opcodes.h b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_opcodes.h
index 5e7857f..497ebfb 100644
--- a/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_opcodes.h
+++ b/vendor/anbox/android/opengl/system/GLESv2_enc/gl2_opcodes.h
@@ -211,7 +211,210 @@
 #define OP_glGetCompressedTextureFormats 					2253
 #define OP_glShaderString 					2254
 #define OP_glFinishRoundTrip 					2255
-#define OP_last 					2256
+#define OP_glGenVertexArrays 					2256
+#define OP_glBindVertexArray 					2257
+#define OP_glDeleteVertexArrays 					2258
+#define OP_glIsVertexArray 					2259
+#define OP_glMapBufferRange 					2260
+#define OP_glUnmapBuffer 					2261
+#define OP_glFlushMappedBufferRange 					2262
+#define OP_glMapBufferRangeAEMU 					2263
+#define OP_glUnmapBufferAEMU 					2264
+#define OP_glFlushMappedBufferRangeAEMU 					2265
+#define OP_glReadPixelsOffsetAEMU 					2266
+#define OP_glCompressedTexImage2DOffsetAEMU 					2267
+#define OP_glCompressedTexSubImage2DOffsetAEMU 					2268
+#define OP_glTexImage2DOffsetAEMU 					2269
+#define OP_glTexSubImage2DOffsetAEMU 					2270
+#define OP_glBindBufferRange 					2271
+#define OP_glBindBufferBase 					2272
+#define OP_glCopyBufferSubData 					2273
+#define OP_glClearBufferiv 					2274
+#define OP_glClearBufferuiv 					2275
+#define OP_glClearBufferfv 					2276
+#define OP_glClearBufferfi 					2277
+#define OP_glGetBufferParameteri64v 					2278
+#define OP_glGetBufferPointerv 					2279
+#define OP_glUniformBlockBinding 					2280
+#define OP_glGetUniformBlockIndex 					2281
+#define OP_glGetUniformIndices 					2282
+#define OP_glGetUniformIndicesAEMU 					2283
+#define OP_glGetActiveUniformBlockiv 					2284
+#define OP_glGetActiveUniformBlockName 					2285
+#define OP_glUniform1ui 					2286
+#define OP_glUniform2ui 					2287
+#define OP_glUniform3ui 					2288
+#define OP_glUniform4ui 					2289
+#define OP_glUniform1uiv 					2290
+#define OP_glUniform2uiv 					2291
+#define OP_glUniform3uiv 					2292
+#define OP_glUniform4uiv 					2293
+#define OP_glUniformMatrix2x3fv 					2294
+#define OP_glUniformMatrix3x2fv 					2295
+#define OP_glUniformMatrix2x4fv 					2296
+#define OP_glUniformMatrix4x2fv 					2297
+#define OP_glUniformMatrix3x4fv 					2298
+#define OP_glUniformMatrix4x3fv 					2299
+#define OP_glGetUniformuiv 					2300
+#define OP_glGetActiveUniformsiv 					2301
+#define OP_glVertexAttribI4i 					2302
+#define OP_glVertexAttribI4ui 					2303
+#define OP_glVertexAttribI4iv 					2304
+#define OP_glVertexAttribI4uiv 					2305
+#define OP_glVertexAttribIPointer 					2306
+#define OP_glVertexAttribIPointerOffsetAEMU 					2307
+#define OP_glVertexAttribIPointerDataAEMU 					2308
+#define OP_glGetVertexAttribIiv 					2309
+#define OP_glGetVertexAttribIuiv 					2310
+#define OP_glVertexAttribDivisor 					2311
+#define OP_glDrawArraysInstanced 					2312
+#define OP_glDrawElementsInstanced 					2313
+#define OP_glDrawElementsInstancedDataAEMU 					2314
+#define OP_glDrawElementsInstancedOffsetAEMU 					2315
+#define OP_glDrawRangeElements 					2316
+#define OP_glDrawRangeElementsDataAEMU 					2317
+#define OP_glDrawRangeElementsOffsetAEMU 					2318
+#define OP_glFenceSync 					2319
+#define OP_glClientWaitSync 					2320
+#define OP_glWaitSync 					2321
+#define OP_glDeleteSync 					2322
+#define OP_glIsSync 					2323
+#define OP_glGetSynciv 					2324
+#define OP_glFenceSyncAEMU 					2325
+#define OP_glClientWaitSyncAEMU 					2326
+#define OP_glWaitSyncAEMU 					2327
+#define OP_glDeleteSyncAEMU 					2328
+#define OP_glIsSyncAEMU 					2329
+#define OP_glGetSyncivAEMU 					2330
+#define OP_glDrawBuffers 					2331
+#define OP_glReadBuffer 					2332
+#define OP_glBlitFramebuffer 					2333
+#define OP_glInvalidateFramebuffer 					2334
+#define OP_glInvalidateSubFramebuffer 					2335
+#define OP_glFramebufferTextureLayer 					2336
+#define OP_glRenderbufferStorageMultisample 					2337
+#define OP_glTexStorage2D 					2338
+#define OP_glGetInternalformativ 					2339
+#define OP_glBeginTransformFeedback 					2340
+#define OP_glEndTransformFeedback 					2341
+#define OP_glGenTransformFeedbacks 					2342
+#define OP_glDeleteTransformFeedbacks 					2343
+#define OP_glBindTransformFeedback 					2344
+#define OP_glPauseTransformFeedback 					2345
+#define OP_glResumeTransformFeedback 					2346
+#define OP_glIsTransformFeedback 					2347
+#define OP_glTransformFeedbackVaryings 					2348
+#define OP_glTransformFeedbackVaryingsAEMU 					2349
+#define OP_glGetTransformFeedbackVarying 					2350
+#define OP_glGenSamplers 					2351
+#define OP_glDeleteSamplers 					2352
+#define OP_glBindSampler 					2353
+#define OP_glSamplerParameterf 					2354
+#define OP_glSamplerParameteri 					2355
+#define OP_glSamplerParameterfv 					2356
+#define OP_glSamplerParameteriv 					2357
+#define OP_glGetSamplerParameterfv 					2358
+#define OP_glGetSamplerParameteriv 					2359
+#define OP_glIsSampler 					2360
+#define OP_glGenQueries 					2361
+#define OP_glDeleteQueries 					2362
+#define OP_glBeginQuery 					2363
+#define OP_glEndQuery 					2364
+#define OP_glGetQueryiv 					2365
+#define OP_glGetQueryObjectuiv 					2366
+#define OP_glIsQuery 					2367
+#define OP_glProgramParameteri 					2368
+#define OP_glProgramBinary 					2369
+#define OP_glGetProgramBinary 					2370
+#define OP_glGetFragDataLocation 					2371
+#define OP_glGetInteger64v 					2372
+#define OP_glGetIntegeri_v 					2373
+#define OP_glGetInteger64i_v 					2374
+#define OP_glTexImage3D 					2375
+#define OP_glTexImage3DOffsetAEMU 					2376
+#define OP_glTexStorage3D 					2377
+#define OP_glTexSubImage3D 					2378
+#define OP_glTexSubImage3DOffsetAEMU 					2379
+#define OP_glCompressedTexImage3D 					2380
+#define OP_glCompressedTexImage3DOffsetAEMU 					2381
+#define OP_glCompressedTexSubImage3D 					2382
+#define OP_glCompressedTexSubImage3DOffsetAEMU 					2383
+#define OP_glCopyTexSubImage3D 					2384
+#define OP_glGetStringi 					2385
+#define OP_glGetBooleani_v 					2386
+#define OP_glMemoryBarrier 					2387
+#define OP_glMemoryBarrierByRegion 					2388
+#define OP_glGenProgramPipelines 					2389
+#define OP_glDeleteProgramPipelines 					2390
+#define OP_glBindProgramPipeline 					2391
+#define OP_glGetProgramPipelineiv 					2392
+#define OP_glGetProgramPipelineInfoLog 					2393
+#define OP_glValidateProgramPipeline 					2394
+#define OP_glIsProgramPipeline 					2395
+#define OP_glUseProgramStages 					2396
+#define OP_glActiveShaderProgram 					2397
+#define OP_glCreateShaderProgramv 					2398
+#define OP_glCreateShaderProgramvAEMU 					2399
+#define OP_glProgramUniform1f 					2400
+#define OP_glProgramUniform2f 					2401
+#define OP_glProgramUniform3f 					2402
+#define OP_glProgramUniform4f 					2403
+#define OP_glProgramUniform1i 					2404
+#define OP_glProgramUniform2i 					2405
+#define OP_glProgramUniform3i 					2406
+#define OP_glProgramUniform4i 					2407
+#define OP_glProgramUniform1ui 					2408
+#define OP_glProgramUniform2ui 					2409
+#define OP_glProgramUniform3ui 					2410
+#define OP_glProgramUniform4ui 					2411
+#define OP_glProgramUniform1fv 					2412
+#define OP_glProgramUniform2fv 					2413
+#define OP_glProgramUniform3fv 					2414
+#define OP_glProgramUniform4fv 					2415
+#define OP_glProgramUniform1iv 					2416
+#define OP_glProgramUniform2iv 					2417
+#define OP_glProgramUniform3iv 					2418
+#define OP_glProgramUniform4iv 					2419
+#define OP_glProgramUniform1uiv 					2420
+#define OP_glProgramUniform2uiv 					2421
+#define OP_glProgramUniform3uiv 					2422
+#define OP_glProgramUniform4uiv 					2423
+#define OP_glProgramUniformMatrix2fv 					2424
+#define OP_glProgramUniformMatrix3fv 					2425
+#define OP_glProgramUniformMatrix4fv 					2426
+#define OP_glProgramUniformMatrix2x3fv 					2427
+#define OP_glProgramUniformMatrix3x2fv 					2428
+#define OP_glProgramUniformMatrix2x4fv 					2429
+#define OP_glProgramUniformMatrix4x2fv 					2430
+#define OP_glProgramUniformMatrix3x4fv 					2431
+#define OP_glProgramUniformMatrix4x3fv 					2432
+#define OP_glGetProgramInterfaceiv 					2433
+#define OP_glGetProgramResourceiv 					2434
+#define OP_glGetProgramResourceIndex 					2435
+#define OP_glGetProgramResourceLocation 					2436
+#define OP_glGetProgramResourceName 					2437
+#define OP_glBindImageTexture 					2438
+#define OP_glDispatchCompute 					2439
+#define OP_glDispatchComputeIndirect 					2440
+#define OP_glBindVertexBuffer 					2441
+#define OP_glVertexAttribBinding 					2442
+#define OP_glVertexAttribFormat 					2443
+#define OP_glVertexAttribIFormat 					2444
+#define OP_glVertexBindingDivisor 					2445
+#define OP_glDrawArraysIndirect 					2446
+#define OP_glDrawArraysIndirectDataAEMU 					2447
+#define OP_glDrawArraysIndirectOffsetAEMU 					2448
+#define OP_glDrawElementsIndirect 					2449
+#define OP_glDrawElementsIndirectDataAEMU 					2450
+#define OP_glDrawElementsIndirectOffsetAEMU 					2451
+#define OP_glTexStorage2DMultisample 					2452
+#define OP_glSampleMaski 					2453
+#define OP_glGetMultisamplefv 					2454
+#define OP_glFramebufferParameteri 					2455
+#define OP_glGetFramebufferParameteriv 					2456
+#define OP_glGetTexLevelParameterfv 					2457
+#define OP_glGetTexLevelParameteriv 					2458
+#define OP_last 					2459
 
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLClientIface.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLClientIface.h
index 3c8cb55..35b66bf 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLClientIface.h
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLClientIface.h
@@ -28,6 +28,7 @@ typedef struct {
     void* (*getProcAddress)(const char *funcName);
     void (*init)();
     void (*finish)();
+    void (*getIntegerv)(unsigned int pname, int* param);
 } EGLClient_glesInterface;
 
 //
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLImage.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLImage.h
index 5edb44e..07148e9 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLImage.h
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/EGLImage.h
@@ -19,6 +19,7 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 #include <GLES/gl.h>
+
 #include <system/window.h>
 
 struct EGLImage_t
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/FormatConversions.cpp b/vendor/anbox/android/opengl/system/OpenglSystemCommon/FormatConversions.cpp
new file mode 100644
index 0000000..8213602
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/FormatConversions.cpp
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "FormatConversions.h"
+
+#include <cutils/log.h>
+#include <string.h>
+
+#define DEBUG 0
+
+#if DEBUG
+#define DD(...) ALOGD(...)
+#else
+#define DD(...)
+#endif
+
+void get_yv12_offsets(int width, int height,
+                             uint32_t* yStride_out,
+                             uint32_t* cStride_out,
+                             uint32_t* totalSz_out) {
+    uint32_t align = 16;
+    uint32_t yStride = (width + (align - 1)) & ~(align-1);
+    uint32_t uvStride = (yStride / 2 + (align - 1)) & ~(align-1);
+    uint32_t uvHeight = height / 2;
+    uint32_t sz = yStride * height + 2 * (uvHeight * uvStride);
+
+    if (yStride_out) *yStride_out = yStride;
+    if (cStride_out) *cStride_out = uvStride;
+    if (totalSz_out) *totalSz_out = sz;
+}
+
+void get_yuv420p_offsets(int width, int height,
+                                uint32_t* yStride_out,
+                                uint32_t* cStride_out,
+                                uint32_t* totalSz_out) {
+    uint32_t align = 1;
+    uint32_t yStride = (width + (align - 1)) & ~(align-1);
+    uint32_t uvStride = (yStride / 2 + (align - 1)) & ~(align-1);
+    uint32_t uvHeight = height / 2;
+    uint32_t sz = yStride * height + 2 * (uvHeight * uvStride);
+
+    if (yStride_out) *yStride_out = yStride;
+    if (cStride_out) *cStride_out = uvStride;
+    if (totalSz_out) *totalSz_out = sz;
+}
+
+signed clamp_rgb(signed value) {
+    if (value > 255) {
+        value = 255;
+    } else if (value < 0) {
+        value = 0;
+    }
+    return value;
+}
+
+void rgb565_to_yv12(char* dest, char* src, int width, int height,
+        int left, int top, int right, int bottom) {
+    int align = 16;
+    int yStride = (width + (align -1)) & ~(align-1);
+    int cStride = (yStride / 2 + (align - 1)) & ~(align-1);
+    int yOffset = 0;
+    int cSize = cStride * height/2;
+
+    uint16_t *rgb_ptr0 = (uint16_t *)src;
+    uint8_t *yv12_y0 = (uint8_t *)dest;
+    uint8_t *yv12_v0 = yv12_y0 + yStride * height;
+    uint8_t *yv12_u0 = yv12_v0 + cSize;
+
+    for (int j = top; j <= bottom; ++j) {
+        uint8_t *yv12_y = yv12_y0 + j * yStride;
+        uint8_t *yv12_v = yv12_v0 + (j/2) * cStride;
+        uint8_t *yv12_u = yv12_v + cSize;
+        uint16_t *rgb_ptr = rgb_ptr0 + j * width;
+        bool jeven = (j & 1) == 0;
+        for (int i = left; i <= right; ++i) {
+            uint8_t r = ((rgb_ptr[i]) >> 11) & 0x01f;
+            uint8_t g = ((rgb_ptr[i]) >> 5) & 0x03f;
+            uint8_t b = (rgb_ptr[i]) & 0x01f;
+            // convert to 8bits
+            // http://stackoverflow.com/questions/2442576/how-does-one-convert-16-bit-rgb565-to-24-bit-rgb888
+            uint8_t R = (r * 527 + 23) >> 6;
+            uint8_t G = (g * 259 + 33) >> 6;
+            uint8_t B = (b * 527 + 23) >> 6;
+            // convert to YV12
+            // frameworks/base/core/jni/android_hardware_camera2_legacy_LegacyCameraDevice.cpp
+            yv12_y[i] = clamp_rgb((77 * R + 150 * G +  29 * B) >> 8);
+            bool ieven = (i & 1) == 0;
+            if (jeven && ieven) {
+                yv12_u[i] = clamp_rgb((( -43 * R - 85 * G + 128 * B) >> 8) + 128);
+                yv12_v[i] = clamp_rgb((( 128 * R - 107 * G - 21 * B) >> 8) + 128);
+            }
+        }
+    }
+}
+
+void rgb888_to_yv12(char* dest, char* src, int width, int height,
+        int left, int top, int right, int bottom) {
+    DD("%s convert %d by %d", __func__, width, height);
+    int align = 16;
+    int yStride = (width + (align -1)) & ~(align-1);
+    int cStride = (yStride / 2 + (align - 1)) & ~(align-1);
+    int yOffset = 0;
+    int cSize = cStride * height/2;
+    int rgb_stride = 3;
+
+    uint8_t *rgb_ptr0 = (uint8_t *)src;
+    uint8_t *yv12_y0 = (uint8_t *)dest;
+    uint8_t *yv12_v0 = yv12_y0 + yStride * height;
+    uint8_t *yv12_u0 = yv12_v0 + cSize;
+
+    for (int j = top; j <= bottom; ++j) {
+        uint8_t *yv12_y = yv12_y0 + j * yStride;
+        uint8_t *yv12_v = yv12_v0 + (j/2) * cStride;
+        uint8_t *yv12_u = yv12_v + cSize;
+        uint8_t  *rgb_ptr = rgb_ptr0 + j * width*rgb_stride;
+        bool jeven = (j & 1) == 0;
+        for (int i = left; i <= right; ++i) {
+            uint8_t R = rgb_ptr[i*rgb_stride];
+            uint8_t G = rgb_ptr[i*rgb_stride+1];
+            uint8_t B = rgb_ptr[i*rgb_stride+2];
+            // convert to YV12
+            // frameworks/base/core/jni/android_hardware_camera2_legacy_LegacyCameraDevice.cpp
+            yv12_y[i] = clamp_rgb((77 * R + 150 * G +  29 * B) >> 8);
+            bool ieven = (i & 1) == 0;
+            if (jeven && ieven) {
+                yv12_u[i] = clamp_rgb((( -43 * R - 85 * G + 128 * B) >> 8) + 128);
+                yv12_v[i] = clamp_rgb((( 128 * R - 107 * G - 21 * B) >> 8) + 128);
+            }
+        }
+    }
+}
+
+void rgb888_to_yuv420p(char* dest, char* src, int width, int height,
+        int left, int top, int right, int bottom) {
+    DD("%s convert %d by %d", __func__, width, height);
+    int yStride = width;
+    int cStride = yStride / 2;
+    int yOffset = 0;
+    int cSize = cStride * height/2;
+    int rgb_stride = 3;
+
+    uint8_t *rgb_ptr0 = (uint8_t *)src;
+    uint8_t *yv12_y0 = (uint8_t *)dest;
+    uint8_t *yv12_u0 = yv12_y0 + yStride * height;
+    uint8_t *yv12_v0 = yv12_u0 + cSize;
+
+    for (int j = top; j <= bottom; ++j) {
+        uint8_t *yv12_y = yv12_y0 + j * yStride;
+        uint8_t *yv12_u = yv12_u0 + (j/2) * cStride;
+        uint8_t *yv12_v = yv12_u + cStride;
+        uint8_t  *rgb_ptr = rgb_ptr0 + j * width*rgb_stride;
+        bool jeven = (j & 1) == 0;
+        for (int i = left; i <= right; ++i) {
+            uint8_t R = rgb_ptr[i*rgb_stride];
+            uint8_t G = rgb_ptr[i*rgb_stride+1];
+            uint8_t B = rgb_ptr[i*rgb_stride+2];
+            // convert to YV12
+            // frameworks/base/core/jni/android_hardware_camera2_legacy_LegacyCameraDevice.cpp
+            yv12_y[i] = clamp_rgb((77 * R + 150 * G +  29 * B) >> 8);
+            bool ieven = (i & 1) == 0;
+            if (jeven && ieven) {
+                yv12_u[i] = clamp_rgb((( -43 * R - 85 * G + 128 * B) >> 8) + 128);
+                yv12_v[i] = clamp_rgb((( 128 * R - 107 * G - 21 * B) >> 8) + 128);
+            }
+        }
+    }
+}
+// YV12 is aka YUV420Planar, or YUV420p; the only difference is that YV12 has
+// certain stride requirements for Y and UV respectively.
+void yv12_to_rgb565(char* dest, char* src, int width, int height,
+        int left, int top, int right, int bottom) {
+    DD("%s convert %d by %d", __func__, width, height);
+    int align = 16;
+    int yStride = (width + (align -1)) & ~(align-1);
+    int cStride = (yStride / 2 + (align - 1)) & ~(align-1);
+    int yOffset = 0;
+    int cSize = cStride * height/2;
+
+    uint16_t *rgb_ptr0 = (uint16_t *)dest;
+    uint8_t *yv12_y0 = (uint8_t *)src;
+    uint8_t *yv12_v0 = yv12_y0 + yStride * height;
+    uint8_t *yv12_u0 = yv12_v0 + cSize;
+
+    for (int j = top; j <= bottom; ++j) {
+        uint8_t *yv12_y = yv12_y0 + j * yStride;
+        uint8_t *yv12_v = yv12_v0 + (j/2) * cStride;
+        uint8_t *yv12_u = yv12_v + cSize;
+        uint16_t *rgb_ptr = rgb_ptr0 + (j-top) * (right-left+1);
+        for (int i = left; i <= right; ++i) {
+            // convert to rgb
+            // frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+            signed y1 = (signed)yv12_y[i] - 16;
+            signed u = (signed)yv12_u[i / 2] - 128;
+            signed v = (signed)yv12_v[i / 2] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = clamp_rgb((tmp1 + u_b) / 256);
+            signed g1 = clamp_rgb((tmp1 + v_g + u_g) / 256);
+            signed r1 = clamp_rgb((tmp1 + v_r) / 256);
+
+            uint16_t rgb1 = ((r1 >> 3) << 11) | ((g1 >> 2) << 5) | (b1 >> 3);
+
+            rgb_ptr[i-left] = rgb1;
+        }
+    }
+}
+
+// YV12 is aka YUV420Planar, or YUV420p; the only difference is that YV12 has
+// certain stride requirements for Y and UV respectively.
+void yv12_to_rgb888(char* dest, char* src, int width, int height,
+        int left, int top, int right, int bottom) {
+    DD("%s convert %d by %d", __func__, width, height);
+    int align = 16;
+    int yStride = (width + (align -1)) & ~(align-1);
+    int cStride = (yStride / 2 + (align - 1)) & ~(align-1);
+    int yOffset = 0;
+    int cSize = cStride * height/2;
+    int rgb_stride = 3;
+
+    uint8_t *rgb_ptr0 = (uint8_t *)dest;
+    uint8_t *yv12_y0 = (uint8_t *)src;
+    uint8_t *yv12_v0 = yv12_y0 + yStride * height;
+    uint8_t *yv12_u0 = yv12_v0 + cSize;
+
+    for (int j = top; j <= bottom; ++j) {
+        uint8_t *yv12_y = yv12_y0 + j * yStride;
+        uint8_t *yv12_v = yv12_v0 + (j/2) * cStride;
+        uint8_t *yv12_u = yv12_v + cSize;
+        uint8_t *rgb_ptr = rgb_ptr0 + (j-top) * (right-left+1) * rgb_stride;
+        for (int i = left; i <= right; ++i) {
+            // convert to rgb
+            // frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+            signed y1 = (signed)yv12_y[i] - 16;
+            signed u = (signed)yv12_u[i / 2] - 128;
+            signed v = (signed)yv12_v[i / 2] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = clamp_rgb((tmp1 + u_b) / 256);
+            signed g1 = clamp_rgb((tmp1 + v_g + u_g) / 256);
+            signed r1 = clamp_rgb((tmp1 + v_r) / 256);
+
+            rgb_ptr[(i-left)*rgb_stride] = r1;
+            rgb_ptr[(i-left)*rgb_stride+1] = g1;
+            rgb_ptr[(i-left)*rgb_stride+2] = b1;
+        }
+    }
+}
+
+// YV12 is aka YUV420Planar, or YUV420p; the only difference is that YV12 has
+// certain stride requirements for Y and UV respectively.
+void yuv420p_to_rgb888(char* dest, char* src, int width, int height,
+        int left, int top, int right, int bottom) {
+    DD("%s convert %d by %d", __func__, width, height);
+    int yStride = width;
+    int cStride = yStride / 2;
+    int yOffset = 0;
+    int cSize = cStride * height/2;
+    int rgb_stride = 3;
+
+    uint8_t *rgb_ptr0 = (uint8_t *)dest;
+    uint8_t *yv12_y0 = (uint8_t *)src;
+    uint8_t *yv12_u0 = yv12_y0 + yStride * height;
+    uint8_t *yv12_v0 = yv12_u0 + cSize;
+
+    for (int j = top; j <= bottom; ++j) {
+        uint8_t *yv12_y = yv12_y0 + j * yStride;
+        uint8_t *yv12_u = yv12_u0 + (j/2) * cStride;
+        uint8_t *yv12_v = yv12_u + cSize;
+        uint8_t *rgb_ptr = rgb_ptr0 + (j-top) * (right-left+1) * rgb_stride;
+        for (int i = left; i <= right; ++i) {
+            // convert to rgb
+            // frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+            signed y1 = (signed)yv12_y[i] - 16;
+            signed u = (signed)yv12_u[i / 2] - 128;
+            signed v = (signed)yv12_v[i / 2] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = clamp_rgb((tmp1 + u_b) / 256);
+            signed g1 = clamp_rgb((tmp1 + v_g + u_g) / 256);
+            signed r1 = clamp_rgb((tmp1 + v_r) / 256);
+
+            rgb_ptr[(i-left)*rgb_stride] = r1;
+            rgb_ptr[(i-left)*rgb_stride+1] = g1;
+            rgb_ptr[(i-left)*rgb_stride+2] = b1;
+        }
+    }
+}
+
+void copy_rgb_buffer_from_unlocked(
+        char* _dst, char* raw_data,
+        int unlockedWidth,
+        int width, int height, int top, int left,
+        int bpp) {
+    char* dst = _dst;
+    int dst_line_len = width * bpp;
+    int src_line_len = unlockedWidth * bpp;
+    char *src = (char *)raw_data + top*src_line_len + left*bpp;
+    for (int y = 0; y < height; y++) {
+        memcpy(dst, src, dst_line_len);
+        src += src_line_len;
+        dst += dst_line_len;
+    }
+}
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/FormatConversions.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/FormatConversions.h
new file mode 100644
index 0000000..6e15f36
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/FormatConversions.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __GOLDFISH_FORMATCONVERSIONS_H__
+#define __GOLDFISH_FORMATCONVERSIONS_H__
+
+#include <inttypes.h>
+
+// format conversions and helper functions
+void get_yv12_offsets(int width, int height,
+                      uint32_t* yStride_out,
+                      uint32_t* cStride_out,
+                      uint32_t* totalSz_out);
+void get_yuv420p_offsets(int width, int height,
+                         uint32_t* yStride_out,
+                         uint32_t* cStride_out,
+                         uint32_t* totalSz_out);
+signed clamp_rgb(signed value);
+void rgb565_to_yv12(char* dest, char* src, int width, int height,
+                    int left, int top, int right, int bottom);
+void rgb888_to_yv12(char* dest, char* src, int width, int height,
+                    int left, int top, int right, int bottom);
+void rgb888_to_yuv420p(char* dest, char* src, int width, int height,
+                       int left, int top, int right, int bottom);
+void yv12_to_rgb565(char* dest, char* src, int width, int height,
+                    int left, int top, int right, int bottom);
+void yv12_to_rgb888(char* dest, char* src, int width, int height,
+                    int left, int top, int right, int bottom);
+void yuv420p_to_rgb888(char* dest, char* src, int width, int height,
+                       int left, int top, int right, int bottom);
+void copy_rgb_buffer_from_unlocked(char* _dst, char* raw_data,
+                                   int unlockedWidth,
+                                   int width, int height, int top, int left,
+                                   int bpp);
+#endif
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.cpp b/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.cpp
index bc3b634..e9b9c55 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.cpp
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.cpp
@@ -14,15 +14,16 @@
 * limitations under the License.
 */
 #include "HostConnection.h"
-#include "TcpStream.h"
+
+#include "GLEncoder.h"
+#include "GL2Encoder.h"
 #include "QemuPipeStream.h"
+#include "TcpStream.h"
 #include "ThreadInfo.h"
+
 #include <cutils/log.h>
-#include "GLEncoder.h"
-#include "GL2Encoder.h"
-#include <memory>
 
-#define STREAM_BUFFER_SIZE  4*1024*1024
+#define STREAM_BUFFER_SIZE  (4*1024*1024)
 #define STREAM_PORT_NUM     22468
 
 /* Set to 1 to use a QEMU pipe, or 0 for a TCP connection */
@@ -33,7 +34,9 @@ HostConnection::HostConnection() :
     m_glEnc(NULL),
     m_gl2Enc(NULL),
     m_rcEnc(NULL),
-    m_checksumHelper()
+    m_checksumHelper(),
+    m_glExtensions(),
+    m_grallocOnly(true)
 {
 }
 
@@ -45,13 +48,16 @@ HostConnection::~HostConnection()
     delete m_rcEnc;
 }
 
-HostConnection *HostConnection::get()
-{
+HostConnection *HostConnection::get() {
+    return getWithThreadInfo(getEGLThreadInfo());
+}
+
+HostConnection *HostConnection::getWithThreadInfo(EGLThreadInfo* tinfo) {
+
     /* TODO: Make this configurable with a system property */
     const int useQemuPipe = USE_QEMU_PIPE;
 
     // Get thread info
-    EGLThreadInfo *tinfo = getEGLThreadInfo();
     if (!tinfo) {
         return NULL;
     }
@@ -76,6 +82,7 @@ HostConnection *HostConnection::get()
                 return NULL;
             }
             con->m_stream = stream;
+            con->m_pipeFd = stream->getSocket();
         }
         else /* !useQemuPipe */
         {
@@ -108,6 +115,20 @@ HostConnection *HostConnection::get()
     return tinfo->hostConn;
 }
 
+void HostConnection::exit() {
+    EGLThreadInfo *tinfo = getEGLThreadInfo();
+    if (!tinfo) {
+        return;
+    }
+
+    if (tinfo->hostConn) {
+        delete tinfo->hostConn;
+        tinfo->hostConn = NULL;
+    }
+}
+
+
+
 GLEncoder *HostConnection::glEncoder()
 {
     if (!m_glEnc) {
@@ -128,13 +149,15 @@ GL2Encoder *HostConnection::gl2Encoder()
     return m_gl2Enc;
 }
 
-renderControl_encoder_context_t *HostConnection::rcEncoder()
+ExtendedRCEncoderContext *HostConnection::rcEncoder()
 {
     if (!m_rcEnc) {
-        m_rcEnc = new renderControl_encoder_context_t(m_stream, checksumHelper());
-        // TODO: disable checksum as a workaround in a glTexSubImage2D problem
-        // Uncomment the following line when the root cause is solved
+        m_rcEnc = new ExtendedRCEncoderContext(m_stream, checksumHelper());
         //setChecksumHelper(m_rcEnc);
+        //queryAndSetSyncImpl(m_rcEnc);
+        //queryAndSetDmaImpl(m_rcEnc);
+        queryAndSetGLESMaxVersion(m_rcEnc);
+        //processPipeInit(m_rcEnc);
     }
     return m_rcEnc;
 }
@@ -157,21 +180,40 @@ gl2_client_context_t *HostConnection::s_getGL2Context()
     return NULL;
 }
 
-void HostConnection::setChecksumHelper(renderControl_encoder_context_t *rcEnc) {
-    std::unique_ptr<char[]> glExtensions;
-    int extensionSize = rcEnc->rcGetGLString(rcEnc, GL_EXTENSIONS, NULL, 0);
+const std::string& HostConnection::queryGLExtensions(ExtendedRCEncoderContext *rcEnc) {
+    if (!m_glExtensions.empty()) {
+        return m_glExtensions;
+    }
+
+    // Extensions strings are usually quite long, preallocate enough here.
+    std::string extensions_buffer(1023, '\0');
+
+    // rcGetGLString() returns required size including the 0-terminator, so
+    // account it when passing/using the sizes.
+    int extensionSize = rcEnc->rcGetGLString(rcEnc, GL_EXTENSIONS,
+                                             &extensions_buffer[0],
+                                             extensions_buffer.size() + 1);
     if (extensionSize < 0) {
-        glExtensions = std::unique_ptr<char[]>(new char[-extensionSize]);
-        extensionSize = rcEnc->rcGetGLString(rcEnc, GL_EXTENSIONS, glExtensions.get(), -extensionSize);
-        if (extensionSize <= 0) {
-            glExtensions.reset();
-        }
+        extensions_buffer.resize(-extensionSize);
+        extensionSize = rcEnc->rcGetGLString(rcEnc, GL_EXTENSIONS,
+                                             &extensions_buffer[0],
+                                            -extensionSize + 1);
+    }
+
+    if (extensionSize > 0) {
+        extensions_buffer.resize(extensionSize - 1);
+        m_glExtensions.swap(extensions_buffer);
     }
+
+    return m_glExtensions;
+}
+
+void HostConnection::setChecksumHelper(ExtendedRCEncoderContext *rcEnc) {
+    const std::string& glExtensions = queryGLExtensions(rcEnc);
     // check the host supported version
     uint32_t checksumVersion = 0;
     const char* checksumPrefix = ChecksumCalculator::getMaxVersionStrPrefix();
-    const char* glProtocolStr = glExtensions.get() ?
-            strstr(glExtensions.get(), checksumPrefix) : NULL;
+    const char* glProtocolStr = strstr(glExtensions.c_str(), checksumPrefix);
     if (glProtocolStr) {
         uint32_t maxVersion = ChecksumCalculator::getMaxVersion();
         sscanf(glProtocolStr+strlen(checksumPrefix), "%d", &checksumVersion);
@@ -184,3 +226,46 @@ void HostConnection::setChecksumHelper(renderControl_encoder_context_t *rcEnc) {
         m_checksumHelper.setVersion(checksumVersion);
     }
 }
+
+void HostConnection::queryAndSetSyncImpl(ExtendedRCEncoderContext *rcEnc) {
+    const std::string& glExtensions = queryGLExtensions(rcEnc);
+#if PLATFORM_SDK_VERSION <= 16 || (!defined(__i386__) && !defined(__x86_64__))
+    rcEnc->setSyncImpl(SYNC_IMPL_NONE);
+#else
+    if (glExtensions.find(kRCNativeSync) != std::string::npos) {
+        rcEnc->setSyncImpl(SYNC_IMPL_NATIVE_SYNC);
+    } else {
+        rcEnc->setSyncImpl(SYNC_IMPL_NONE);
+    }
+#endif
+}
+
+void HostConnection::queryAndSetDmaImpl(ExtendedRCEncoderContext *rcEnc) {
+    std::string glExtensions = queryGLExtensions(rcEnc);
+#if PLATFORM_SDK_VERSION <= 16 || (!defined(__i386__) && !defined(__x86_64__))
+    rcEnc->setDmaImpl(DMA_IMPL_NONE);
+#else
+    if (glExtensions.find(kDmaExtStr_v1) != std::string::npos) {
+        rcEnc->setDmaImpl(DMA_IMPL_v1);
+    } else {
+        rcEnc->setDmaImpl(DMA_IMPL_NONE);
+    }
+#endif
+}
+
+void HostConnection::queryAndSetGLESMaxVersion(ExtendedRCEncoderContext* rcEnc) {
+    std::string glExtensions = queryGLExtensions(rcEnc);
+    if (glExtensions.find(kGLESMaxVersion_2) != std::string::npos) {
+        rcEnc->setGLESMaxVersion(GLES_MAX_VERSION_2);
+    } else if (glExtensions.find(kGLESMaxVersion_3_0) != std::string::npos) {
+        rcEnc->setGLESMaxVersion(GLES_MAX_VERSION_3_0);
+    } else if (glExtensions.find(kGLESMaxVersion_3_1) != std::string::npos) {
+        rcEnc->setGLESMaxVersion(GLES_MAX_VERSION_3_1);
+    } else if (glExtensions.find(kGLESMaxVersion_3_2) != std::string::npos) {
+        rcEnc->setGLESMaxVersion(GLES_MAX_VERSION_3_2);
+    } else {
+        ALOGW("Unrecognized GLES max version string in extensions: %s",
+              glExtensions.c_str());
+        rcEnc->setGLESMaxVersion(GLES_MAX_VERSION_3_0);
+    }
+}
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.h
index a52fbfa..54ac9ae 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.h
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/HostConnection.h
@@ -20,20 +20,95 @@
 #include "renderControl_enc.h"
 #include "ChecksumCalculator.h"
 
+#include <string>
+
 class GLEncoder;
-class gl_client_context_t;
+struct gl_client_context_t;
 class GL2Encoder;
-class gl2_client_context_t;
+struct gl2_client_context_t;
+
+// SyncImpl determines the presence of host/guest OpenGL fence sync
+// capabilities. It corresponds exactly to EGL_ANDROID_native_fence_sync
+// capability, but for the emulator, we need to make sure that
+// OpenGL pipe protocols match, so we use a special extension name
+// here.
+// SYNC_IMPL_NONE means that the native fence sync capability is
+// not present, and we will end up using the equivalent of glFinish
+// in order to preserve buffer swapping order.
+// SYNC_IMPL_NATIVE_SYNC means that we do have native fence sync
+// capability, and we will use a fence fd to synchronize buffer swaps.
+enum SyncImpl {
+    SYNC_IMPL_NONE = 0,
+    SYNC_IMPL_NATIVE_SYNC = 1
+};
+
+// Interface:
+// If this GL extension string shows up, we use
+// SYNC_IMPL_NATIVE_SYNC, otherwise we use SYNC_IMPL_NONE.
+// This string is always updated to require the _latest_
+// version of Android emulator native sync in this system image;
+// otherwise, we do not use the feature.
+static const char kRCNativeSync[] = "ANDROID_EMU_native_sync_v2";
+
+// DMA for OpenGL
+enum DmaImpl {
+    DMA_IMPL_NONE = 0,
+    DMA_IMPL_v1 = 1,
+};
+
+static const char kDmaExtStr_v1[] = "ANDROID_EMU_dma_v1";
+
+// OpenGL ES max supported version
+enum GLESMaxVersion {
+    GLES_MAX_VERSION_2 = 0,
+    GLES_MAX_VERSION_3_0 = 1,
+    GLES_MAX_VERSION_3_1 = 2,
+    GLES_MAX_VERSION_3_2 = 3,
+};
+
+static const char kGLESMaxVersion_2[] = "ANDROID_EMU_gles_max_version_2";
+static const char kGLESMaxVersion_3_0[] = "ANDROID_EMU_gles_max_version_3_0";
+static const char kGLESMaxVersion_3_1[] = "ANDROID_EMU_gles_max_version_3_1";
+static const char kGLESMaxVersion_3_2[] = "ANDROID_EMU_gles_max_version_3_2";
+
+// ExtendedRCEncoderContext is an extended version of renderControl_encoder_context_t
+// that will be used to track SyncImpl.
+class ExtendedRCEncoderContext : public renderControl_encoder_context_t {
+public:
+    ExtendedRCEncoderContext(IOStream *stream, ChecksumCalculator *checksumCalculator)
+        : renderControl_encoder_context_t(stream, checksumCalculator) {
+        m_dmaCxt = NULL;
+        }
+    void setSyncImpl(SyncImpl syncImpl) { m_syncImpl = syncImpl; }
+    void setDmaImpl(DmaImpl dmaImpl) { m_dmaImpl = dmaImpl; }
+    bool hasNativeSync() const { return m_syncImpl == SYNC_IMPL_NATIVE_SYNC; }
+    DmaImpl getDmaVersion() const { return m_dmaImpl; }
+    void bindDmaContext(struct goldfish_dma_context* cxt) { m_dmaCxt = cxt; }
+    virtual uint64_t lockAndWriteDma(void* data, uint32_t size) {
+	    return 0;
+    }
+    void setGLESMaxVersion(GLESMaxVersion ver) { m_glesMaxVersion = ver; }
+    GLESMaxVersion getGLESMaxVersion() const { return m_glesMaxVersion; }
+private:
+    SyncImpl m_syncImpl;
+    DmaImpl m_dmaImpl;
+    struct goldfish_dma_context* m_dmaCxt;
+    GLESMaxVersion m_glesMaxVersion;
+};
+
+struct EGLThreadInfo;
 
 class HostConnection
 {
 public:
     static HostConnection *get();
+    static HostConnection *getWithThreadInfo(EGLThreadInfo* tInfo);
+    static void exit();
     ~HostConnection();
 
     GLEncoder *glEncoder();
     GL2Encoder *gl2Encoder();
-    renderControl_encoder_context_t *rcEncoder();
+    ExtendedRCEncoderContext *rcEncoder();
     ChecksumCalculator *checksumHelper() { return &m_checksumHelper; }
 
     void flush() {
@@ -42,20 +117,36 @@ public:
         }
     }
 
+    void setGrallocOnly(bool gralloc_only) {
+        m_grallocOnly = gralloc_only;
+    }
+
+    bool isGrallocOnly() const { return m_grallocOnly; }
+
+    int getPipeFd() const { return m_pipeFd; }
+
 private:
     HostConnection();
     static gl_client_context_t  *s_getGLContext();
     static gl2_client_context_t *s_getGL2Context();
+
+    const std::string& queryGLExtensions(ExtendedRCEncoderContext *rcEnc);
     // setProtocol initilizes GL communication protocol for checksums
     // should be called when m_rcEnc is created
-    void setChecksumHelper(renderControl_encoder_context_t *rcEnc);
+    void setChecksumHelper(ExtendedRCEncoderContext *rcEnc);
+    void queryAndSetSyncImpl(ExtendedRCEncoderContext *rcEnc);
+    void queryAndSetDmaImpl(ExtendedRCEncoderContext *rcEnc);
+    void queryAndSetGLESMaxVersion(ExtendedRCEncoderContext *rcEnc);
 
 private:
     IOStream *m_stream;
     GLEncoder   *m_glEnc;
     GL2Encoder  *m_gl2Enc;
-    renderControl_encoder_context_t *m_rcEnc;
+    ExtendedRCEncoderContext *m_rcEnc;
     ChecksumCalculator m_checksumHelper;
+    std::string m_glExtensions;
+    bool m_grallocOnly;
+    int m_pipeFd;
 };
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.cpp b/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.cpp
index 581aec3..45cc666 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.cpp
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.cpp
@@ -51,8 +51,11 @@ QemuPipeStream::~QemuPipeStream()
 
 int QemuPipeStream::connect(void)
 {
-    m_sock = qemu_pipe_open("opengles");
-    if (!valid()) return -1;
+     m_sock = qemu_pipe_open("opengles");
+    if (!valid()) {
+        ALOGE("%s: failed with fd %d errno %d", __FUNCTION__, m_sock, errno);
+        return -1;
+    }
     return 0;
 }
 
@@ -124,6 +127,10 @@ int QemuPipeStream::writeFully(const void *buf, size_t len)
     return retval;
 }
 
+int QemuPipeStream::getSocket() const {
+    return m_sock;
+}
+
 const unsigned char *QemuPipeStream::readFully(void *buf, size_t len)
 {
     //DBG(">> QemuPipeStream::readFully %d\n", len);
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.h
index 57ee399..15f74e6 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.h
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.h
@@ -41,6 +41,7 @@ public:
 
     virtual int writeFully(const void *buf, size_t len);
 
+    int getSocket() const;
 private:
     int m_sock;
     size_t m_bufsize;
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.cpp b/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.cpp
index 04ce508..9e11624 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.cpp
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.cpp
@@ -18,19 +18,30 @@
 
 thread_store_t s_tls = THREAD_STORE_INITIALIZER;
 
+static bool sDefaultTlsDestructorCallback(void* ptr) { return true; }
+static bool (*sTlsDestructorCallback)(void*) = sDefaultTlsDestructorCallback;
+
 static void tlsDestruct(void *ptr)
 {
+    sTlsDestructorCallback(ptr);
     if (ptr) {
         EGLThreadInfo *ti = (EGLThreadInfo *)ptr;
         delete ti->hostConn;
         delete ti;
+#ifdef __ANDROID__
         ((void **)__get_tls())[TLS_SLOT_OPENGL] = NULL;
+#endif
     }
 }
 
-EGLThreadInfo *slow_getEGLThreadInfo()
+void setTlsDestructor(tlsDtorCallback func) {
+    sTlsDestructorCallback = func;
+}
+
+EGLThreadInfo *goldfish_get_egl_tls()
 {
-    EGLThreadInfo *ti = (EGLThreadInfo *)thread_store_get(&s_tls);
+    EGLThreadInfo* ti = (EGLThreadInfo*)thread_store_get(&s_tls);
+
     if (ti) return ti;
 
     ti = new EGLThreadInfo();
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.h
index 9a5dc88..06d9267 100644
--- a/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.h
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/ThreadInfo.h
@@ -18,15 +18,14 @@
 
 #include "HostConnection.h"
 #include <pthread.h>
-#ifdef __ANDROID__
-#include <bionic_tls.h>
-#endif
 
+#include <bionic_tls.h>
 struct EGLContext_t;
+struct HostConnection;
 
 struct EGLThreadInfo
 {
-    EGLThreadInfo() : currentContext(NULL), hostConn(NULL), eglError(EGL_SUCCESS) {}
+    EGLThreadInfo() : currentContext(NULL), hostConn(NULL), eglError(EGL_SUCCESS) { }
 
     EGLContext_t *currentContext;
     HostConnection *hostConn;
@@ -34,26 +33,23 @@ struct EGLThreadInfo
 };
 
 
-EGLThreadInfo *slow_getEGLThreadInfo();
+typedef bool (*tlsDtorCallback)(void*);
+void setTlsDestructor(tlsDtorCallback);
+
+extern "C" __attribute__((visibility("default"))) EGLThreadInfo *goldfish_get_egl_tls();
 
+inline EGLThreadInfo* getEGLThreadInfo() {
 #ifdef __ANDROID__
-    // We have a dedicated TLS slot in bionic
-    inline EGLThreadInfo* getEGLThreadInfo() {
-        EGLThreadInfo *tInfo =
-             (EGLThreadInfo *)(((uintptr_t *)__get_tls())[TLS_SLOT_OPENGL]);
-        if (!tInfo) {
-            tInfo = slow_getEGLThreadInfo();
-            ((uintptr_t *)__get_tls())[TLS_SLOT_OPENGL] = (uintptr_t)tInfo;
-        }
-        return tInfo;
+    EGLThreadInfo *tInfo =
+        (EGLThreadInfo *)(((uintptr_t *)__get_tls())[TLS_SLOT_OPENGL]);
+    if (!tInfo) {
+        tInfo = goldfish_get_egl_tls();
+        ((uintptr_t *)__get_tls())[TLS_SLOT_OPENGL] = (uintptr_t)tInfo;
     }
+    return tInfo;
 #else
-    inline EGLThreadInfo* getEGLThreadInfo() {
-        return slow_getEGLThreadInfo();
-    }
+    return goldfish_get_egl_tls();
 #endif
-
-
-
+}
 
 #endif // of _THREAD_INFO_H
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/goldfishHwc2.cpp b/vendor/anbox/android/opengl/system/OpenglSystemCommon/goldfishHwc2.cpp
new file mode 100644
index 0000000..888ba89
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/goldfishHwc2.cpp
@@ -0,0 +1,22 @@
+/*
+* Copyright (C) 2017 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#include "goldfishHwc2.h"
+
+// Stub functions if not using HWC2.
+#ifndef USE_HWC2
+extern "C" void surfaceInterface_init() { }
+extern "C" void surfaceInterface_setAsyncModeForWindow(void* window) { }
+#endif
diff --git a/vendor/anbox/android/opengl/system/OpenglSystemCommon/goldfishHwc2.h b/vendor/anbox/android/opengl/system/OpenglSystemCommon/goldfishHwc2.h
new file mode 100644
index 0000000..cb1a396
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/OpenglSystemCommon/goldfishHwc2.h
@@ -0,0 +1,25 @@
+/*
+* Copyright (C) 2017 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#pragma once
+
+// Set of functions that help support HWC2 in the emulator.
+
+#ifdef USE_HWC2
+#include "../surfaceInterface/surfaceInterface.h"
+#else
+extern "C" void surfaceInterface_init();
+extern "C" void surfaceInterface_setAsyncModeForWindow(void* window);
+#endif
diff --git a/vendor/anbox/android/opengl/system/egl/Android.mk b/vendor/anbox/android/opengl/system/egl/Android.mk
index 241cefe..37aadd7 100644
--- a/vendor/anbox/android/opengl/system/egl/Android.mk
+++ b/vendor/anbox/android/opengl/system/egl/Android.mk
@@ -13,8 +13,12 @@ LOCAL_SRC_FILES := \
     egl.cpp \
     ClientAPIExts.cpp
 
-LOCAL_SHARED_LIBRARIES += libdl
+ifeq ($(TARGET_USES_HWC2), true)
+    LOCAL_CFLAGS += -DUSE_HWC2
+    LOCAL_STATIC_LIBRARIES += libsurfaceInterface
+endif
 
+LOCAL_SHARED_LIBRARIES += libdl
 # Used to access the Bionic private OpenGL TLS slot
 LOCAL_C_INCLUDES += bionic/libc/private
 
@@ -35,6 +39,10 @@ LOCAL_SRC_FILES := $(LOCAL_MODULE)
 LOCAL_MODULE_PATH := $(TARGET_OUT)/lib/egl
 LOCAL_MODULE_CLASS := ETC
 
+ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 19 && echo PreKitkat),PreKitkat)
+    LOCAL_MODULE_TAGS := debug
+endif
+
 include $(BUILD_PREBUILT)
 endif # TARGET_PRODUCT in 'full full_x86 full_mips sdk sdk_x86 sdk_mips google_sdk google_sdk_x86 google_sdk_mips')
 
diff --git a/vendor/anbox/android/opengl/system/egl/ClientAPIExts.cpp b/vendor/anbox/android/opengl/system/egl/ClientAPIExts.cpp
index 5e81afe..0f02dcb 100644
--- a/vendor/anbox/android/opengl/system/egl/ClientAPIExts.cpp
+++ b/vendor/anbox/android/opengl/system/egl/ClientAPIExts.cpp
@@ -27,11 +27,12 @@ namespace ClientAPIExts
 // typename has the form __egl_{funcname}_t
 //
 #define FUNC_TYPE(fname) __egl_ ## fname ## _t
+// NOLINT: clang-tidy adds parentheses around 'params'.
 #define API_ENTRY(fname,params,args) \
-    typedef void (GL_APIENTRY *FUNC_TYPE(fname)) params;
+    typedef void (GL_APIENTRY *FUNC_TYPE(fname)) params;  // NOLINT
 
 #define API_ENTRY_RET(rtype,fname,params,args) \
-    typedef rtype (GL_APIENTRY *FUNC_TYPE(fname)) params;
+    typedef rtype (GL_APIENTRY *FUNC_TYPE(fname)) params;  // NOLINT
 
 #include "ClientAPIExts.in"
 #undef API_ENTRY
@@ -44,7 +45,7 @@ namespace ClientAPIExts
 // loaded.
 /////
 #define API_ENTRY(fname,params,args) \
-    FUNC_TYPE(fname) fname;
+    FUNC_TYPE(fname) (fname);
 
 #define API_ENTRY_RET(rtype,fname,params,args) \
     API_ENTRY(fname,params,args)
@@ -88,6 +89,7 @@ void initClientFuncs(const EGLClient_glesInterface *iface, int idx)
 // the current context version and calls to the correct client API
 // function.
 //
+// NOLINT: clang-tidy adds parentheses around 'args'.
 #define API_ENTRY(fname,params,args) \
     static void _egl_ ## fname params \
     { \
@@ -95,11 +97,11 @@ void initClientFuncs(const EGLClient_glesInterface *iface, int idx)
         if (!thread->currentContext) { \
             return; \
         } \
-        int idx = (int)thread->currentContext->version - 1; \
+        int idx = (int)thread->currentContext->majorVersion - 1; \
         if (!s_client_extensions[idx].fname) { \
             return; \
         } \
-        (*s_client_extensions[idx].fname) args; \
+        (*s_client_extensions[idx].fname) args; /* NOLINT */ \
     }
 
 #define API_ENTRY_RET(rtype,fname,params,args) \
@@ -109,11 +111,11 @@ void initClientFuncs(const EGLClient_glesInterface *iface, int idx)
         if (!thread->currentContext) { \
             return (rtype)0; \
         } \
-        int idx = (int)thread->currentContext->version - 1; \
+        int idx = (int)thread->currentContext->majorVersion - 1; \
         if (!s_client_extensions[idx].fname) { \
             return (rtype)0; \
         } \
-        return (*s_client_extensions[idx].fname) args; \
+        return (*s_client_extensions[idx].fname) args; /* NOLINT */ \
     }
 
 #include "ClientAPIExts.in"
diff --git a/vendor/anbox/android/opengl/system/egl/egl.cpp b/vendor/anbox/android/opengl/system/egl/egl.cpp
index ae5a889..a6f1906 100644
--- a/vendor/anbox/android/opengl/system/egl/egl.cpp
+++ b/vendor/anbox/android/opengl/system/egl/egl.cpp
@@ -14,11 +14,15 @@
 * limitations under the License.
 */
 
+#include <assert.h>
 #include "HostConnection.h"
 #include "ThreadInfo.h"
 #include "eglDisplay.h"
+#include "eglSync.h"
 #include "egl_ftable.h"
 #include <cutils/log.h>
+#include <cutils/properties.h>
+#include "goldfish_sync.h"
 #include "gralloc_cb.h"
 #include "GLClientState.h"
 #include "GLSharedGroup.h"
@@ -31,8 +35,19 @@
 #include "GL2Encoder.h"
 #endif
 
+#include <GLES3/gl31.h>
+
 #include <system/window.h>
 
+
+#define DEBUG_EGL 0
+
+#if DEBUG_EGL
+#define DPRINT(fmt,...) ALOGD("%s: " fmt, __FUNCTION__, ##__VA_ARGS__);
+#else
+#define DPRINT(...)
+#endif
+
 template<typename T>
 static T setErrorFunc(GLint error, T returnValue) {
     getEGLThreadInfo()->eglError = error;
@@ -87,7 +102,7 @@ const char *  eglStrError(EGLint err)
 #endif //LOG_EGL_ERRORS
 
 #define VALIDATE_CONFIG(cfg,ret) \
-    if(((intptr_t)cfg<0)||((intptr_t)cfg>s_display.getNumConfigs())) { \
+    if(((intptr_t)(cfg)<0)||((intptr_t)(cfg)>s_display.getNumConfigs())) { \
         RETURN_ERROR(ret,EGL_BAD_CONFIG); \
     }
 
@@ -104,7 +119,7 @@ const char *  eglStrError(EGLint err)
 
 #define DEFINE_HOST_CONNECTION \
     HostConnection *hostCon = HostConnection::get(); \
-    renderControl_encoder_context_t *rcEnc = (hostCon ? hostCon->rcEncoder() : NULL)
+    ExtendedRCEncoderContext *rcEnc = (hostCon ? hostCon->rcEncoder() : NULL)
 
 #define DEFINE_AND_VALIDATE_HOST_CONNECTION(ret) \
     HostConnection *hostCon = HostConnection::get(); \
@@ -112,26 +127,40 @@ const char *  eglStrError(EGLint err)
         ALOGE("egl: Failed to get host connection\n"); \
         return ret; \
     } \
-    renderControl_encoder_context_t *rcEnc = hostCon->rcEncoder(); \
+    ExtendedRCEncoderContext *rcEnc = hostCon->rcEncoder(); \
     if (!rcEnc) { \
         ALOGE("egl: Failed to get renderControl encoder context\n"); \
         return ret; \
     }
 
-#define VALIDATE_CONTEXT_RETURN(context,ret)        \
-    if (!context) {                                    \
+#define DEFINE_AND_VALIDATE_HOST_CONNECTION_FOR_TLS(ret, tls) \
+    HostConnection *hostCon = HostConnection::getWithThreadInfo(tls); \
+    if (!hostCon) { \
+        ALOGE("egl: Failed to get host connection\n"); \
+        return ret; \
+    } \
+    ExtendedRCEncoderContext *rcEnc = hostCon->rcEncoder(); \
+    if (!rcEnc) { \
+        ALOGE("egl: Failed to get renderControl encoder context\n"); \
+        return ret; \
+    }
+
+#define VALIDATE_CONTEXT_RETURN(context,ret)  \
+    if (!(context)) {                         \
         RETURN_ERROR(ret,EGL_BAD_CONTEXT);    \
     }
 
 #define VALIDATE_SURFACE_RETURN(surface, ret)    \
-    if (surface != EGL_NO_SURFACE) {    \
+    if ((surface) != EGL_NO_SURFACE) {    \
         egl_surface_t* s( static_cast<egl_surface_t*>(surface) );    \
         if (s->dpy != (EGLDisplay)&s_display)    \
             setErrorReturn(EGL_BAD_DISPLAY, EGL_FALSE);    \
     }
 
+// The one and only supported display object.
+static eglDisplay s_display;
 
-EGLContext_t::EGLContext_t(EGLDisplay dpy, EGLConfig config, EGLContext_t* shareCtx) :
+EGLContext_t::EGLContext_t(EGLDisplay dpy, EGLConfig config, EGLContext_t* shareCtx, int maj, int min) :
     dpy(dpy),
     config(config),
     read(EGL_NO_SURFACE),
@@ -139,23 +168,61 @@ EGLContext_t::EGLContext_t(EGLDisplay dpy, EGLConfig config, EGLContext_t* share
     shareCtx(shareCtx),
     rcContext(0),
     versionString(NULL),
+    majorVersion(maj),
+    minorVersion(min),
     vendorString(NULL),
     rendererString(NULL),
     shaderVersionString(NULL),
     extensionString(NULL),
-    deletePending(0)
+    deletePending(0),
+    goldfishSyncFd(-1)
 {
+
+    DEFINE_HOST_CONNECTION;
+    switch (rcEnc->getGLESMaxVersion()) {
+        case GLES_MAX_VERSION_3_0:
+            deviceMajorVersion = 3;
+            deviceMinorVersion = 0;
+            break;
+        case GLES_MAX_VERSION_3_1:
+            deviceMajorVersion = 3;
+            deviceMinorVersion = 1;
+            break;
+        case GLES_MAX_VERSION_3_2:
+            deviceMajorVersion = 3;
+            deviceMinorVersion = 2;
+            break;
+        default:
+            deviceMajorVersion = 2;
+            deviceMinorVersion = 0;
+            break;
+    }
+
     flags = 0;
-    version = 1;
-    clientState = new GLClientState();
-    if (shareCtx)
+    clientState = new GLClientState(majorVersion, minorVersion);
+     if (shareCtx)
         sharedGroup = shareCtx->getSharedGroup();
     else
         sharedGroup = GLSharedGroupPtr(new GLSharedGroup());
+    assert(dpy == (EGLDisplay)&s_display);
+    s_display.onCreateContext((EGLContext)this);
 };
 
+int EGLContext_t::getGoldfishSyncFd() {
+    if (goldfishSyncFd < 0) {
+        goldfishSyncFd = goldfish_sync_open();
+    }
+    return goldfishSyncFd;
+}
+
 EGLContext_t::~EGLContext_t()
 {
+    if (goldfishSyncFd > 0) {
+        goldfish_sync_close(goldfishSyncFd);
+        goldfishSyncFd = -1;
+    }
+    assert(dpy == (EGLDisplay)&s_display);
+    s_display.onDestroyContext((EGLContext)this);
     delete clientState;
     delete [] versionString;
     delete [] vendorString;
@@ -187,6 +254,8 @@ struct egl_surface_t {
 
     EGLint      getWidth(){ return width; }
     EGLint      getHeight(){ return height; }
+    EGLint      getNativeWidth(){ return nativeWidth; }
+    EGLint      getNativeHeight(){ return nativeHeight; }
     void        setTextureFormat(EGLint _texFormat) { texFormat = _texFormat; }
     EGLint      getTextureFormat() { return texFormat; }
     void        setTextureTarget(EGLint _texTarget) { texTarget = _texTarget; }
@@ -201,9 +270,16 @@ private:
     EGLint      texFormat;
     EGLint      texTarget;
 
+    // Width of the actual window being presented (not the EGL texture)
+    // Give it some default values.
+    int nativeWidth;
+    int nativeHeight;
+
 protected:
     void        setWidth(EGLint w)  { width = w;  }
     void        setHeight(EGLint h) { height = h; }
+    void        setNativeWidth(int w)  { nativeWidth = w;  }
+    void        setNativeHeight(int h) { nativeHeight = h; }
 
     EGLint      surfaceType;
     uint32_t    rcSurface; //handle to surface created via remote control
@@ -214,8 +290,13 @@ egl_surface_t::egl_surface_t(EGLDisplay dpy, EGLConfig config, EGLint surfaceTyp
 {
     width = 0;
     height = 0;
+    // prevent div by 0 in EGL_(HORIZONTAL|VERTICAL)_RESOLUTION queries.
+    nativeWidth = 1;
+    nativeHeight = 1;
     texFormat = EGL_NO_TEXTURE;
     texTarget = EGL_NO_TEXTURE;
+    assert(dpy == (EGLDisplay)&s_display);
+    s_display.onCreateSurface((EGLSurface)this);
 }
 
 EGLint egl_surface_t::getSwapBehavior() const {
@@ -224,6 +305,8 @@ EGLint egl_surface_t::getSwapBehavior() const {
 
 egl_surface_t::~egl_surface_t()
 {
+    assert(dpy == (EGLDisplay)&s_display);
+    s_display.onDestroySurface((EGLSurface)this);
 }
 
 // ----------------------------------------------------------------------------
@@ -260,6 +343,7 @@ egl_window_surface_t::egl_window_surface_t (
     nativeWindow->common.incRef(&nativeWindow->common);
 }
 
+
 EGLBoolean egl_window_surface_t::init()
 {
     if (nativeWindow->dequeueBuffer_DEPRECATED(nativeWindow, &buffer) != NO_ERROR) {
@@ -268,6 +352,13 @@ EGLBoolean egl_window_surface_t::init()
     setWidth(buffer->width);
     setHeight(buffer->height);
 
+    int nativeWidth, nativeHeight;
+          nativeWindow->query(nativeWindow, NATIVE_WINDOW_WIDTH, &nativeWidth);
+          nativeWindow->query(nativeWindow, NATIVE_WINDOW_HEIGHT, &nativeHeight);
+
+    setNativeWidth(nativeWidth);
+    setNativeHeight(nativeHeight);
+
     DEFINE_AND_VALIDATE_HOST_CONNECTION(EGL_FALSE);
     rcSurface = rcEnc->rcCreateWindowSurface(rcEnc, (uintptr_t)config,
             getWidth(), getHeight());
@@ -309,19 +400,75 @@ void egl_window_surface_t::setSwapInterval(int interval)
 {
     nativeWindow->setSwapInterval(nativeWindow, interval);
 }
+/*
+// createNativeSync() creates an OpenGL sync object on the host
+// using rcCreateSyncKHR. If necessary, a native fence FD will
+// also be created through the goldfish sync device.
+// Returns a handle to the host-side FenceSync object.
+static uint64_t createNativeSync(EGLenum type,
+                                 const EGLint* attrib_list,
+                                 int num_actual_attribs,
+                                 bool destroy_when_signaled,
+                                 int fd_in,
+                                 int* fd_out) {
+    DEFINE_HOST_CONNECTION;
+
+    uint64_t sync_handle;
+    uint64_t thread_handle;
+
+    EGLint* actual_attribs =
+        (EGLint*)(num_actual_attribs == 0 ? NULL : attrib_list);
+
+    rcEnc->rcCreateSyncKHR(rcEnc, type,
+                           actual_attribs,
+                           num_actual_attribs * sizeof(EGLint),
+                           destroy_when_signaled,
+                           &sync_handle,
+                           &thread_handle);
+
+    if (type == EGL_SYNC_NATIVE_FENCE_ANDROID && fd_in < 0) {
+        int queue_work_err =
+            goldfish_sync_queue_work(
+                    getEGLThreadInfo()->currentContext->getGoldfishSyncFd(),
+                    sync_handle,
+                    thread_handle,
+                    fd_out);
+
+        DPRINT("got native fence fd=%d queue_work_err=%d",
+               *fd_out, queue_work_err);
+    }
+
+    return sync_handle;
+}
+*/
+// createGoldfishOpenGLNativeSync() is for creating host-only sync objects
+// that are needed by only this goldfish opengl driver,
+// such as in swapBuffers().
+// The guest will not see any of these, and these sync objects will be
+// destroyed on the host when signaled.
+// A native fence FD is possibly returned.
+//static void createGoldfishOpenGLNativeSync(int* fd_out) {
+//    createNativeSync(EGL_SYNC_NATIVE_FENCE_ANDROID,
+//                     NULL /* empty attrib list */,
+//                     0 /* 0 attrib count */,
+//                     true /* destroy when signaled. this is host-only
+//                             and there will only be one waiter */,
+//                     -1 /* we want a new fd */,
+//                     fd_out);
+//}
 
 EGLBoolean egl_window_surface_t::swapBuffers()
 {
+
     DEFINE_AND_VALIDATE_HOST_CONNECTION(EGL_FALSE);
 
     rcEnc->rcFlushWindowColorBuffer(rcEnc, rcSurface);
-
     nativeWindow->queueBuffer_DEPRECATED(nativeWindow, buffer);
+
     if (nativeWindow->dequeueBuffer_DEPRECATED(nativeWindow, &buffer)) {
         buffer = NULL;
         setErrorReturn(EGL_BAD_ALLOC, EGL_FALSE);
     }
-
     rcEnc->rcSetWindowColorBuffer(rcEnc, rcSurface,
             ((cb_handle_t *)(buffer->handle))->hostHandle);
 
@@ -382,8 +529,7 @@ EGLBoolean egl_pbuffer_surface_t::init(GLenum pixelFormat)
         return EGL_FALSE;
     }
 
-    rcColorBuffer = rcEnc->rcCreateColorBuffer(rcEnc, getWidth(), getHeight(),
-            pixelFormat);
+    rcColorBuffer = rcEnc->rcCreateColorBuffer(rcEnc, getWidth(), getHeight(), pixelFormat);
     if (!rcColorBuffer) {
         ALOGE("rcCreateColorBuffer returned 0");
         return EGL_FALSE;
@@ -444,13 +590,6 @@ static const char *getGLString(int glEnum)
         return NULL;
     }
 
-    if (*strPtr != NULL) {
-        //
-        // string is already cached
-        //
-        return *strPtr;
-    }
-
     //
     // first query of that string - need to query host
     //
@@ -475,9 +614,6 @@ static const char *getGLString(int glEnum)
 
 // ----------------------------------------------------------------------------
 
-// The one and only supported display object.
-static eglDisplay s_display;
-
 static EGLClient_eglInterface s_eglIface = {
     getThreadInfo: getEGLThreadInfo,
     getGLString: getGLString
@@ -574,6 +710,10 @@ EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig
 {
     VALIDATE_DISPLAY_INIT(dpy, EGL_FALSE);
 
+    if (!num_config) {
+        setErrorReturn(EGL_BAD_PARAMETER, EGL_FALSE);
+    }
+
     int attribs_size = 0;
     if (attrib_list) {
         const EGLint * attrib_p = attrib_list;
@@ -584,16 +724,21 @@ EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig
         attribs_size++; //for the terminating EGL_NONE
     }
 
+    // API 19 passes EGL_SWAP_BEHAVIOR_PRESERVED_BIT to surface type,
+    // while the host never supports it.
+    // We remove the bit here.
+
     uint32_t* tempConfigs[config_size];
     DEFINE_AND_VALIDATE_HOST_CONNECTION(EGL_FALSE);
-    *num_config = rcEnc->rcChooseConfig(rcEnc, (EGLint*)attrib_list, attribs_size * sizeof(EGLint), (uint32_t*)tempConfigs, config_size);
+    *num_config = rcEnc->rcChooseConfig(rcEnc,(EGLint*)attrib_list,
+            attribs_size * sizeof(EGLint), (uint32_t*)tempConfigs, config_size);
+
     if (configs!=NULL) {
         EGLint i=0;
         for (i=0;i<(*num_config);i++) {
              *((uintptr_t*)configs+i) = *((uint32_t*)tempConfigs+i);
         }
     }
-
     if (*num_config <= 0)
         return EGL_FALSE;
     return EGL_TRUE;
@@ -610,6 +755,7 @@ EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute
     }
     else
     {
+        ALOGD("%s: bad attrib 0x%x", __FUNCTION__, attribute);
         RETURN_ERROR(EGL_FALSE, EGL_BAD_ATTRIBUTE);
     }
 }
@@ -664,9 +810,11 @@ EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLin
         switch (attrib_list[0]) {
             case EGL_WIDTH:
                 w = attrib_list[1];
+                if (w < 0) setErrorReturn(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
                 break;
             case EGL_HEIGHT:
                 h = attrib_list[1];
+                if (h < 0) setErrorReturn(EGL_BAD_PARAMETER, EGL_NO_SURFACE);
                 break;
             case EGL_TEXTURE_FORMAT:
                 texFormat = attrib_list[1];
@@ -674,8 +822,14 @@ EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLin
             case EGL_TEXTURE_TARGET:
                 texTarget = attrib_list[1];
                 break;
-            default:
+            // the followings are not supported
+            case EGL_LARGEST_PBUFFER:
+            case EGL_MIPMAP_TEXTURE:
+            case EGL_VG_ALPHA_FORMAT:
+            case EGL_VG_COLORSPACE:
                 break;
+            default:
+                setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
         };
         attrib_list+=2;
     }
@@ -709,8 +863,8 @@ EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePix
     //     to s/w rendering -or- let the host render to a buffer that will be
     //     copied back to guest at some sync point. None of those methods not
     //     implemented and pixmaps are not used with OpenGL anyway ...
+    VALIDATE_CONFIG(config, EGL_FALSE);
     (void)dpy;
-    (void)config;
     (void)pixmap;
     (void)attrib_list;
     return EGL_NO_SURFACE;
@@ -727,12 +881,25 @@ EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface eglSurface)
     return EGL_TRUE;
 }
 
+static float s_getNativeDpi() {
+    float nativeDPI = 560.0f;
+    const char* dpiPropName = "qemu.sf.lcd_density";
+    char dpiProp[PROPERTY_VALUE_MAX];
+    if (property_get(dpiPropName, dpiProp, NULL) > 0) {
+        nativeDPI = atof(dpiProp);
+    }
+    return nativeDPI;
+}
+
 EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface eglSurface, EGLint attribute, EGLint *value)
 {
     VALIDATE_DISPLAY_INIT(dpy, EGL_FALSE);
     VALIDATE_SURFACE_RETURN(eglSurface, EGL_FALSE);
 
     egl_surface_t* surface( static_cast<egl_surface_t*>(eglSurface) );
+
+    // Parameters involved in queries of EGL_(HORIZONTAL|VERTICAL)_RESOLUTION
+    float currWidth, currHeight, scaledResolution, effectiveSurfaceDPI;
     EGLBoolean ret = EGL_TRUE;
     switch (attribute) {
         case EGL_CONFIG_ID:
@@ -745,19 +912,39 @@ EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface eglSurface, EGLint attribu
             *value = surface->getHeight();
             break;
         case EGL_TEXTURE_FORMAT:
-            *value = surface->getTextureFormat();
+            if (surface->getSurfaceType() & EGL_PBUFFER_BIT) {
+                *value = surface->getTextureFormat();
+            }
             break;
         case EGL_TEXTURE_TARGET:
-            *value = surface->getTextureTarget();
+            if (surface->getSurfaceType() & EGL_PBUFFER_BIT) {
+                *value = surface->getTextureTarget();
+            }
             break;
         case EGL_SWAP_BEHAVIOR:
-            *value = surface->getSwapBehavior();
+        {
+            EGLint surfaceType;
+            ret = s_display.getConfigAttrib(surface->config, EGL_SURFACE_TYPE,
+                    &surfaceType);
+            if (ret == EGL_TRUE) {
+                if (surfaceType & EGL_SWAP_BEHAVIOR_PRESERVED_BIT) {
+                    *value = EGL_BUFFER_PRESERVED;
+                } else {
+                    *value = EGL_BUFFER_DESTROYED;
+                }
+            }
             break;
+        }
         case EGL_LARGEST_PBUFFER:
             // not modified for a window or pixmap surface
             // and we ignore it when creating a PBuffer surface (default is EGL_FALSE)
             if (surface->getSurfaceType() & EGL_PBUFFER_BIT) *value = EGL_FALSE;
             break;
+        case EGL_MIPMAP_TEXTURE:
+            // not modified for a window or pixmap surface
+            // and we ignore it when creating a PBuffer surface (default is 0)
+            if (surface->getSurfaceType() & EGL_PBUFFER_BIT) *value = false;
+            break;
         case EGL_MIPMAP_LEVEL:
             // not modified for a window or pixmap surface
             // and we ignore it when creating a PBuffer surface (default is 0)
@@ -767,6 +954,56 @@ EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface eglSurface, EGLint attribu
             // ignored when creating the surface, return default
             *value = EGL_MULTISAMPLE_RESOLVE_DEFAULT;
             break;
+        case EGL_HORIZONTAL_RESOLUTION:
+            // pixel/mm * EGL_DISPLAY_SCALING
+            // TODO: get the DPI from avd config
+            currWidth = surface->getWidth();
+            scaledResolution = currWidth / surface->getNativeWidth();
+            effectiveSurfaceDPI =
+                scaledResolution * s_getNativeDpi() * EGL_DISPLAY_SCALING;
+            *value = (EGLint)(effectiveSurfaceDPI);
+            break;
+        case EGL_VERTICAL_RESOLUTION:
+            // pixel/mm * EGL_DISPLAY_SCALING
+            // TODO: get the real DPI from avd config
+            currHeight = surface->getHeight();
+            scaledResolution = currHeight / surface->getNativeHeight();
+            effectiveSurfaceDPI =
+                scaledResolution * s_getNativeDpi() * EGL_DISPLAY_SCALING;
+            *value = (EGLint)(effectiveSurfaceDPI);
+            break;
+        case EGL_PIXEL_ASPECT_RATIO:
+            // w / h * EGL_DISPLAY_SCALING
+            // Please don't ask why * EGL_DISPLAY_SCALING, the document says it
+            *value = 1 * EGL_DISPLAY_SCALING;
+            break;
+        case EGL_RENDER_BUFFER:
+            switch (surface->getSurfaceType()) {
+                case EGL_PBUFFER_BIT:
+                    *value = EGL_BACK_BUFFER;
+                    break;
+                case EGL_PIXMAP_BIT:
+                    *value = EGL_SINGLE_BUFFER;
+                    break;
+                case EGL_WINDOW_BIT:
+                    // ignored when creating the surface, return default
+                    *value = EGL_BACK_BUFFER;
+                    break;
+                default:
+                    ALOGE("eglQuerySurface %x unknown surface type %x",
+                            attribute, surface->getSurfaceType());
+                    ret = setErrorFunc(EGL_BAD_ATTRIBUTE, EGL_FALSE);
+                    break;
+            }
+            break;
+        case EGL_VG_COLORSPACE:
+            // ignored when creating the surface, return default
+            *value = EGL_VG_COLORSPACE_sRGB;
+            break;
+        case EGL_VG_ALPHA_FORMAT:
+            // ignored when creating the surface, return default
+            *value = EGL_VG_ALPHA_FORMAT_NONPRE;
+            break;
         //TODO: complete other attributes
         default:
             ALOGE("eglQuerySurface %x  EGL_BAD_ATTRIBUTE", attribute);
@@ -794,15 +1031,40 @@ EGLBoolean eglWaitClient()
     return eglWaitGL();
 }
 
-EGLBoolean eglReleaseThread()
-{
-    EGLThreadInfo *tInfo = getEGLThreadInfo();
-    if (tInfo && tInfo->currentContext) {
-        return eglMakeCurrent(&s_display, EGL_NO_CONTEXT, EGL_NO_SURFACE, EGL_NO_SURFACE);
+// We may need to trigger this directly from the TLS destructor.
+static EGLBoolean s_eglReleaseThreadImpl(EGLThreadInfo* tInfo) {
+    if (!tInfo) return EGL_TRUE;
+
+    tInfo->eglError = EGL_SUCCESS;
+    EGLContext_t* context = tInfo->currentContext;
+
+    if (!context) return EGL_TRUE;
+
+    // The following code is doing pretty much the same thing as
+    // eglMakeCurrent(&s_display, EGL_NO_CONTEXT, EGL_NO_SURFACE, EGL_NO_SURFACE)
+    // with the only issue that we do not require a valid display here.
+    DEFINE_AND_VALIDATE_HOST_CONNECTION_FOR_TLS(EGL_FALSE, tInfo);
+    // We are going to call makeCurrent on the null context and surface
+    // anyway once we are on the host, so skip rcMakeCurrent here.
+    // rcEnc->rcMakeCurrent(rcEnc, 0, 0, 0);
+    context->flags &= ~EGLContext_t::IS_CURRENT;
+    if (context->deletePending) {
+        if (context->rcContext) {
+            rcEnc->rcDestroyContext(rcEnc, context->rcContext);
+            context->rcContext = 0;
+        }
+        delete context;
     }
+    tInfo->currentContext = 0;
+
     return EGL_TRUE;
 }
 
+EGLBoolean eglReleaseThread()
+{
+    return s_eglReleaseThreadImpl(getEGLThreadInfo());
+}
+
 EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
 {
     //TODO
@@ -830,14 +1092,36 @@ EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute
 
     (void)value;
 
+    egl_surface_t* p_surface( static_cast<egl_surface_t*>(surface) );
     switch (attribute) {
     case EGL_MIPMAP_LEVEL:
+        return true;
+        break;
     case EGL_MULTISAMPLE_RESOLVE:
+    {
+        if (value == EGL_MULTISAMPLE_RESOLVE_BOX) {
+            EGLint surface_type;
+            s_display.getConfigAttrib(p_surface->config, EGL_SURFACE_TYPE, &surface_type);
+            if (0 == (surface_type & EGL_MULTISAMPLE_RESOLVE_BOX_BIT)) {
+                setErrorReturn(EGL_BAD_MATCH, EGL_FALSE);
+            }
+        }
+        return true;
+        break;
+    }
     case EGL_SWAP_BEHAVIOR:
+        if (value == EGL_BUFFER_PRESERVED) {
+            EGLint surface_type;
+            s_display.getConfigAttrib(p_surface->config, EGL_SURFACE_TYPE, &surface_type);
+            if (0 == (surface_type & EGL_SWAP_BEHAVIOR_PRESERVED_BIT)) {
+                setErrorReturn(EGL_BAD_MATCH, EGL_FALSE);
+            }
+        }
         return true;
         break;
     default:
         ALOGW("%s: attr=0x%x not implemented", __FUNCTION__, attribute);
+        setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_FALSE);
     }
     return false;
 }
@@ -908,14 +1192,126 @@ EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_c
     VALIDATE_DISPLAY_INIT(dpy, EGL_NO_CONTEXT);
     VALIDATE_CONFIG(config, EGL_NO_CONTEXT);
 
-    EGLint version = 1; //default
+    EGLint majorVersion = 1; //default
+    EGLint minorVersion = 0;
+    EGLint context_flags = 0;
+    EGLint profile_mask = 0;
+    EGLint reset_notification_strategy = 0;
+
+    bool wantedMajorVersion = false;
+    bool wantedMinorVersion = false;
+
     while (attrib_list && attrib_list[0] != EGL_NONE) {
-        if (attrib_list[0] == EGL_CONTEXT_CLIENT_VERSION) version = attrib_list[1];
+           EGLint attrib_val = attrib_list[1];
+        switch(attrib_list[0]) {
+        case EGL_CONTEXT_MAJOR_VERSION_KHR:
+            majorVersion = attrib_val;
+            wantedMajorVersion = true;
+            break;
+        case EGL_CONTEXT_MINOR_VERSION_KHR:
+            minorVersion = attrib_val;
+            wantedMinorVersion = true;
+            break;
+        case EGL_CONTEXT_FLAGS_KHR:
+            if ((attrib_val | EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) ||
+                (attrib_val | EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR)  ||
+                (attrib_val | EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR)) {
+                context_flags = attrib_val;
+            } else {
+                RETURN_ERROR(EGL_NO_CONTEXT,EGL_BAD_ATTRIBUTE);
+            }
+            break;
+        case EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR:
+            if ((attrib_val | EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR) ||
+                (attrib_val | EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR)) {
+                profile_mask = attrib_val;
+            } else {
+                RETURN_ERROR(EGL_NO_CONTEXT,EGL_BAD_ATTRIBUTE);
+            }
+            break;
+        case EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR:
+            switch (attrib_val) {
+            case EGL_NO_RESET_NOTIFICATION_KHR:
+            case EGL_LOSE_CONTEXT_ON_RESET_KHR:
+                break;
+            default:
+                RETURN_ERROR(EGL_NO_CONTEXT,EGL_BAD_ATTRIBUTE);
+            }
+            reset_notification_strategy = attrib_val;
+            break;
+        default:
+            setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_NO_CONTEXT);
+        }
         attrib_list+=2;
     }
 
-    // Currently only support GLES1 and 2
-    if (version != 1 && version != 2) {
+    // Support up to GLES 3.2 depending on advertised version from the host system.
+    DEFINE_AND_VALIDATE_HOST_CONNECTION(EGL_NO_CONTEXT);
+    if (rcEnc->getGLESMaxVersion() >= GLES_MAX_VERSION_3_0) {
+        if (!wantedMajorVersion) {
+            majorVersion = 1;
+            wantedMinorVersion = false;
+        }
+
+        if (wantedMajorVersion &&
+            majorVersion == 2) {
+            majorVersion = 3;
+            wantedMinorVersion = false;
+        }
+
+        if (majorVersion == 3 && !wantedMinorVersion) {
+            switch (rcEnc->getGLESMaxVersion()) {
+                case GLES_MAX_VERSION_3_0:
+                    minorVersion = 0;
+                    break;
+                case GLES_MAX_VERSION_3_1:
+                    minorVersion = 1;
+                    break;
+                case GLES_MAX_VERSION_3_2:
+                    minorVersion = 2;
+                    break;
+                default:
+                    minorVersion = 0;
+                    break;
+            }
+        }
+    } else {
+        if (!wantedMajorVersion) {
+            majorVersion = 1;
+        }
+    }
+
+    switch (majorVersion) {
+    case 1:
+    case 2:
+        break;
+    case 3:
+        if (rcEnc->getGLESMaxVersion() < GLES_MAX_VERSION_3_0) {
+            ALOGE("%s: EGL_BAD_CONFIG: no ES 3 support", __FUNCTION__);
+            setErrorReturn(EGL_BAD_CONFIG, EGL_NO_CONTEXT);
+        }
+        switch (minorVersion) {
+            case 0:
+                break;
+            case 1:
+                if (rcEnc->getGLESMaxVersion() < GLES_MAX_VERSION_3_1) {
+                    ALOGE("%s: EGL_BAD_CONFIG: no ES 3.1 support", __FUNCTION__);
+                    setErrorReturn(EGL_BAD_CONFIG, EGL_NO_CONTEXT);
+                }
+                break;
+            case 2:
+                if (rcEnc->getGLESMaxVersion() < GLES_MAX_VERSION_3_2) {
+                    ALOGE("%s: EGL_BAD_CONFIG: no ES 3.2 support", __FUNCTION__);
+                    setErrorReturn(EGL_BAD_CONFIG, EGL_NO_CONTEXT);
+                }
+                break;
+            default:
+                ALOGE("%s: EGL_BAD_CONFIG: Unknown ES version %d.%d",
+                      __FUNCTION__, majorVersion, minorVersion);
+                setErrorReturn(EGL_BAD_CONFIG, EGL_NO_CONTEXT);
+        }
+        break;
+    default:
         setErrorReturn(EGL_BAD_CONFIG, EGL_NO_CONTEXT);
     }
 
@@ -928,21 +1324,31 @@ EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_c
             setErrorReturn(EGL_BAD_MATCH, EGL_NO_CONTEXT);
     }
 
-    DEFINE_AND_VALIDATE_HOST_CONNECTION(EGL_NO_CONTEXT);
-    uint32_t rcContext = rcEnc->rcCreateContext(rcEnc, (uintptr_t)config, rcShareCtx, version);
+    // We've created EGL context. Disconnecting
+    // would be dangerous at this point.
+    hostCon->setGrallocOnly(false);
+
+    int rcMajorVersion = majorVersion;
+    if (majorVersion == 3 && minorVersion == 1) {
+        rcMajorVersion = 4;
+    }
+    if (majorVersion == 3 && minorVersion == 2) {
+        rcMajorVersion = 4;
+    }
+    uint32_t rcContext = rcEnc->rcCreateContext(rcEnc, (uintptr_t)config, rcShareCtx, rcMajorVersion);
     if (!rcContext) {
         ALOGE("rcCreateContext returned 0");
         setErrorReturn(EGL_BAD_ALLOC, EGL_NO_CONTEXT);
     }
 
-    EGLContext_t * context = new EGLContext_t(dpy, config, shareCtx);
-    if (!context)
+    EGLContext_t * context = new EGLContext_t(dpy, config, shareCtx, majorVersion, minorVersion);
+    ALOGD("%s: %p: maj %d min %d rcv %d", __FUNCTION__, context, majorVersion, minorVersion, rcMajorVersion);
+    if (!context) {
+        ALOGE("could not alloc egl context!");
         setErrorReturn(EGL_BAD_ALLOC, EGL_NO_CONTEXT);
+    }
 
-    context->version = version;
     context->rcContext = rcContext;
-
-
     return context;
 }
 
@@ -976,6 +1382,10 @@ EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLC
     VALIDATE_SURFACE_RETURN(draw, EGL_FALSE);
     VALIDATE_SURFACE_RETURN(read, EGL_FALSE);
 
+    // Only place to initialize the TLS destructor; any
+    // thread can suddenly jump in any eglMakeCurrent
+    setTlsDestructor((tlsDtorCallback)s_eglReleaseThreadImpl);
+
     if ((read == EGL_NO_SURFACE && draw == EGL_NO_SURFACE) && (ctx != EGL_NO_CONTEXT))
         setErrorReturn(EGL_BAD_MATCH, EGL_FALSE);
     if ((read != EGL_NO_SURFACE || draw != EGL_NO_SURFACE) && (ctx == EGL_NO_CONTEXT))
@@ -1008,7 +1418,8 @@ EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLC
     }
 
     if (context && (context->flags & EGLContext_t::IS_CURRENT) && (context != tInfo->currentContext)) {
-        //context is current to another thread
+        // context is current to another thread
+        ALOGE("%s: error: EGL_BAD_ACCESS: context %p current to another thread!\n", __FUNCTION__, context);
         setErrorReturn(EGL_BAD_ACCESS, EGL_FALSE);
     }
 
@@ -1020,12 +1431,68 @@ EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLC
 
     //Now make the local bind
     if (context) {
+
+        ALOGD("%s: %p: ver %d %d (tinfo %p)", __FUNCTION__, context, context->majorVersion, context->minorVersion, tInfo);
+        // This is a nontrivial context.
+        // The thread cannot be gralloc-only anymore.
+        hostCon->setGrallocOnly(false);
         context->draw = draw;
         context->read = read;
         context->flags |= EGLContext_t::IS_CURRENT;
-        //set the client state
-        if (context->version == 2) {
-            hostCon->gl2Encoder()->setClientState(context->getClientState());
+        GLClientState* contextState =
+            context->getClientState();
+
+        if (!hostCon->gl2Encoder()->isInitialized()) {
+            s_display.gles2_iface()->init();
+            hostCon->gl2Encoder()->setInitialized();
+            ClientAPIExts::initClientFuncs(s_display.gles2_iface(), 1);
+        }
+        if (contextState->needsInitFromCaps()) {
+            // Get caps for indexed buffers from host.
+            // Some need a current context.
+            int max_transform_feedback_separate_attribs = 0;
+            int max_uniform_buffer_bindings = 0;
+            int max_atomic_counter_buffer_bindings = 0;
+            int max_shader_storage_buffer_bindings = 0;
+            int max_vertex_attrib_bindings = 0;
+            int max_color_attachments = 1;
+            int max_draw_buffers = 1;
+            if (context->majorVersion > 2) {
+                s_display.gles2_iface()->getIntegerv(
+                        GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, &max_transform_feedback_separate_attribs);
+                s_display.gles2_iface()->getIntegerv(
+                        GL_MAX_UNIFORM_BUFFER_BINDINGS, &max_uniform_buffer_bindings);
+                if (context->minorVersion > 0) {
+                    s_display.gles2_iface()->getIntegerv(
+                            GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS, &max_atomic_counter_buffer_bindings);
+                    s_display.gles2_iface()->getIntegerv(
+                            GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS, &max_shader_storage_buffer_bindings);
+                    s_display.gles2_iface()->getIntegerv(
+                            GL_MAX_VERTEX_ATTRIB_BINDINGS, &max_vertex_attrib_bindings);
+                }
+                s_display.gles2_iface()->getIntegerv(
+                        GL_MAX_COLOR_ATTACHMENTS, &max_color_attachments);
+                s_display.gles2_iface()->getIntegerv(
+                        GL_MAX_DRAW_BUFFERS, &max_draw_buffers);
+            }
+            contextState->initFromCaps(
+                    max_transform_feedback_separate_attribs,
+                    max_uniform_buffer_bindings,
+                    max_atomic_counter_buffer_bindings,
+                    max_shader_storage_buffer_bindings,
+                    max_vertex_attrib_bindings,
+                    max_color_attachments,
+                    max_draw_buffers);
+        }
+
+        // set the client state and share group
+        if (context->majorVersion > 1) {
+            hostCon->gl2Encoder()->setClientStateMakeCurrent(
+                    contextState,
+                    context->majorVersion,
+                    context->minorVersion,
+                    context->deviceMajorVersion,
+                    context->deviceMinorVersion);
             hostCon->gl2Encoder()->setSharedGroup(context->getSharedGroup());
         }
         else {
@@ -1035,7 +1502,7 @@ EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLC
     }
     else if (tInfo->currentContext) {
         //release ClientState & SharedGroup
-        if (tInfo->currentContext->version == 2) {
+        if (tInfo->currentContext->majorVersion > 1) {
             hostCon->gl2Encoder()->setClientState(NULL);
             hostCon->gl2Encoder()->setSharedGroup(GLSharedGroupPtr(NULL));
         }
@@ -1054,12 +1521,16 @@ EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLC
 
     //Check maybe we need to init the encoder, if it's first eglMakeCurrent
     if (tInfo->currentContext) {
-        if (tInfo->currentContext->version == 2) {
+        if (tInfo->currentContext->majorVersion  > 1) {
             if (!hostCon->gl2Encoder()->isInitialized()) {
                 s_display.gles2_iface()->init();
                 hostCon->gl2Encoder()->setInitialized();
                 ClientAPIExts::initClientFuncs(s_display.gles2_iface(), 1);
             }
+            const char* exts = getGLString(GL_EXTENSIONS);
+            if (exts) {
+                hostCon->gl2Encoder()->setExtensions(exts);
+            }
         }
         else {
             if (!hostCon->glEncoder()->isInitialized()) {
@@ -1119,7 +1590,7 @@ EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGL
             *value = EGL_OPENGL_ES_API;
             break;
         case EGL_CONTEXT_CLIENT_VERSION:
-            *value = context->version;
+            *value = context->majorVersion;
             break;
         case EGL_RENDER_BUFFER:
             if (!context->draw)
@@ -1143,7 +1614,7 @@ EGLBoolean eglWaitGL()
         return EGL_FALSE;
     }
 
-    if (tInfo->currentContext->version == 2) {
+    if (tInfo->currentContext->majorVersion > 1) {
         s_display.gles2_iface()->finish();
     }
     else {
@@ -1172,10 +1643,10 @@ EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface eglSurface)
         setErrorReturn(EGL_BAD_DISPLAY, EGL_FALSE);
 
     // post the surface
-    d->swapBuffers();
+    EGLBoolean ret = d->swapBuffers();
 
     hostCon->flush();
-    return EGL_TRUE;
+    return ret;
 }
 
 EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
@@ -1230,6 +1701,7 @@ EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EG
             case HAL_PIXEL_FORMAT_RGBX_8888:
             case HAL_PIXEL_FORMAT_RGB_888:
             case HAL_PIXEL_FORMAT_RGB_565:
+            case HAL_PIXEL_FORMAT_YV12:
             case HAL_PIXEL_FORMAT_BGRA_8888:
                 break;
             default:
@@ -1299,17 +1771,107 @@ EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
 }
 
 #define FENCE_SYNC_HANDLE (EGLSyncKHR)0xFE4CE
+#define MAX_EGL_SYNC_ATTRIBS 10
 
 EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type,
         const EGLint *attrib_list)
 {
-    // TODO: This implementation could be faster. We should require the host EGL
-    // to support KHR_fence_sync, or at least pipe the fence command to the host
-    // and wait for it (probably involving a glFinish on the host) in
-    // eglClientWaitSyncKHR.
-
     VALIDATE_DISPLAY(dpy, EGL_NO_SYNC_KHR);
+    DPRINT("type for eglCreateSyncKHR: 0x%x", type);
+/*
+    DEFINE_HOST_CONNECTION;
+
+    if ((type != EGL_SYNC_FENCE_KHR &&
+         type != EGL_SYNC_NATIVE_FENCE_ANDROID) ||
+        (type != EGL_SYNC_FENCE_KHR &&
+         !rcEnc->hasNativeSync())) {
+        setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_NO_SYNC_KHR);
+    }
+
+    EGLThreadInfo *tInfo = getEGLThreadInfo();
+    if (!tInfo || !tInfo->currentContext) {
+        setErrorReturn(EGL_BAD_MATCH, EGL_NO_SYNC_KHR);
+    }
+
+    int num_actual_attribs = 0;
+
+    // If attrib_list is not NULL,
+    // ensure attrib_list contains (key, value) pairs
+    // followed by a single EGL_NONE.
+    // Also validate attribs.
+    int inputFenceFd = -1;
+    if (attrib_list) {
+        for (int i = 0; i < MAX_EGL_SYNC_ATTRIBS; i += 2) {
+            if (attrib_list[i] == EGL_NONE) {
+                num_actual_attribs = i;
+                break;
+            }
+            if (i + 1 == MAX_EGL_SYNC_ATTRIBS) {
+                DPRINT("ERROR: attrib list without EGL_NONE");
+                setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_NO_SYNC_KHR);
+            }
+        }
 
+        // Validate and input attribs
+        for (int i = 0; i < num_actual_attribs; i += 2) {
+            if (attrib_list[i] == EGL_SYNC_TYPE_KHR) {
+                DPRINT("ERROR: attrib key = EGL_SYNC_TYPE_KHR");
+            }
+            if (attrib_list[i] == EGL_SYNC_STATUS_KHR) {
+                DPRINT("ERROR: attrib key = EGL_SYNC_STATUS_KHR");
+            }
+            if (attrib_list[i] == EGL_SYNC_CONDITION_KHR) {
+                DPRINT("ERROR: attrib key = EGL_SYNC_CONDITION_KHR");
+            }
+            EGLint attrib_key = attrib_list[i];
+            EGLint attrib_val = attrib_list[i + 1];
+            if (attrib_key == EGL_SYNC_NATIVE_FENCE_FD_ANDROID) {
+                if (attrib_val != EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+                    inputFenceFd = attrib_val;
+                }
+            }
+            DPRINT("attrib: 0x%x : 0x%x", attrib_key, attrib_val);
+        }
+    }
+
+    uint64_t sync_handle = 0;
+    int newFenceFd = -1;
+
+    if (rcEnc->hasNativeSync()) {
+        sync_handle =
+            createNativeSync(type, attrib_list, num_actual_attribs,
+                             false,
+                             inputFenceFd,
+                             &newFenceFd);
+
+    } else {
+        // Just trigger a glFinish if the native sync on host
+        // is unavailable.
+        eglWaitClient();
+    }
+
+    EGLSync_t* syncRes = new EGLSync_t(sync_handle);
+
+    if (type == EGL_SYNC_NATIVE_FENCE_ANDROID) {
+        syncRes->type = EGL_SYNC_NATIVE_FENCE_ANDROID;
+
+        if (inputFenceFd < 0) {
+            syncRes->android_native_fence_fd = newFenceFd;
+        } else {
+            DPRINT("has input fence fd %d",
+                    inputFenceFd);
+            syncRes->android_native_fence_fd = inputFenceFd;
+        }
+    } else {
+        syncRes->type = EGL_SYNC_FENCE_KHR;
+        syncRes->android_native_fence_fd = -1;
+        if (!rcEnc->hasNativeSync()) {
+            syncRes->status = EGL_SIGNALED_KHR;
+        }
+    }
+
+    return (EGLSyncKHR)syncRes;
+*/
     if (type != EGL_SYNC_FENCE_KHR ||
             (attrib_list != NULL && attrib_list[0] != EGL_NONE)) {
         setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_NO_SYNC_KHR);
@@ -1320,7 +1882,7 @@ EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type,
         setErrorReturn(EGL_BAD_MATCH, EGL_NO_SYNC_KHR);
     }
 
-    if (tInfo->currentContext->version == 2) {
+    if (tInfo->currentContext->majorVersion >= 2) {
         s_display.gles2_iface()->finish();
     } else {
         s_display.gles_iface()->finish();
@@ -1329,21 +1891,74 @@ EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type,
     return FENCE_SYNC_HANDLE;
 }
 
-EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync)
+EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR eglsync)
 {
     (void)dpy;
+/*
+    if (!eglsync) {
+        DPRINT("WARNING: null sync object")
+        return EGL_TRUE;
+    }
 
+    EGLSync_t* sync = static_cast<EGLSync_t*>(eglsync);
+
+    if (sync && sync->android_native_fence_fd > 0) {
+        close(sync->android_native_fence_fd);
+        sync->android_native_fence_fd = -1;
+    }
+
+    if (sync) {
+        DEFINE_HOST_CONNECTION;
+        if (rcEnc->hasNativeSync()) {
+            rcEnc->rcDestroySyncKHR(rcEnc, sync->handle);
+        }
+        delete sync;
+    }
+*/
     if (sync != FENCE_SYNC_HANDLE) {
         setErrorReturn(EGL_BAD_PARAMETER, EGL_FALSE);
     }
-
     return EGL_TRUE;
 }
 
-EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags,
+EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR eglsync, EGLint flags,
         EGLTimeKHR timeout)
 {
     (void)dpy;
+/*
+    if (!eglsync) {
+        DPRINT("WARNING: null sync object");
+        return EGL_CONDITION_SATISFIED_KHR;
+    }
+
+    EGLSync_t* sync = (EGLSync_t*)eglsync;
+
+    DPRINT("sync=0x%lx (handle=0x%lx) flags=0x%x timeout=0x%llx",
+           sync, sync->handle, flags, timeout);
+
+    DEFINE_HOST_CONNECTION;
+
+    EGLint retval;
+    if (rcEnc->hasNativeSync()) {
+        retval = rcEnc->rcClientWaitSyncKHR
+            (rcEnc, sync->handle, flags, timeout);
+    } else {
+        retval = EGL_CONDITION_SATISFIED_KHR;
+    }
+    EGLint res_status;
+    switch (sync->type) {
+        case EGL_SYNC_FENCE_KHR:
+            res_status = EGL_SIGNALED_KHR;
+            break;
+        case EGL_SYNC_NATIVE_FENCE_ANDROID:
+            res_status = EGL_SYNC_NATIVE_FENCE_SIGNALED_ANDROID;
+            break;
+        default:
+            res_status = EGL_SIGNALED_KHR;
+    }
+    sync->status = res_status;
+    return retval;
+*/
     (void)flags;
     (void)timeout;
 
@@ -1354,21 +1969,19 @@ EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags,
     return EGL_CONDITION_SATISFIED_KHR;
 }
 
-EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
+EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR eglsync,
         EGLint attribute, EGLint *value)
 {
     (void)dpy;
 
-    if (sync != FENCE_SYNC_HANDLE) {
-        setErrorReturn(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
+    EGLSync_t* sync = (EGLSync_t*)eglsync;
 
     switch (attribute) {
     case EGL_SYNC_TYPE_KHR:
-        *value = EGL_SYNC_FENCE_KHR;
+        *value = sync->type;
         return EGL_TRUE;
     case EGL_SYNC_STATUS_KHR:
-        *value = EGL_SIGNALED_KHR;
+        *value = sync->status;
         return EGL_TRUE;
     case EGL_SYNC_CONDITION_KHR:
         *value = EGL_SYNC_PRIOR_COMMANDS_COMPLETE_KHR;
@@ -1377,3 +1990,25 @@ EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
         setErrorReturn(EGL_BAD_ATTRIBUTE, EGL_FALSE);
     }
 }
+
+int eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR eglsync) {
+    (void)dpy;
+
+    DPRINT("call");
+
+    EGLSync_t* sync = (EGLSync_t*)eglsync;
+    if (sync && sync->android_native_fence_fd > 0) {
+        int res = dup(sync->android_native_fence_fd);
+        return res;
+    } else {
+        return -1;
+    }
+}
+
+// TODO: Implement EGL_KHR_wait_sync
+EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR eglsync, EGLint flags) {
+    (void)dpy;
+    (void)eglsync;
+    (void)flags;
+    return EGL_TRUE;
+}
diff --git a/vendor/anbox/android/opengl/system/egl/eglContext.h b/vendor/anbox/android/opengl/system/egl/eglContext.h
index 5b6a428..0674833 100644
--- a/vendor/anbox/android/opengl/system/egl/eglContext.h
+++ b/vendor/anbox/android/opengl/system/egl/eglContext.h
@@ -26,7 +26,7 @@ struct EGLContext_t {
         NEVER_CURRENT   =   0x00020000
     };
 
-    EGLContext_t(EGLDisplay dpy, EGLConfig config, EGLContext_t* shareCtx);
+    EGLContext_t(EGLDisplay dpy, EGLConfig config, EGLContext_t* shareCtx, int maj, int min);
     ~EGLContext_t();
     uint32_t            flags;
     EGLDisplay          dpy;
@@ -34,9 +34,12 @@ struct EGLContext_t {
     EGLSurface          read;
     EGLSurface          draw;
     EGLContext_t    *   shareCtx;
-    EGLint                version;
-    uint32_t             rcContext;
+    uint32_t            rcContext;
     const char*         versionString;
+    EGLint              majorVersion;
+    EGLint              minorVersion;
+    EGLint              deviceMajorVersion;
+    EGLint              deviceMinorVersion;
     const char*         vendorString;
     const char*         rendererString;
     const char*         shaderVersionString;
@@ -44,9 +47,11 @@ struct EGLContext_t {
     EGLint              deletePending;
     GLClientState * getClientState(){ return clientState; }
     GLSharedGroupPtr getSharedGroup(){ return sharedGroup; }
+    int getGoldfishSyncFd();
 private:
     GLClientState    *    clientState;
     GLSharedGroupPtr      sharedGroup;
+    int goldfishSyncFd;
 };
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/egl/eglDisplay.cpp b/vendor/anbox/android/opengl/system/egl/eglDisplay.cpp
index 9340482..455af87 100644
--- a/vendor/anbox/android/opengl/system/egl/eglDisplay.cpp
+++ b/vendor/anbox/android/opengl/system/egl/eglDisplay.cpp
@@ -15,8 +15,12 @@
 */
 #include "eglDisplay.h"
 #include "HostConnection.h"
+#include "goldfishHwc2.h"
+
 #include <dlfcn.h>
 
+#include <string>
+
 static const int systemEGLVersionMajor = 1;
 static const int systemEGLVersionMinor = 4;
 static const char systemEGLVendor[] = "Google Android emulator";
@@ -29,6 +33,9 @@ static const char systemStaticEGLExtensions[] =
             "EGL_KHR_image_base "
             "EGL_KHR_gl_texture_2d_image ";
 
+// extensions to add dynamically depending on host-side support
+static const char kDynamicEGLExtNativeSync[] = "EGL_ANDROID_native_fence_sync ";
+
 static void *s_gles_lib = NULL;
 static void *s_gles2_lib = NULL;
 
@@ -209,6 +216,20 @@ void eglDisplay::terminate()
 {
     pthread_mutex_lock(&m_lock);
     if (m_initialized) {
+        // Cannot use the for loop in the following code because
+        // eglDestroyContext may erase elements.
+        EGLContextSet::iterator ctxIte = m_contexts.begin();
+        while (ctxIte != m_contexts.end()) {
+            EGLContextSet::iterator ctxToDelete = ctxIte;
+            ctxIte ++;
+            eglDestroyContext(static_cast<EGLDisplay>(this), *ctxToDelete);
+        }
+        EGLSurfaceSet::iterator surfaceIte = m_surfaces.begin();
+        while (surfaceIte != m_surfaces.end()) {
+            EGLSurfaceSet::iterator surfaceToDelete = surfaceIte;
+            surfaceIte ++;
+            eglDestroySurface(static_cast<EGLDisplay>(this), *surfaceToDelete);
+        }
         m_initialized = false;
         delete [] m_configs;
         m_configs = NULL;
@@ -258,14 +279,10 @@ static char *queryHostEGLString(EGLint name)
         if (rcEnc) {
             int n = rcEnc->rcQueryEGLString(rcEnc, name, NULL, 0);
             if (n < 0) {
-                // allocate space for the string with additional
-                // space charachter to be suffixed at the end.
-                char *str = (char *)malloc(-n+2);
+                // allocate space for the string.
+                char *str = (char *)malloc(-n);
                 n = rcEnc->rcQueryEGLString(rcEnc, name, str, -n);
                 if (n > 0) {
-                    // add extra space at end of string which will be
-                    // needed later when filtering the extension list.
-                    strcat(str, " ");
                     return str;
                 }
 
@@ -389,8 +406,28 @@ EGLBoolean eglDisplay::getAttribValue(EGLConfig config, EGLint attribIdx, EGLint
     return EGL_TRUE;
 }
 
+#define EGL_COLOR_COMPONENT_TYPE_EXT 0x3339
+#define EGL_COLOR_COMPONENT_TYPE_FIXED_EXT 0x333A
+
 EGLBoolean eglDisplay::getConfigAttrib(EGLConfig config, EGLint attrib, EGLint * value)
 {
+    if (attrib == EGL_FRAMEBUFFER_TARGET_ANDROID) {
+        *value = EGL_TRUE;
+        return EGL_TRUE;
+    }
+    if (attrib == EGL_COVERAGE_SAMPLES_NV ||
+        attrib == EGL_COVERAGE_BUFFERS_NV) {
+        *value = 0;
+        return EGL_TRUE;
+    }
+    if (attrib == EGL_DEPTH_ENCODING_NV) {
+        *value = EGL_DEPTH_ENCODING_NONE_NV;
+        return EGL_TRUE;
+    }
+    if  (attrib == EGL_COLOR_COMPONENT_TYPE_EXT) {
+        *value = EGL_COLOR_COMPONENT_TYPE_FIXED_EXT;
+        return EGL_TRUE;
+    }
     //Though it seems that valueFor() is thread-safe, we don't take chanses
     pthread_mutex_lock(&m_lock);
     EGLBoolean ret = getAttribValue(config, m_attribs.valueFor(attrib), value);
@@ -483,3 +520,28 @@ EGLBoolean eglDisplay::getConfigGLPixelFormat(EGLConfig config, GLenum * format)
 
     return EGL_TRUE;
 }
+
+void eglDisplay::onCreateContext(EGLContext ctx) {
+    pthread_mutex_lock(&m_ctxLock);
+    m_contexts.insert(ctx);
+    pthread_mutex_unlock(&m_ctxLock);
+}
+
+void eglDisplay::onCreateSurface(EGLSurface surface) {
+    pthread_mutex_lock(&m_surfaceLock);
+    m_surfaces.insert(surface);
+    pthread_mutex_unlock(&m_surfaceLock);
+}
+
+void eglDisplay::onDestroyContext(EGLContext ctx) {
+    pthread_mutex_lock(&m_ctxLock);
+    m_contexts.erase(ctx);
+    pthread_mutex_unlock(&m_ctxLock);
+}
+
+void eglDisplay::onDestroySurface(EGLSurface surface) {
+    pthread_mutex_lock(&m_surfaceLock);
+    m_surfaces.erase(surface);
+    pthread_mutex_unlock(&m_surfaceLock);
+}
+
diff --git a/vendor/anbox/android/opengl/system/egl/eglDisplay.h b/vendor/anbox/android/opengl/system/egl/eglDisplay.h
index 9d979d9..ba39201 100644
--- a/vendor/anbox/android/opengl/system/egl/eglDisplay.h
+++ b/vendor/anbox/android/opengl/system/egl/eglDisplay.h
@@ -23,9 +23,16 @@
 #include "EGLClientIface.h"
 #include <utils/KeyedVector.h>
 
+#if __cplusplus >= 201103L
+#include <unordered_set>
+#else
+#include <hash_set>
+#endif
+
+
 #include <ui/PixelFormat.h>
 
-#define ATTRIBUTE_NONE -1
+#define ATTRIBUTE_NONE (-1)
 //FIXME: are we in this namespace?
 using namespace android;
 
@@ -54,6 +61,12 @@ public:
     EGLBoolean getConfigNativePixelFormat(EGLConfig config, PixelFormat * format);
 
     void     dumpConfig(EGLConfig config);
+
+    void onCreateContext(EGLContext ctx);
+    void onCreateSurface(EGLSurface surface);
+
+    void onDestroyContext(EGLContext ctx);
+    void onDestroySurface(EGLSurface surface);
 private:
     EGLClient_glesInterface *loadGLESClientAPI(const char *libName,
                                                EGLClient_eglInterface *eglIface,
@@ -84,6 +97,18 @@ private:
     char *m_versionString;
     char *m_vendorString;
     char *m_extensionString;
+
+#if __cplusplus >= 201103L
+    typedef std::unordered_set<EGLContext> EGLContextSet;
+    typedef std::unordered_set<EGLSurface> EGLSurfaceSet;
+#else
+    typedef std::hash_set<EGLContext> EGLContextSet;
+    typedef std::hash_set<EGLSurface> EGLSurfaceSet;
+#endif
+    EGLContextSet m_contexts;
+    EGLSurfaceSet m_surfaces;
+    pthread_mutex_t m_ctxLock;
+    pthread_mutex_t m_surfaceLock;
 };
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/egl/eglSync.h b/vendor/anbox/android/opengl/system/egl/eglSync.h
new file mode 100644
index 0000000..9f84a4e
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/egl/eglSync.h
@@ -0,0 +1,42 @@
+/*
+* Copyright (C) 2016 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef _EGL_SYNC_H
+#define _EGL_SYNC_H
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <inttypes.h>
+
+// EGLSync_t is our driver's internal representation
+// of EGLSyncKHR objects.
+// The components are:
+// a. handle: reference host sync objects
+// b. android_native_fence_fd: for ANDROID_native_fence_sync
+// when we want to wrap native fence fd's in EGLSyncKHR's
+// c. type/status: track status of fence so SyncAttrib works
+struct EGLSync_t {
+    EGLSync_t(uint64_t handle_in) :
+        handle(handle_in), android_native_fence_fd(-1),
+        type(EGL_SYNC_FENCE_KHR),
+        status(EGL_UNSIGNALED_KHR) { }
+    uint64_t handle;
+    int android_native_fence_fd;
+    EGLint type;
+    EGLint status;
+};
+
+#endif
diff --git a/vendor/anbox/android/opengl/system/egl/goldfish_sync.h b/vendor/anbox/android/opengl/system/egl/goldfish_sync.h
new file mode 100644
index 0000000..4667a77
--- /dev/null
+++ b/vendor/anbox/android/opengl/system/egl/goldfish_sync.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef ANDROID_INCLUDE_HARDWARE_GOLDFISH_SYNC_H
+#define ANDROID_INCLUDE_HARDWARE_GOLDFISH_SYNC_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <sys/cdefs.h>
+#include <fcntl.h>
+
+// Make it conflict with ioctls that are not likely to be used
+// in the emulator.
+//
+// '@'	00-0F	linux/radeonfb.h	conflict!
+// '@'	00-0F	drivers/video/aty/aty128fb.c	conflict!
+#define GOLDFISH_SYNC_IOC_MAGIC	'@'
+
+struct goldfish_sync_ioctl_info {
+    uint64_t host_glsync_handle_in;
+    uint64_t host_syncthread_handle_in;
+    int fence_fd_out;
+};
+
+#define GOLDFISH_SYNC_IOC_QUEUE_WORK	_IOWR(GOLDFISH_SYNC_IOC_MAGIC, 0, struct goldfish_sync_ioctl_info)
+
+static __inline__ int goldfish_sync_open() {
+    return open("/dev/goldfish_sync", O_RDWR);
+}
+
+static __inline__ int goldfish_sync_close(int sync_fd) {
+    return close(sync_fd);
+}
+
+static __inline__ int goldfish_sync_queue_work(int goldfish_sync_fd,
+                                                uint64_t host_glsync,
+                                                uint64_t host_thread,
+                                                int* fd_out) {
+
+    struct goldfish_sync_ioctl_info info;
+    int err;
+
+    info.host_glsync_handle_in = host_glsync;
+    info.host_syncthread_handle_in = host_thread;
+    info.fence_fd_out = -1;
+
+    err = ioctl(goldfish_sync_fd, GOLDFISH_SYNC_IOC_QUEUE_WORK, &info);
+
+    if (fd_out) *fd_out = info.fence_fd_out;
+
+    return err;
+}
+
+#endif
diff --git a/vendor/anbox/android/opengl/system/gralloc/Android.mk b/vendor/anbox/android/opengl/system/gralloc/Android.mk
index 71ac2f2..190bfd6 100644
--- a/vendor/anbox/android/opengl/system/gralloc/Android.mk
+++ b/vendor/anbox/android/opengl/system/gralloc/Android.mk
@@ -2,11 +2,12 @@ ifneq (false,$(BUILD_EMULATOR_OPENGL_DRIVER))
 
 LOCAL_PATH := $(call my-dir)
 
-$(call emugl-begin-shared-library,gralloc.goldfish)
-$(call emugl-import,libGLESv1_enc lib_renderControl_enc libOpenglSystemCommon)
-$(call emugl-set-shared-library-subpath,hw)
+define gralloc_recipe
+$$(call emugl-begin-shared-library,gralloc.$(1))
+$$(call emugl-import,libGLESv1_enc lib_renderControl_enc libOpenglSystemCommon)
+$$(call emugl-set-shared-library-subpath,hw)
 
-LOCAL_CFLAGS += -DLOG_TAG=\"gralloc_goldfish\"
+LOCAL_CFLAGS += -DLOG_TAG=\"gralloc_$(1)\"
 LOCAL_CFLAGS += -Wno-missing-field-initializers
 
 LOCAL_SRC_FILES := gralloc.cpp
@@ -15,6 +16,13 @@ LOCAL_SRC_FILES := gralloc.cpp
 LOCAL_C_INCLUDES += bionic/libc/private
 LOCAL_SHARED_LIBRARIES += libdl
 
-$(call emugl-end-module)
+$$(call emugl-end-module)
+endef  # define gralloc_recipe
+
+$(eval $(call gralloc_recipe,goldfish))
+$(eval $(call gralloc_recipe,ranchu))
+ifeq ($(TARGET_BOARD_PLATFORM),brilloemulator)
+$(eval $(call gralloc_recipe,$(TARGET_BOARD_PLATFORM)))
+endif  # defined(BRILLO)
 
 endif # BUILD_EMULATOR_OPENGL_DRIVER != false
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.attrib b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.attrib
index 0fa0469..fbf52f7 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.attrib
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.attrib
@@ -43,3 +43,13 @@ rcUpdateColorBuffer
 rcCloseColorBuffer
     flag flushOnEncode
 
+rcCloseColorBufferPuid
+    flag flushOnEncode
+
+rcCreateSyncKHR
+    dir attribs in
+    len attribs num_attribs
+    dir glsync_out out
+    len glsync_out sizeof(uint64_t)
+    dir syncthread_out out
+    len syncthread_out sizeof(uint64_t)
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.in b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.in
index 47b8533..8be1886 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.in
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.in
@@ -27,9 +27,11 @@ GL_ENTRY(int, rcOpenColorBuffer2, uint32_t colorbuffer)
 GL_ENTRY(uint32_t, rcCreateClientImage, uint32_t context, EGLenum target, GLuint buffer)
 GL_ENTRY(int, rcDestroyClientImage, uint32_t image)
 GL_ENTRY(void, rcSelectChecksumHelper, uint32_t newProtocol, uint32_t reserved)
-GL_ENTRY(int, rcGetNumDisplays)
-GL_ENTRY(int, rcGetDisplayWidth, uint32_t displayId)
-GL_ENTRY(int, rcGetDisplayHeight, uint32_t displayId)
-GL_ENTRY(int, rcGetDisplayDpiX, uint32_t displayId)
-GL_ENTRY(int, rcGetDisplayDpiY, uint32_t displayId)
-GL_ENTRY(int, rcGetDisplayVsyncPeriod, uint32_t displayId)
+GL_ENTRY(uint32_t, rcCreateColorBufferPuid, uint32_t width, uint32_t height, GLenum internalFormat, uint64_t puid)
+GL_ENTRY(int, rcOpenColorBuffer2Puid, uint32_t colorbuffer, uint64_t puid)
+GL_ENTRY(void, rcCloseColorBufferPuid, uint32_t colorbuffer, uint64_t puid)
+GL_ENTRY(void, rcCreateSyncKHR, EGLenum type, EGLint* attribs, uint32_t num_attribs, uint64_t* glsync_out, uint64_t* syncthread_out)
+GL_ENTRY(EGLint, rcClientWaitSyncKHR, uint64_t sync, EGLint flags, uint64_t timeout)
+GL_ENTRY(void, rcFlushWindowColorBufferAsync, uint32_t windowSurface)
+GL_ENTRY(uint32_t, rcCreateClientImagePuid, uint32_t context, EGLenum target, GLuint buffer, uint64_t puid)
+GL_ENTRY(int, rcDestroyClientImagePuid, uint32_t image, uint64_t puid)
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.types b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.types
index a7d96ab..578492b 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.types
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl.types
@@ -1,11 +1,14 @@
-uint32_t 32 0x%08x false
-EGLint 32 0x%08x false
-GLint 32 0x%08x false
-GLuint 32 0x%08x false
-GLenum 32 0x%08x false
-EGLenum 32 0x%08x false
-uint32_t* 32 0x%08x true
-EGLint* 32 0x%08x true
-GLint* 32 0x%08x true
-GLuint* 32 0x%08x true
-void* 32 0x%08x true
+uint32_t 32 0x%08x
+uint64_t 64 0x%016lx
+EGLint 32 0x%08x
+GLint 32 0x%08x
+GLuint 32 0x%08x
+GLenum 32 0x%08x
+EGLenum 32 0x%08x
+uint32_t* 32 0x%08x
+EGLint* 32 0x%08x
+int* 32 0x%08x
+GLint* 32 0x%08x
+GLuint* 32 0x%08x
+void* 32 0x%08x
+uint64_t* 32 0x%08x
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.cpp b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.cpp
index 34ae4f8..c314fbc 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.cpp
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.cpp
@@ -38,15 +38,23 @@ int renderControl_client_context_t::initDispatchByName(void *(*getProc)(const ch
 	rcOpenColorBuffer2 = (rcOpenColorBuffer2_client_proc_t) getProc("rcOpenColorBuffer2", userData);
 	rcCreateClientImage = (rcCreateClientImage_client_proc_t) getProc("rcCreateClientImage", userData);
 	rcDestroyClientImage = (rcDestroyClientImage_client_proc_t) getProc("rcDestroyClientImage", userData);
-	rcSelectChecksumCalculator = (rcSelectChecksumCalculator_client_proc_t) getProc("rcSelectChecksumCalculator", userData);
-	rcGetNumDisplays = (rcGetNumDisplays_client_proc_t) getProc("rcGetNumDisplays", userData);
-	rcGetDisplayWidth = (rcGetDisplayWidth_client_proc_t) getProc("rcGetDisplayWidth", userData);
-	rcGetDisplayHeight = (rcGetDisplayHeight_client_proc_t) getProc("rcGetDisplayHeight", userData);
-	rcGetDisplayDpiX = (rcGetDisplayDpiX_client_proc_t) getProc("rcGetDisplayDpiX", userData);
-	rcGetDisplayDpiY = (rcGetDisplayDpiY_client_proc_t) getProc("rcGetDisplayDpiY", userData);
-	rcGetDisplayVsyncPeriod = (rcGetDisplayVsyncPeriod_client_proc_t) getProc("rcGetDisplayVsyncPeriod", userData);
-	rcPostLayer = (rcPostLayer_client_proc_t) getProc("rcPostLayer", userData);
-	rcPostAllLayersDone = (rcPostAllLayersDone_client_proc_t) getProc("rcPostAllLayersDone", userData);
+//	rcSelectChecksumHelper = (rcSelectChecksumHelper_client_proc_t) getProc("rcSelectChecksumHelper", userData);
+//	rcCreateSyncKHR = (rcCreateSyncKHR_client_proc_t) getProc("rcCreateSyncKHR", userData);
+//	rcClientWaitSyncKHR = (rcClientWaitSyncKHR_client_proc_t) getProc("rcClientWaitSyncKHR", userData);
+//	rcFlushWindowColorBufferAsync = (rcFlushWindowColorBufferAsync_client_proc_t) getProc("rcFlushWindowColorBufferAsync", userData);
+//	rcDestroySyncKHR = (rcDestroySyncKHR_client_proc_t) getProc("rcDestroySyncKHR", userData);
+//	rcSetPuid = (rcSetPuid_client_proc_t) getProc("rcSetPuid", userData);
+        rcSelectChecksumCalculator = (rcSelectChecksumCalculator_client_proc_t) getProc("rcSelectChecksumCalculator", userData);
+        rcGetNumDisplays = (rcGetNumDisplays_client_proc_t) getProc("rcGetNumDisplays", userData);
+        rcGetDisplayWidth = (rcGetDisplayWidth_client_proc_t) getProc("rcGetDisplayWidth", userData);
+        rcGetDisplayHeight = (rcGetDisplayHeight_client_proc_t) getProc("rcGetDisplayHeight", userData);
+        rcGetDisplayDpiX = (rcGetDisplayDpiX_client_proc_t) getProc("rcGetDisplayDpiX", userData);
+        rcGetDisplayDpiY = (rcGetDisplayDpiY_client_proc_t) getProc("rcGetDisplayDpiY", userData);
+        rcGetDisplayVsyncPeriod = (rcGetDisplayVsyncPeriod_client_proc_t) getProc("rcGetDisplayVsyncPeriod", userData);
+        rcPostLayer = (rcPostLayer_client_proc_t) getProc("rcPostLayer", userData);
+        rcPostAllLayersDone = (rcPostAllLayersDone_client_proc_t) getProc("rcPostAllLayersDone", userData);
+	rcUpdateColorBufferDMA = (rcUpdateColorBufferDMA_client_proc_t) getProc("rcUpdateColorBufferDMA", userData);
+	rcCreateColorBufferDMA = (rcCreateColorBufferDMA_client_proc_t) getProc("rcCreateColorBufferDMA", userData);
 	return 0;
 }
 
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.h b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.h
index a6408c1..30f8c2d 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.h
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_context.h
@@ -38,16 +38,24 @@ struct renderControl_client_context_t {
 	rcOpenColorBuffer2_client_proc_t rcOpenColorBuffer2;
 	rcCreateClientImage_client_proc_t rcCreateClientImage;
 	rcDestroyClientImage_client_proc_t rcDestroyClientImage;
-	rcSelectChecksumCalculator_client_proc_t rcSelectChecksumCalculator;
-	rcGetNumDisplays_client_proc_t rcGetNumDisplays;
-	rcGetDisplayWidth_client_proc_t rcGetDisplayWidth;
-	rcGetDisplayHeight_client_proc_t rcGetDisplayHeight;
-	rcGetDisplayDpiX_client_proc_t rcGetDisplayDpiX;
-	rcGetDisplayDpiY_client_proc_t rcGetDisplayDpiY;
-	rcGetDisplayVsyncPeriod_client_proc_t rcGetDisplayVsyncPeriod;
-	rcPostLayer_client_proc_t rcPostLayer;
-	rcPostAllLayersDone_client_proc_t rcPostAllLayersDone;
-	 virtual ~renderControl_client_context_t() {}
+//	rcSelectChecksumHelper_client_proc_t rcSelectChecksumHelper;
+//	rcCreateSyncKHR_client_proc_t rcCreateSyncKHR;
+//	rcClientWaitSyncKHR_client_proc_t rcClientWaitSyncKHR;
+//	rcFlushWindowColorBufferAsync_client_proc_t rcFlushWindowColorBufferAsync;
+//	rcDestroySyncKHR_client_proc_t rcDestroySyncKHR;
+//	rcSetPuid_client_proc_t rcSetPuid;
+        rcSelectChecksumCalculator_client_proc_t rcSelectChecksumCalculator;
+        rcGetNumDisplays_client_proc_t rcGetNumDisplays;
+        rcGetDisplayWidth_client_proc_t rcGetDisplayWidth;
+        rcGetDisplayHeight_client_proc_t rcGetDisplayHeight;
+        rcGetDisplayDpiX_client_proc_t rcGetDisplayDpiX;
+        rcGetDisplayDpiY_client_proc_t rcGetDisplayDpiY;
+        rcGetDisplayVsyncPeriod_client_proc_t rcGetDisplayVsyncPeriod;
+        rcPostLayer_client_proc_t rcPostLayer;
+        rcPostAllLayersDone_client_proc_t rcPostAllLayersDone;
+	rcUpdateColorBufferDMA_client_proc_t rcUpdateColorBufferDMA;
+	rcCreateColorBufferDMA_client_proc_t rcCreateColorBufferDMA;
+	virtual ~renderControl_client_context_t() {}
 
 	typedef renderControl_client_context_t *CONTEXT_ACCESSOR_TYPE(void);
 	static void setContextAccessor(CONTEXT_ACCESSOR_TYPE *f);
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_proc.h b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_proc.h
index 565fd12..0101a6e 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_proc.h
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_client_proc.h
@@ -37,6 +37,12 @@ typedef int (renderControl_APIENTRY *rcUpdateColorBuffer_client_proc_t) (void *
 typedef int (renderControl_APIENTRY *rcOpenColorBuffer2_client_proc_t) (void * ctx, uint32_t);
 typedef uint32_t (renderControl_APIENTRY *rcCreateClientImage_client_proc_t) (void * ctx, uint32_t, EGLenum, GLuint);
 typedef int (renderControl_APIENTRY *rcDestroyClientImage_client_proc_t) (void * ctx, uint32_t);
+//typedef void (renderControl_APIENTRY *rcSelectChecksumHelper_client_proc_t) (void * ctx, uint32_t, uint32_t);
+//typedef void (renderControl_APIENTRY *rcCreateSyncKHR_client_proc_t) (void * ctx, EGLenum, EGLint*, uint32_t, int, uint64_t*, uint64_t*);
+//typedef EGLint (renderControl_APIENTRY *rcClientWaitSyncKHR_client_proc_t) (void * ctx, uint64_t, EGLint, uint64_t);
+//typedef void (renderControl_APIENTRY *rcFlushWindowColorBufferAsync_client_proc_t) (void * ctx, uint32_t);
+//typedef int (renderControl_APIENTRY *rcDestroySyncKHR_client_proc_t) (void * ctx, uint64_t);
+//typedef void (renderControl_APIENTRY *rcSetPuid_client_proc_t) (void * ctx, uint64_t);
 typedef void (renderControl_APIENTRY *rcSelectChecksumCalculator_client_proc_t) (void * ctx, uint32_t, uint32_t);
 typedef int (renderControl_APIENTRY *rcGetNumDisplays_client_proc_t) (void * ctx);
 typedef int (renderControl_APIENTRY *rcGetDisplayWidth_client_proc_t) (void * ctx, uint32_t);
@@ -46,6 +52,8 @@ typedef int (renderControl_APIENTRY *rcGetDisplayDpiY_client_proc_t) (void * ctx
 typedef int (renderControl_APIENTRY *rcGetDisplayVsyncPeriod_client_proc_t) (void * ctx, uint32_t);
 typedef void (renderControl_APIENTRY *rcPostLayer_client_proc_t) (void * ctx, const char*, uint32_t, float, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);
 typedef void (renderControl_APIENTRY *rcPostAllLayersDone_client_proc_t) (void * ctx);
+typedef int (renderControl_APIENTRY *rcUpdateColorBufferDMA_client_proc_t) (void * ctx, uint32_t, GLint, GLint, GLint, GLint, GLenum, GLenum, void*, uint32_t);
+typedef uint32_t (renderControl_APIENTRY *rcCreateColorBufferDMA_client_proc_t) (void * ctx, uint32_t, uint32_t, GLenum, int);
 
 
 #endif
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.cpp b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.cpp
index 4a22b54..b5bb8e9 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.cpp
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.cpp
@@ -2,7 +2,6 @@
 // generated by 'emugen'
 
 
-#include <memory>
 #include <string.h>
 #include "renderControl_opcodes.h"
 
@@ -45,9 +44,11 @@ GLint rcGetRendererVersion_enc(void *self )
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcGetRendererVersion: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -67,7 +68,7 @@ EGLint rcGetEGLVersion_enc(void *self , EGLint* major, EGLint* minor)
 	const unsigned int __size_minor =  sizeof(EGLint);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_major + __size_minor + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 0 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -90,9 +91,11 @@ EGLint rcGetEGLVersion_enc(void *self , EGLint* major, EGLint* minor)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcGetEGLVersion: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -111,7 +114,7 @@ EGLint rcQueryEGLString_enc(void *self , EGLenum name, void* buffer, EGLint buff
 	const unsigned int __size_buffer =  bufferSize;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffer + 4 + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 4 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -133,9 +136,11 @@ EGLint rcQueryEGLString_enc(void *self , EGLenum name, void* buffer, EGLint buff
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcQueryEGLString: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -154,7 +159,7 @@ EGLint rcGetGLString_enc(void *self , EGLenum name, void* buffer, EGLint bufferS
 	const unsigned int __size_buffer =  bufferSize;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffer + 4 + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 4 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -176,9 +181,11 @@ EGLint rcGetGLString_enc(void *self , EGLenum name, void* buffer, EGLint bufferS
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcGetGLString: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -197,7 +204,7 @@ EGLint rcGetNumConfigs_enc(void *self , uint32_t* numAttribs)
 	const unsigned int __size_numAttribs =  sizeof(uint32_t);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_numAttribs + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -217,9 +224,11 @@ EGLint rcGetNumConfigs_enc(void *self , uint32_t* numAttribs)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcGetNumConfigs: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -238,7 +247,7 @@ EGLint rcGetConfigs_enc(void *self , uint32_t bufSize, GLuint* buffer)
 	const unsigned int __size_buffer =  bufSize;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffer + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -259,9 +268,11 @@ EGLint rcGetConfigs_enc(void *self , uint32_t bufSize, GLuint* buffer)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcGetConfigs: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -281,7 +292,7 @@ EGLint rcChooseConfig_enc(void *self , EGLint* attribs, uint32_t attribs_size, u
 	const unsigned int __size_configs = ((configs != NULL) ?  configs_size*sizeof(uint32_t) : 0);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_attribs + 4 + __size_configs + 4 + 2*4;
+	 const size_t sizeWithoutChecksum = 8 + __size_attribs + 4 + 0 + 4 + 2*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -307,9 +318,11 @@ EGLint rcChooseConfig_enc(void *self , EGLint* attribs, uint32_t attribs_size, u
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcChooseConfig: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -345,9 +358,11 @@ EGLint rcGetFBParam_enc(void *self , EGLint param)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcGetFBParam: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -385,9 +400,11 @@ uint32_t rcCreateContext_enc(void *self , uint32_t config, uint32_t share, uint3
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcCreateContext: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -450,9 +467,11 @@ uint32_t rcCreateWindowSurface_enc(void *self , uint32_t config, uint32_t width,
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcCreateWindowSurface: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -515,9 +534,11 @@ uint32_t rcCreateColorBuffer_enc(void *self , uint32_t width, uint32_t height, G
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcCreateColorBuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -630,9 +651,11 @@ int rcFlushWindowColorBuffer_enc(void *self , uint32_t windowSurface)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcFlushWindowColorBuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -670,9 +693,11 @@ EGLint rcMakeCurrent_enc(void *self , uint32_t context, uint32_t drawSurf, uint3
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcMakeCurrent: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -810,9 +835,11 @@ EGLint rcColorBufferCacheFlush_enc(void *self , uint32_t colorbuffer, EGLint pos
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcColorBufferCacheFlush: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -831,7 +858,7 @@ void rcReadColorBuffer_enc(void *self , uint32_t colorbuffer, GLint x, GLint y,
 	const unsigned int __size_pixels =  (((glUtilsPixelBitSize(format, type) * width) >> 3) * height);
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
@@ -854,9 +881,11 @@ void rcReadColorBuffer_enc(void *self , uint32_t colorbuffer, GLint x, GLint y,
 	stream->readback(pixels, __size_pixels);
 	if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcReadColorBuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -904,9 +933,11 @@ int rcUpdateColorBuffer_enc(void *self , uint32_t colorbuffer, GLint x, GLint y,
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcUpdateColorBuffer: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -942,9 +973,11 @@ int rcOpenColorBuffer2_enc(void *self , uint32_t colorbuffer)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcOpenColorBuffer2: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -982,9 +1015,11 @@ uint32_t rcCreateClientImage_enc(void *self , uint32_t context, EGLenum target,
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcCreateClientImage: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1020,9 +1055,11 @@ int rcDestroyClientImage_enc(void *self , uint32_t image)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
 			ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
@@ -1033,181 +1070,332 @@ int rcDestroyClientImage_enc(void *self , uint32_t image)
 void rcSelectChecksumCalculator_enc(void *self , uint32_t newProtocol, uint32_t reserved)
 {
 
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
 
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcSelectChecksumCalculator;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + 4 + 4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcSelectChecksumCalculator;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
 
-		memcpy(ptr, &newProtocol, 4); ptr += 4;
-		memcpy(ptr, &reserved, 4); ptr += 4;
+                memcpy(ptr, &newProtocol, 4); ptr += 4;
+                memcpy(ptr, &reserved, 4); ptr += 4;
 
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
 
 }
 
 int rcGetNumDisplays_enc(void *self )
 {
 
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
-
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcGetNumDisplays;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
-
-
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
-
-
-	int retval;
-	stream->readback(&retval, 4);
-	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
-	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
-			ALOGE("rcGetNumDisplays: GL communication error, please report this issue to b.android.com.\n");
-			abort();
-		}
-	}
-	return retval;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcGetNumDisplays;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+        int retval;
+        stream->readback(&retval, 4);
+        if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+        if (useChecksum) {
+                unsigned char *checksumBufPtr = NULL;
+                unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+                if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+                stream->readback(checksumBufPtr, checksumSize);
+                if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+                    ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
+                    abort();
+                }
+        }
+        return retval;
 }
 
 int rcGetDisplayWidth_enc(void *self , uint32_t displayId)
 {
 
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
-
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcGetDisplayWidth;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + 4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcGetDisplayWidth;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+                memcpy(ptr, &displayId, 4); ptr += 4;
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+        int retval;
+        stream->readback(&retval, 4);
+        if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+        if (useChecksum) {
+                unsigned char *checksumBufPtr = NULL;
+                unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+                if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+                stream->readback(checksumBufPtr, checksumSize);
+                if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+                    ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
+                    abort();
+                }
+        }
+        return retval;
+}
 
-		memcpy(ptr, &displayId, 4); ptr += 4;
+int rcGetDisplayHeight_enc(void *self , uint32_t displayId)
+{
 
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + 4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcGetDisplayHeight;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+                memcpy(ptr, &displayId, 4); ptr += 4;
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+        int retval;
+        stream->readback(&retval, 4);
+        if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+        if (useChecksum) {
+                unsigned char *checksumBufPtr = NULL;
+                unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+                if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+                stream->readback(checksumBufPtr, checksumSize);
+                if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+                    ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
+                    abort();
+                }
+        }
+        return retval;
+}
 
+int rcGetDisplayDpiX_enc(void *self , uint32_t displayId)
+{
 
-	int retval;
-	stream->readback(&retval, 4);
-	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
-	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
-			ALOGE("rcGetDisplayWidth: GL communication error, please report this issue to b.android.com.\n");
-			abort();
-		}
-	}
-	return retval;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + 4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcGetDisplayDpiX;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+                memcpy(ptr, &displayId, 4); ptr += 4;
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+        int retval;
+        stream->readback(&retval, 4);
+        if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+        if (useChecksum) {
+                unsigned char *checksumBufPtr = NULL;
+                unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+                if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+                stream->readback(checksumBufPtr, checksumSize);
+                if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+                    ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
+                    abort();
+                }
+        }
+        return retval;
 }
 
-int rcGetDisplayHeight_enc(void *self , uint32_t displayId)
+int rcGetDisplayDpiY_enc(void *self , uint32_t displayId)
 {
 
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + 4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcGetDisplayDpiY;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+                memcpy(ptr, &displayId, 4); ptr += 4;
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+        int retval;
+        stream->readback(&retval, 4);
+        if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+        if (useChecksum) {
+                unsigned char *checksumBufPtr = NULL;
+                unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+                if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+                stream->readback(checksumBufPtr, checksumSize);
+                if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+                    ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
+                    abort();
+                }
+        }
+        return retval;
+}
 
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcGetDisplayHeight;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
+int rcGetDisplayVsyncPeriod_enc(void *self , uint32_t displayId)
+{
 
-		memcpy(ptr, &displayId, 4); ptr += 4;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + 4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcGetDisplayVsyncPeriod;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+                memcpy(ptr, &displayId, 4); ptr += 4;
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
+
+
+        int retval;
+        stream->readback(&retval, 4);
+        if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
+        if (useChecksum) {
+                unsigned char *checksumBufPtr = NULL;
+                unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+                if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+                stream->readback(checksumBufPtr, checksumSize);
+                if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+                    ALOGE("rcDestroyClientImage: GL communication error, please report this issue to b.android.com.\n");
+                    abort();
+                }
+        }
+        return retval;
+}
 
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
 
+void rcPostLayer_enc(void *self , const char* name, uint32_t colorBuffer, float alpha, int32_t sourceCropLeft, int32_t sourceCropTop, int32_t sourceCropRight, int32_t sourceCropBottom, int32_t displayFrameLeft, int32_t displayFrameTop, int32_t displayFrameRight, int32_t displayFrameBottom)
+{
+
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
+
+        const unsigned int __size_name =  (strlen(name) + 1);
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8 + __size_name + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1*4;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcPostLayer;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
+
+        *(unsigned int *)(ptr) = __size_name; ptr += 4;
+        memcpy(ptr, name, __size_name);ptr += __size_name;
+                memcpy(ptr, &colorBuffer, 4); ptr += 4;
+                memcpy(ptr, &alpha, 4); ptr += 4;
+                memcpy(ptr, &sourceCropLeft, 4); ptr += 4;
+                memcpy(ptr, &sourceCropTop, 4); ptr += 4;
+                memcpy(ptr, &sourceCropRight, 4); ptr += 4;
+                memcpy(ptr, &sourceCropBottom, 4); ptr += 4;
+                memcpy(ptr, &displayFrameLeft, 4); ptr += 4;
+                memcpy(ptr, &displayFrameTop, 4); ptr += 4;
+                memcpy(ptr, &displayFrameRight, 4); ptr += 4;
+                memcpy(ptr, &displayFrameBottom, 4); ptr += 4;
+
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
 
-	int retval;
-	stream->readback(&retval, 4);
-	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
-	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
-			ALOGE("rcGetDisplayHeight: GL communication error, please report this issue to b.android.com.\n");
-			abort();
-		}
-	}
-	return retval;
 }
 
-int rcGetDisplayDpiX_enc(void *self , uint32_t displayId)
+void rcPostAllLayersDone_enc(void *self )
 {
 
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
-
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcGetDisplayDpiX;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
+        renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
+        IOStream *stream = ctx->m_stream;
+        ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
+        bool useChecksum = checksumCalculator->getVersion() > 0;
 
-		memcpy(ptr, &displayId, 4); ptr += 4;
+         unsigned char *ptr;
+         unsigned char *buf;
+         const size_t sizeWithoutChecksum = 8;
+         const size_t checksumSize = checksumCalculator->checksumByteSize();
+         const size_t totalSize = sizeWithoutChecksum + checksumSize;
+        buf = stream->alloc(totalSize);
+        ptr = buf;
+        int tmp = OP_rcPostAllLayersDone;memcpy(ptr, &tmp, 4); ptr += 4;
+        memcpy(ptr, &totalSize, 4);  ptr += 4;
 
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
 
+        if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
+        if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
 
-	int retval;
-	stream->readback(&retval, 4);
-	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
-	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
-			ALOGE("rcGetDisplayDpiX: GL communication error, please report this issue to b.android.com.\n");
-			abort();
-		}
-	}
-	return retval;
 }
 
-int rcGetDisplayDpiY_enc(void *self , uint32_t displayId)
+
+int rcUpdateColorBufferDMA_enc(void *self , uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels, uint32_t pixels_size)
 {
 
 	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
@@ -1215,17 +1403,26 @@ int rcGetDisplayDpiY_enc(void *self , uint32_t displayId)
 	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
 	bool useChecksum = checksumCalculator->getVersion() > 0;
 
+	const unsigned int __size_pixels =  pixels_size;
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 4 + 1*4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
 	ptr = buf;
-	int tmp = OP_rcGetDisplayDpiY;memcpy(ptr, &tmp, 4); ptr += 4;
+	int tmp = OP_rcUpdateColorBufferDMA;memcpy(ptr, &tmp, 4); ptr += 4;
 	memcpy(ptr, &totalSize, 4);  ptr += 4;
 
-		memcpy(ptr, &displayId, 4); ptr += 4;
+		memcpy(ptr, &colorbuffer, 4); ptr += 4;
+		memcpy(ptr, &x, 4); ptr += 4;
+		memcpy(ptr, &y, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &format, 4); ptr += 4;
+		memcpy(ptr, &type, 4); ptr += 4;
+	*(uint64_t *)(ptr) = ctx->lockAndWriteDma(pixels, __size_pixels); ptr += 8;
+		memcpy(ptr, &pixels_size, 4); ptr += 4;
 
 	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
 	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
@@ -1235,17 +1432,19 @@ int rcGetDisplayDpiY_enc(void *self , uint32_t displayId)
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
-			ALOGE("rcGetDisplayDpiY: GL communication error, please report this issue to b.android.com.\n");
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("rcUpdateColorBufferDMA: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
 	}
 	return retval;
 }
 
-int rcGetDisplayVsyncPeriod_enc(void *self , uint32_t displayId)
+uint32_t rcCreateColorBufferDMA_enc(void *self , uint32_t width, uint32_t height, GLenum internalFormat, int frameworkFormat)
 {
 
 	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
@@ -1255,95 +1454,39 @@ int rcGetDisplayVsyncPeriod_enc(void *self , uint32_t displayId)
 
 	 unsigned char *ptr;
 	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + 4;
+	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
 	 const size_t checksumSize = checksumCalculator->checksumByteSize();
 	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
 	buf = stream->alloc(totalSize);
 	ptr = buf;
-	int tmp = OP_rcGetDisplayVsyncPeriod;memcpy(ptr, &tmp, 4); ptr += 4;
+	int tmp = OP_rcCreateColorBufferDMA;memcpy(ptr, &tmp, 4); ptr += 4;
 	memcpy(ptr, &totalSize, 4);  ptr += 4;
 
-		memcpy(ptr, &displayId, 4); ptr += 4;
+		memcpy(ptr, &width, 4); ptr += 4;
+		memcpy(ptr, &height, 4); ptr += 4;
+		memcpy(ptr, &internalFormat, 4); ptr += 4;
+		memcpy(ptr, &frameworkFormat, 4); ptr += 4;
 
 	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
 	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
 
 
-	int retval;
+	uint32_t retval;
 	stream->readback(&retval, 4);
 	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
 	if (useChecksum) {
-		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
-		stream->readback(checksumBuf.get(), checksumSize);
-		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
-			ALOGE("rcGetDisplayVsyncPeriod: GL communication error, please report this issue to b.android.com.\n");
+		unsigned char *checksumBufPtr = NULL;
+		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
+		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
+		stream->readback(checksumBufPtr, checksumSize);
+		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
+			ALOGE("rcCreateColorBufferDMA: GL communication error, please report this issue to b.android.com.\n");
 			abort();
 		}
 	}
 	return retval;
 }
 
-void rcPostLayer_enc(void *self , const char* name, uint32_t colorBuffer, float alpha, int32_t sourceCropLeft, int32_t sourceCropTop, int32_t sourceCropRight, int32_t sourceCropBottom, int32_t displayFrameLeft, int32_t displayFrameTop, int32_t displayFrameRight, int32_t displayFrameBottom)
-{
-
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
-
-	const unsigned int __size_name =  (strlen(name) + 1);
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8 + __size_name + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1*4;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcPostLayer;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
-
-	*(unsigned int *)(ptr) = __size_name; ptr += 4;
-	memcpy(ptr, name, __size_name);ptr += __size_name;
-		memcpy(ptr, &colorBuffer, 4); ptr += 4;
-		memcpy(ptr, &alpha, 4); ptr += 4;
-		memcpy(ptr, &sourceCropLeft, 4); ptr += 4;
-		memcpy(ptr, &sourceCropTop, 4); ptr += 4;
-		memcpy(ptr, &sourceCropRight, 4); ptr += 4;
-		memcpy(ptr, &sourceCropBottom, 4); ptr += 4;
-		memcpy(ptr, &displayFrameLeft, 4); ptr += 4;
-		memcpy(ptr, &displayFrameTop, 4); ptr += 4;
-		memcpy(ptr, &displayFrameRight, 4); ptr += 4;
-		memcpy(ptr, &displayFrameBottom, 4); ptr += 4;
-
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
-
-}
-
-void rcPostAllLayersDone_enc(void *self )
-{
-
-	renderControl_encoder_context_t *ctx = (renderControl_encoder_context_t *)self;
-	IOStream *stream = ctx->m_stream;
-	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
-	bool useChecksum = checksumCalculator->getVersion() > 0;
-
-	 unsigned char *ptr;
-	 unsigned char *buf;
-	 const size_t sizeWithoutChecksum = 8;
-	 const size_t checksumSize = checksumCalculator->checksumByteSize();
-	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
-	buf = stream->alloc(totalSize);
-	ptr = buf;
-	int tmp = OP_rcPostAllLayersDone;memcpy(ptr, &tmp, 4); ptr += 4;
-	memcpy(ptr, &totalSize, 4);  ptr += 4;
-
-
-	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
-	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;
-
-}
-
 }  // namespace
 
 renderControl_encoder_context_t::renderControl_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator)
@@ -1379,14 +1522,22 @@ renderControl_encoder_context_t::renderControl_encoder_context_t(IOStream *strea
 	this->rcOpenColorBuffer2 = &rcOpenColorBuffer2_enc;
 	this->rcCreateClientImage = &rcCreateClientImage_enc;
 	this->rcDestroyClientImage = &rcDestroyClientImage_enc;
-	this->rcSelectChecksumCalculator = &rcSelectChecksumCalculator_enc;
-	this->rcGetNumDisplays = &rcGetNumDisplays_enc;
-	this->rcGetDisplayWidth = &rcGetDisplayWidth_enc;
-	this->rcGetDisplayHeight = &rcGetDisplayHeight_enc;
-	this->rcGetDisplayDpiX = &rcGetDisplayDpiX_enc;
-	this->rcGetDisplayDpiY = &rcGetDisplayDpiY_enc;
-	this->rcGetDisplayVsyncPeriod = &rcGetDisplayVsyncPeriod_enc;
-	this->rcPostLayer = &rcPostLayer_enc;
-	this->rcPostAllLayersDone = &rcPostAllLayersDone_enc;
+	//this->rcSelectChecksumHelper = &rcSelectChecksumHelper_enc;
+	//this->rcCreateSyncKHR = &rcCreateSyncKHR_enc;
+	//this->rcClientWaitSyncKHR = &rcClientWaitSyncKHR_enc;
+	//this->rcFlushWindowColorBufferAsync = &rcFlushWindowColorBufferAsync_enc;
+	//this->rcDestroySyncKHR = &rcDestroySyncKHR_enc;
+	//this->rcSetPuid = &rcSetPuid_enc;
+        this->rcSelectChecksumCalculator = &rcSelectChecksumCalculator_enc;
+        this->rcGetNumDisplays = &rcGetNumDisplays_enc;
+        this->rcGetDisplayWidth = &rcGetDisplayWidth_enc;
+        this->rcGetDisplayHeight = &rcGetDisplayHeight_enc;
+        this->rcGetDisplayDpiX = &rcGetDisplayDpiX_enc;
+        this->rcGetDisplayDpiY = &rcGetDisplayDpiY_enc;
+        this->rcGetDisplayVsyncPeriod = &rcGetDisplayVsyncPeriod_enc;
+        this->rcPostLayer = &rcPostLayer_enc;
+        this->rcPostAllLayersDone = &rcPostAllLayersDone_enc;
+	this->rcUpdateColorBufferDMA = &rcUpdateColorBufferDMA_enc;
+	this->rcCreateColorBufferDMA = &rcCreateColorBufferDMA_enc;
 }
 
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.h b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.h
index 628cff3..9c7b45f 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.h
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_enc.h
@@ -19,6 +19,7 @@ struct renderControl_encoder_context_t : public renderControl_client_context_t {
 	ChecksumCalculator *m_checksumCalculator;
 
 	renderControl_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator);
+	virtual uint64_t lockAndWriteDma(void* data, uint32_t sz) { return 0; }
 };
 
-#endif  // GUARD_renderControl_encoder_context_t
\ No newline at end of file
+#endif  // GUARD_renderControl_encoder_context_t
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_entry.cpp b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_entry.cpp
index 822bb80..e8d767a 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_entry.cpp
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_entry.cpp
@@ -4,7 +4,6 @@
 #include <stdlib.h>
 #include "renderControl_client_context.h"
 
-#ifndef GL_TRUE
 extern "C" {
 	GLint rcGetRendererVersion();
 	EGLint rcGetEGLVersion(EGLint* major, EGLint* minor);
@@ -34,18 +33,26 @@ extern "C" {
 	int rcOpenColorBuffer2(uint32_t colorbuffer);
 	uint32_t rcCreateClientImage(uint32_t context, EGLenum target, GLuint buffer);
 	int rcDestroyClientImage(uint32_t image);
-	void rcSelectChecksumCalculator(uint32_t newProtocol, uint32_t reserved);
-	int rcGetNumDisplays();
-	int rcGetDisplayWidth(uint32_t displayId);
-	int rcGetDisplayHeight(uint32_t displayId);
-	int rcGetDisplayDpiX(uint32_t displayId);
-	int rcGetDisplayDpiY(uint32_t displayId);
-	int rcGetDisplayVsyncPeriod(uint32_t displayId);
-	void rcPostLayer(const char* name, uint32_t colorBuffer, float alpha, int32_t sourceCropLeft, int32_t sourceCropTop, int32_t sourceCropRight, int32_t sourceCropBottom, int32_t displayFrameLeft, int32_t displayFrameTop, int32_t displayFrameRight, int32_t displayFrameBottom);
-	void rcPostAllLayersDone();
+//	void rcSelectChecksumHelper(uint32_t newProtocol, uint32_t reserved);
+//	void rcCreateSyncKHR(EGLenum type, EGLint* attribs, uint32_t num_attribs, int destroy_when_signaled, uint64_t* glsync_out, uint64_t* syncthread_out);
+//	EGLint rcClientWaitSyncKHR(uint64_t sync, EGLint flags, uint64_t timeout);
+//	void rcFlushWindowColorBufferAsync(uint32_t windowSurface);
+//	int rcDestroySyncKHR(uint64_t sync);
+//	void rcSetPuid(uint64_t puid);
+        void rcSelectChecksumCalculator(uint32_t newProtocol, uint32_t reserved);
+        int rcGetNumDisplays();
+        int rcGetDisplayWidth(uint32_t displayId);
+        int rcGetDisplayHeight(uint32_t displayId);
+        int rcGetDisplayDpiX(uint32_t displayId);
+        int rcGetDisplayDpiY(uint32_t displayId);
+        int rcGetDisplayVsyncPeriod(uint32_t displayId);
+        void rcPostLayer(const char* name, uint32_t colorBuffer, float alpha, int32_t sourceCropLeft, int32_t sourceCropTop, int32_t sourceCropRight, int32_t sourceCropBottom, int32_t displayFrameLeft, int32_t displayFrameTop, int32_t displayFrameRight, int32_t displayFrameBottom);
+        void rcPostAllLayersDone();
+
+	int rcUpdateColorBufferDMA(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels, uint32_t pixels_size);
+	uint32_t rcCreateColorBufferDMA(uint32_t width, uint32_t height, GLenum internalFormat, int frameworkFormat);
 };
 
-#endif
 #ifndef GET_CONTEXT
 static renderControl_client_context_t::CONTEXT_ACCESSOR_TYPE *getCurrentContext = NULL;
 void renderControl_client_context_t::setContextAccessor(CONTEXT_ACCESSOR_TYPE *f) { getCurrentContext = f; }
@@ -219,58 +226,105 @@ int rcDestroyClientImage(uint32_t image)
 	GET_CONTEXT;
 	return ctx->rcDestroyClientImage(ctx, image);
 }
+/*
+void rcSelectChecksumHelper(uint32_t newProtocol, uint32_t reserved)
+{
+	GET_CONTEXT;
+	ctx->rcSelectChecksumHelper(ctx, newProtocol, reserved);
+}
 
-void rcSelectChecksumCalculator(uint32_t newProtocol, uint32_t reserved)
+void rcCreateSyncKHR(EGLenum type, EGLint* attribs, uint32_t num_attribs, int destroy_when_signaled, uint64_t* glsync_out, uint64_t* syncthread_out)
 {
 	GET_CONTEXT;
-	ctx->rcSelectChecksumCalculator(ctx, newProtocol, reserved);
+	ctx->rcCreateSyncKHR(ctx, type, attribs, num_attribs, destroy_when_signaled, glsync_out, syncthread_out);
 }
 
-int rcGetNumDisplays()
+EGLint rcClientWaitSyncKHR(uint64_t sync, EGLint flags, uint64_t timeout)
 {
 	GET_CONTEXT;
-	return ctx->rcGetNumDisplays(ctx);
+	return ctx->rcClientWaitSyncKHR(ctx, sync, flags, timeout);
 }
 
-int rcGetDisplayWidth(uint32_t displayId)
+void rcFlushWindowColorBufferAsync(uint32_t windowSurface)
 {
 	GET_CONTEXT;
-	return ctx->rcGetDisplayWidth(ctx, displayId);
+	ctx->rcFlushWindowColorBufferAsync(ctx, windowSurface);
 }
 
-int rcGetDisplayHeight(uint32_t displayId)
+int rcDestroySyncKHR(uint64_t sync)
 {
 	GET_CONTEXT;
-	return ctx->rcGetDisplayHeight(ctx, displayId);
+	return ctx->rcDestroySyncKHR(ctx, sync);
 }
 
-int rcGetDisplayDpiX(uint32_t displayId)
+void rcSetPuid(uint64_t puid)
 {
 	GET_CONTEXT;
-	return ctx->rcGetDisplayDpiX(ctx, displayId);
+	ctx->rcSetPuid(ctx, puid);
+}
+*/
+void rcSelectChecksumCalculator(uint32_t newProtocol, uint32_t reserved)
+{
+        GET_CONTEXT;
+        ctx->rcSelectChecksumCalculator(ctx, newProtocol, reserved);
 }
 
+int rcGetNumDisplays()
+{
+        GET_CONTEXT;
+        return ctx->rcGetNumDisplays(ctx);
+}
+
+int rcGetDisplayWidth(uint32_t displayId)
+{
+        GET_CONTEXT;
+        return ctx->rcGetDisplayWidth(ctx, displayId);
+}
+
+int rcGetDisplayHeight(uint32_t displayId)
+{
+        GET_CONTEXT;
+        return ctx->rcGetDisplayHeight(ctx, displayId);
+}
+
+int rcGetDisplayDpiX(uint32_t displayId)
+{
+        GET_CONTEXT;
+        return ctx->rcGetDisplayDpiX(ctx, displayId);
+}
 int rcGetDisplayDpiY(uint32_t displayId)
 {
-	GET_CONTEXT;
-	return ctx->rcGetDisplayDpiY(ctx, displayId);
+        GET_CONTEXT;
+        return ctx->rcGetDisplayDpiY(ctx, displayId);
 }
 
 int rcGetDisplayVsyncPeriod(uint32_t displayId)
 {
-	GET_CONTEXT;
-	return ctx->rcGetDisplayVsyncPeriod(ctx, displayId);
+        GET_CONTEXT;
+        return ctx->rcGetDisplayVsyncPeriod(ctx, displayId);
 }
 
 void rcPostLayer(const char* name, uint32_t colorBuffer, float alpha, int32_t sourceCropLeft, int32_t sourceCropTop, int32_t sourceCropRight, int32_t sourceCropBottom, int32_t displayFrameLeft, int32_t displayFrameTop, int32_t displayFrameRight, int32_t displayFrameBottom)
 {
-	GET_CONTEXT;
-	ctx->rcPostLayer(ctx, name, colorBuffer, alpha, sourceCropLeft, sourceCropTop, sourceCropRight, sourceCropBottom, displayFrameLeft, displayFrameTop, displayFrameRight, displayFrameBottom);
+        GET_CONTEXT;
+        ctx->rcPostLayer(ctx, name, colorBuffer, alpha, sourceCropLeft, sourceCropTop, sourceCropRight, sourceCropBottom, displayFrameLeft, displayFrameTop, displayFrameRight, displayFrameBottom);
 }
 
 void rcPostAllLayersDone()
 {
+        GET_CONTEXT;
+        ctx->rcPostAllLayersDone(ctx);
+}
+
+int rcUpdateColorBufferDMA(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels, uint32_t pixels_size)
+{
+	GET_CONTEXT;
+	return ctx->rcUpdateColorBufferDMA(ctx, colorbuffer, x, y, width, height, format, type, pixels, pixels_size);
+}
+
+uint32_t rcCreateColorBufferDMA(uint32_t width, uint32_t height, GLenum internalFormat, int frameworkFormat)
+{
 	GET_CONTEXT;
-	ctx->rcPostAllLayersDone(ctx);
+	return ctx->rcCreateColorBufferDMA(ctx, width, height, internalFormat, frameworkFormat);
 }
 
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_ftable.h b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_ftable.h
index da81858..6488c01 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_ftable.h
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_ftable.h
@@ -36,15 +36,23 @@ static const struct _renderControl_funcs_by_name {
 	{"rcOpenColorBuffer2", (void*)rcOpenColorBuffer2},
 	{"rcCreateClientImage", (void*)rcCreateClientImage},
 	{"rcDestroyClientImage", (void*)rcDestroyClientImage},
-	{"rcSelectChecksumCalculator", (void*)rcSelectChecksumCalculator},
-	{"rcGetNumDisplays", (void*)rcGetNumDisplays},
-	{"rcGetDisplayWidth", (void*)rcGetDisplayWidth},
-	{"rcGetDisplayHeight", (void*)rcGetDisplayHeight},
-	{"rcGetDisplayDpiX", (void*)rcGetDisplayDpiX},
-	{"rcGetDisplayDpiY", (void*)rcGetDisplayDpiY},
-	{"rcGetDisplayVsyncPeriod", (void*)rcGetDisplayVsyncPeriod},
-	{"rcPostLayer", (void*)rcPostLayer},
-	{"rcPostAllLayersDone", (void*)rcPostAllLayersDone},
+//	{"rcSelectChecksumHelper", (void*)rcSelectChecksumHelper},
+//	{"rcCreateSyncKHR", (void*)rcCreateSyncKHR},
+//	{"rcClientWaitSyncKHR", (void*)rcClientWaitSyncKHR},
+//	{"rcFlushWindowColorBufferAsync", (void*)rcFlushWindowColorBufferAsync},
+//	{"rcDestroySyncKHR", (void*)rcDestroySyncKHR},
+//	{"rcSetPuid", (void*)rcSetPuid},
+        {"rcSelectChecksumCalculator", (void*)rcSelectChecksumCalculator},
+        {"rcGetNumDisplays", (void*)rcGetNumDisplays},
+        {"rcGetDisplayWidth", (void*)rcGetDisplayWidth},
+        {"rcGetDisplayHeight", (void*)rcGetDisplayHeight},
+        {"rcGetDisplayDpiX", (void*)rcGetDisplayDpiX},
+        {"rcGetDisplayDpiY", (void*)rcGetDisplayDpiY},
+        {"rcGetDisplayVsyncPeriod", (void*)rcGetDisplayVsyncPeriod},
+        {"rcPostLayer", (void*)rcPostLayer},
+        {"rcPostAllLayersDone", (void*)rcPostAllLayersDone},
+	{"rcUpdateColorBufferDMA", (void*)rcUpdateColorBufferDMA},
+	{"rcCreateColorBufferDMA", (void*)rcCreateColorBufferDMA},
 };
 static const int renderControl_num_funcs = sizeof(renderControl_funcs_by_name) / sizeof(struct _renderControl_funcs_by_name);
 
diff --git a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_opcodes.h b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_opcodes.h
index e7cf12d..68d44ca 100644
--- a/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_opcodes.h
+++ b/vendor/anbox/android/opengl/system/renderControl_enc/renderControl_opcodes.h
@@ -31,16 +31,17 @@
 #define OP_rcOpenColorBuffer2 					10025
 #define OP_rcCreateClientImage 					10026
 #define OP_rcDestroyClientImage 					10027
-#define OP_rcSelectChecksumCalculator 					10028
-#define OP_rcGetNumDisplays 					10029
-#define OP_rcGetDisplayWidth 					10030
-#define OP_rcGetDisplayHeight 					10031
-#define OP_rcGetDisplayDpiX 					10032
-#define OP_rcGetDisplayDpiY 					10033
-#define OP_rcGetDisplayVsyncPeriod 					10034
-#define OP_rcPostLayer 					10035
-#define OP_rcPostAllLayersDone 					10036
-#define OP_last 					10037
-
+#define OP_rcSelectChecksumCalculator                                  10028
+#define OP_rcGetNumDisplays                                    10029
+#define OP_rcGetDisplayWidth                                   10030
+#define OP_rcGetDisplayHeight                                  10031
+#define OP_rcGetDisplayDpiX                                    10032
+#define OP_rcGetDisplayDpiY                                    10033
+#define OP_rcGetDisplayVsyncPeriod                                     10034
+#define OP_rcPostLayer                                         10035
+#define OP_rcPostAllLayersDone                                         10036
+#define OP_rcUpdateColorBufferDMA 					10037
+#define OP_rcCreateColorBufferDMA 					10038
+#define OP_last                                                10039
 
 #endif
